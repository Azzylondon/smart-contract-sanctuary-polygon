// SPDX-License-Identifier: MIT
pragma solidity 0.8.6;

import "./VRFTypes.sol";

/**
 * @title BatchVRFCoordinatorV2
 * @notice The BatchVRFCoordinatorV2 contract acts as a proxy to write many random responses to the
 *   provided VRFCoordinatorV2 contract efficiently in a single transaction.
 */
contract BatchVRFCoordinatorV2 {
	VRFCoordinatorV2 public immutable COORDINATOR;

	constructor(address coordinatorAddr) {
		COORDINATOR = VRFCoordinatorV2(coordinatorAddr);
	}

	/**
	 * @notice fulfills multiple randomness requests with the provided proofs and commitments.
	 * @param proofs the randomness proofs generated by the VRF provider
	 * @param rcs the request commitments corresponding to the randomness proofs
	 */
	function fulfillRandomWords(VRFTypes.Proof[] memory proofs, VRFTypes.RequestCommitment[] memory rcs) external {
		require(proofs.length == rcs.length, "input array arg lengths mismatch");
		for (uint256 i = 0; i < proofs.length; i++) {
			COORDINATOR.fulfillRandomWords(proofs[i], rcs[i]);
		}
	}
}

interface VRFCoordinatorV2 {
	function fulfillRandomWords(VRFTypes.Proof memory proof, VRFTypes.RequestCommitment memory rc) external returns (uint96);
}

// SPDX-License-Identifier: MIT
pragma solidity 0.8.6;

library VRFTypes {
    struct Proof {
		uint256[2] pk;
		uint256[2] gamma;
		uint256 c;
		uint256 s;
		uint256 seed;
		address uWitness;
		uint256[2] cGammaWitness;
		uint256[2] sHashWitness;
		uint256 zInv;
	}

	struct RequestCommitment {
	    uint64 blockNum;
	    uint64 subId;
	    uint32 callbackGasLimit;
	    uint32 numWords;
	    address sender;
	}
}