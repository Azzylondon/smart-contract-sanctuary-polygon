// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

// AutomationCompatible.sol imports the functions from both ./AutomationBase.sol and
// ./interfaces/AutomationCompatibleInterface.sol
import "@chainlink/contracts/src/v0.8/AutomationCompatible.sol";
//import "./lyncrent.sol";
import "./Ilyncrent.sol";

/**
 * THIS IS AN EXAMPLE CONTRACT THAT USES HARDCODED VALUES FOR CLARITY.
 * THIS IS AN EXAMPLE CONTRACT THAT USES UN-AUDITED CODE.
 * DO NOT USE THIS CODE IN PRODUCTION.
 */
contract automation is AutomationCompatibleInterface {
    /**
     * Public counter variable
     */
    uint256 public counter;
    Ilyncrent.RentersArrayStruct renterStruct;
    //  enum NFTStandard {
    //     E721,
    //     E1155
    // }
    // struct RentersArrayStruct{
    //     NFTStandard nftStandard;
    //     address nftAddress;
    //     uint256 tokenId;
    //     address sellerAddress;
    //     address renterAddress;
    //     uint startTimeStamp;
    //     uint256 rentedDuration;
    // }

    //imported contract logic and
    // enum NFTStandard {
    //     E721,
    //     E1155
    // }
    // struct RentersArrayStruct{
    //     NFTStandard nftStandard;
    //     address nftAddress;
    //     uint256 tokenId;
    //     address sellerAddress;
    //     address renterAddress;
    //     uint startTimeStamp;
    //     uint256 rentedDuration;
    // }
    /**
     * Use an interval in seconds and a timestamp to slow execution of Upkeep
     */
    uint256 public immutable interval;
    uint256 public lastTimeStamp;
    address lyncAddress;

    constructor(uint256 updateInterval, address addLync) {
        interval = updateInterval;
        lastTimeStamp = block.timestamp;

        lyncAddress = addLync;
    }

    function checkUpkeep(
        bytes calldata /* checkData */
    )
        external
        view
        override
        returns (bool upkeepNeeded, bytes memory performData)
    {
        upkeepNeeded = false;
        // We don't use the checkData in this example. The checkData is defined when the Upkeep was registered.
        if (Ilyncrent(lyncAddress).checkTokenDurationExp().length != 0) {
            upkeepNeeded = true;
        }
        bytes memory callData = abi.encode(
            Ilyncrent(lyncAddress).checkTokenDurationExp()
        );
        return (upkeepNeeded, callData);
    }

    function performUpkeep(bytes calldata performData) external override {
        Ilyncrent.RentersArrayStruct[] memory _renterArray = abi.decode(
            performData,
            (Ilyncrent.RentersArrayStruct[])
        );
        Ilyncrent(lyncAddress).updateRentersDetails(_renterArray);
        // We don't use the performData in this example. The performData is generated by the Automation Node's call to your checkUpkeep function
    }

    // function decode(bytes memory data) public pure returns (renterStruct[] memory _renterArray) {
    //     (_renterArray) = abi.decode(data, (renterStruct[]));
    // }
}

// SPDX-License-Identifier: MIT
pragma solidity ^0.8.3;

// import "@openzeppelin/contracts/token/ERC721/IERC721.sol";
// import "@openzeppelin/contracts/token/ERC1155/IERC1155.sol";
// import "@openzeppelin/contracts/security/ReentrancyGuard.sol";

// error PriceNotMet(address nftAddress, uint256 tokenId, uint256 price);
// error ItemAlreadyRented(
// );
// //error NotListedForRent(address nftAddress, uint256 tokenId);
// error NoSellersForThisAddressTokenId();
// error NotEnoughTokensListed(
//     address nftAddress,
//     uint256 tokenId,
//     uint256 tokenQuantity
// );
// error AlreadyListedForRent(
//     address nftAddress,
//     uint256 tokenId,
//     uint256 tokenQuantity
// );
// error ItemNotRentedByUser(
//     uint256 tokenQuantity,
//     address sellerAddress,
//     address renterAddress
// );
// error cantRentOwnedNfts(uint256 tokenId, address spender, address nftAddress);
// error NoRenterWithAddressForNftAndSellerAddress(
//     address sellerAddress,
//     address renterAddress
// );
// error NFTnotYetListed();
// error PriceMustBeAboveZero();
// error NotOwner();
// error NoProceeds();
// error TokenStandardNotSupported();
// error NoSuchListing();
// error NFTdoesNotExist(); //newly added
// error DurationMustBeAtleastOneDay();
// error DurationMustBeLessThanOrEqualTomaxRentDuration();

interface Ilyncrent {
    enum NFTStandard {
        E721,
        E1155
    }
    struct RentersArrayStruct {
        NFTStandard nftStandard;
        address nftAddress;
        uint256 tokenId;
        address sellerAddress;
        address renterAddress;
        uint256 startTimeStamp;
        uint256 rentedDuration;
    }

    // struct tokenRenter {
    //     address renterAddress;
    //     uint256 tokenQuantityRented;
    //     uint256 rentedDuration;
    //     uint startTimeStamp;
    // }
    // struct tokenSeller {
    //     NFTStandard nftStandard;
    //     address sellerAddress;
    //     uint256 tokenQuantity; //listed quty of NFT
    //     uint256 pricePerDay;
    //     uint256 maxRentDuration;
    //     uint256 tokenQuantityAlreadyRented; //Already rented
    //     tokenRenter[]  renterArray;
    // }

    // //mapping(address => tokenRenter) renterTempMapping;

    // event ItemListedForRent(
    //     address indexed seller,
    //     address indexed nftAddress,
    //     uint256 indexed tokenId,
    //     NFTStandard nftStandard,
    //     uint256 tokenQuantity,
    //     uint256 pricePerDay,
    //     uint256 maxRentDuration
    // );

    // event UpdateItemlisted(
    //     address indexed seller,
    //     address indexed nftAddress,
    //     uint256 indexed tokenId,
    //     NFTStandard nftStandard,
    //     uint256 tokenQuantity,
    //     uint256 pricePerDay,
    //     uint256 maxRentDuration
    // );

    // event ItemRented(
    //     address indexed renter,
    //     address indexed nftAddress,
    //     uint256 indexed tokenId,
    //     NFTStandard nftStandard,
    //     uint256 tokenQuantity,
    //     address sellerAddress,
    //     uint256 price
    //     //uint256 duration //no of days
    // );

    // event ItemReturned(
    //     address indexed renter,
    //     address indexed nftAddress,
    //     uint256 indexed tokenId,
    //     NFTStandard nftStandard,
    //     uint256 tokenQuantity,
    //     address sellerAddress,
    //     uint256 price,
    //     uint256 duration //no of days
    // );

    // event ItemDeListed(
    //     address indexed seller,
    //     address indexed nftAddress,
    //     uint256 indexed tokenId,
    //     NFTStandard nftStandard,
    //     uint256 tokenQuantity
    // );
    // constructor(){
    //     _owner = msg.sender;
    // }

    // mapping(address => mapping(uint256 => tokenSeller[]))
    //     public allNftContractListings; //listings per nftaddress based on tokenids
    // mapping(address => uint256) private s_proceeds;
    // RentersArrayStruct[] private renterStructArray;

    // modifier notListedForRent(
    //     NFTStandard _nftStandard,
    //     address _nftAddress,
    //     uint256 _tokenId,
    //     uint256 _tokenQuantity
    // ) {
    //     tokenSeller[] storage listings = allNftContractListings[_nftAddress][
    //         _tokenId
    //     ];

    //     if (listings.length != 0) {
    //         uint256 listingAllowed;
    //         uint256 index = getIndexOfArray(listings, msg.sender);

    //         if(_nftStandard == NFTStandard.E1155){
    //             IERC1155 nft = IERC1155(_nftAddress);
    //             uint256 ownerAmount = nft.balanceOf(msg.sender, _tokenId);
    //             if(ownerAmount > 0){
    //                 listingAllowed = ownerAmount - listings[index].tokenQuantity;
    //                 if (listingAllowed < _tokenQuantity) {
    //                     revert AlreadyListedForRent(
    //                         _nftAddress,
    //                         _tokenId,
    //                         _tokenQuantity
    //                     );
    //                 }
    //             }else{
    //                 revert NotOwner();
    //             }

    //         }else if(_nftStandard == NFTStandard.E721){
    //             if(listings[index].tokenQuantity == 1){
    //                 revert AlreadyListedForRent(
    //                     _nftAddress,
    //                     _tokenId,
    //                     _tokenQuantity
    //                 );
    //             }
    //         }else {
    //             revert TokenStandardNotSupported();
    //         }

    //     }
    //     _;
    // }

    // modifier isListedForRent(
    //     tokenSeller[] storage listings,
    //     uint256 _tokenQuantity
    // ){
    //     uint index = getIndexOfArray(listings, msg.sender);
    //     if(listings.length > 0){
    //         require(listings[index].sellerAddress == msg.sender, "You are not the owner of this listing");
    //         if(listings[index].tokenQuantity > 0){
    //             _;
    //         }else {
    //             revert NFTnotYetListed();
    //         }
    //     }else{
    //         revert NFTnotYetListed();
    //     }
    // }

    //     modifier isCurrentlyRentedByUser(
    //         tokenSeller[] storage listings,
    //         uint256 _tokenQuantity,
    //         address _sellerAddress
    //     ) {
    //         if (listings.length > 0) {
    //             uint256 index = getIndexOfArray(listings, _sellerAddress);
    //             if (listings[index].renterArray.length > 0) {
    //                 tokenRenter[]  storage renters = listings[index].renterArray;
    //                 uint256 indexRenter = getIndexOfRenterArray(
    //                     renters,
    //                     msg.sender
    //                 );
    //                 if (renters[indexRenter].tokenQuantityRented < _tokenQuantity) {
    //                     revert ItemNotRentedByUser(
    //                         _tokenQuantity,
    //                         _sellerAddress,
    //                         msg.sender
    //                     );
    //                 }
    //             } else {
    //                 revert NoRenterWithAddressForNftAndSellerAddress(
    //                     _sellerAddress,
    //                     msg.sender
    //                 );
    //             }
    //         } else {
    //             revert NoSellersForThisAddressTokenId();
    //         }
    //         _;
    //     }

    //     modifier notAlreadyRentedSeller(
    //         tokenSeller[] storage listings,
    //         uint256 _tokenQuantity,
    //         address _sellerAddress
    //     ) {

    //         if (listings.length > 0) {
    //             //uint256 index = getIndexOfArray(listings, _sellerAddress);
    //             tokenSeller storage tokenSellerStorage = listings[getIndexOfArray(listings, _sellerAddress)];
    //             if (
    //                 tokenSellerStorage.tokenQuantity < 1
    //             ) {
    //                 revert NoSellersForThisAddressTokenId();
    //             } else if (
    //                 tokenSellerStorage.tokenQuantity <
    //                 _tokenQuantity
    //             ) {
    //                 revert ItemAlreadyRented();
    //             }
    //         } else {
    //             revert NoSellersForThisAddressTokenId();
    //         }
    //         _;
    //     }

    //     function listItemForRent(
    //         NFTStandard _nftStandard,
    //         uint256 _tokenId,
    //         uint256 _price,
    //         address _nftAddress,
    //         uint256 _tokenQuantity,
    //         uint256 _maxRentDuration
    //     )
    //         external
    //         notListedForRent(_nftStandard,_nftAddress, _tokenId, _tokenQuantity)
    //     {
    //         if (_price <= 0) {
    //             revert PriceMustBeAboveZero();
    //         }
    //         if (_maxRentDuration < 1) {
    //             revert DurationMustBeAtleastOneDay();
    //         }

    //         if(_nftStandard == NFTStandard.E721){
    //             require(_tokenQuantity == 1, "This NFT standard supports only 1 listing");
    //             IERC721 nft = IERC721(_nftAddress);
    //             address owner = nft.ownerOf(_tokenId);
    //             require(owner == msg.sender, "You Do not own the NFT");

    //         }else if(_nftStandard == NFTStandard.E1155){
    //             IERC1155 nft = IERC1155(_nftAddress);
    //             uint256 ownerAmount = nft.balanceOf(msg.sender, _tokenId);
    //             require(ownerAmount >= _tokenQuantity, "Not enough tokens owned by Address");
    //         }

    //         tokenSeller storage tokenSellerStorage = allNftContractListings[_nftAddress][_tokenId].push();

    //         tokenSellerStorage.nftStandard = _nftStandard;
    //         tokenSellerStorage.sellerAddress = msg.sender;
    //         tokenSellerStorage.tokenQuantity = _tokenQuantity;
    //         tokenSellerStorage.pricePerDay = _price;
    //         tokenSellerStorage.maxRentDuration = _maxRentDuration;
    //         tokenSellerStorage.tokenQuantityAlreadyRented = 0;
    //         //tokenSellerStorage.renterArray = new tokenRenter[](0);

    //         emit ItemListedForRent(
    //             msg.sender,
    //             _nftAddress,
    //             _tokenId,
    //             _nftStandard,
    //             _tokenQuantity,
    //             _price,
    //             _maxRentDuration
    //         );
    //     }

    //     function  updateListedItemForRent(
    //         NFTStandard _nftStandard,
    //         address _nftAddress,
    //         uint256 _tokenId,
    //         uint256 _price,
    //         uint256 _tokenQuantity,
    //         uint256 _maxRentDuration
    //     )
    //      external
    //      isListedForRent(
    //          allNftContractListings[
    //             _nftAddress
    //         ][_tokenId],
    //         _tokenQuantity)
    //     {
    //         require(_price > 0, "Price for listing should be greater than Zero");
    //         require(_maxRentDuration >= 1, "Max rent duration should be greater than or equal to 1");

    //         tokenSeller[] storage listings = allNftContractListings[_nftAddress][_tokenId];
    //         uint index = getIndexOfArray(listings, msg.sender);

    //         if(_nftStandard == NFTStandard.E721){
    //             require(_tokenQuantity == 1, "This NFT standard supports only 1 listing");
    //         }else if(_nftStandard == NFTStandard.E1155){
    //             IERC1155 nft = IERC1155(_nftAddress);
    //             uint256 ownerAmount = nft.balanceOf(msg.sender, _tokenId);
    //             require(ownerAmount >= listings[index].tokenQuantityAlreadyRented + _tokenQuantity,"Not Enough tokens owned by address");
    //         }

    //         tokenSeller storage tokenSellerStorage = listings[index];

    //         tokenSellerStorage.tokenQuantity = _tokenQuantity;
    //         tokenSellerStorage.pricePerDay = _price;
    //         tokenSellerStorage.maxRentDuration = _maxRentDuration;

    //         emit UpdateItemlisted(
    //             msg.sender,
    //             _nftAddress,
    //             _tokenId,
    //             _nftStandard,
    //             _tokenQuantity,
    //             _price,
    //             _maxRentDuration
    //         );
    //     }

    //     function delistItemsFromRent(
    //         NFTStandard _nftStandard,
    //         address _nftAddress,
    //         uint256 _tokenId,
    //         uint256 _tokenQuantity
    //     )
    //         external
    //          notAlreadyRentedSeller(
    //             allNftContractListings[
    //             _nftAddress
    //         ][_tokenId],
    //             _tokenQuantity,
    //             msg.sender
    //         )
    //     {

    //         if(_nftStandard == NFTStandard.E721){
    //             require(_tokenQuantity == 1, "This NFT standard supports only 1 listing");
    //             IERC721 nft = IERC721(_nftAddress);
    //             address owner = nft.ownerOf(_tokenId);
    //             require(owner == msg.sender, "You Do not own the NFT");

    //         }else if(_nftStandard == NFTStandard.E1155){
    //             IERC1155 nft = IERC1155(_nftAddress);
    //             uint256 ownerAmount = nft.balanceOf(msg.sender, _tokenId);
    //             require(ownerAmount > _tokenQuantity, "Not enough tokens owned by Address");
    //         }

    //         tokenSeller[] storage listings = allNftContractListings[
    //             _nftAddress
    //         ][_tokenId];
    //         uint256 index = getIndexOfArray(listings, msg.sender);
    //         tokenSeller storage tokenSellerStorage = listings[index];
    //         uint256 tokenNumber = tokenSellerStorage.tokenQuantity - _tokenQuantity;
    //         if (tokenNumber == 0) {
    //             //delete from storage the listing
    //             removeListing(listings,index);
    //         } else {
    //             tokenSellerStorage.tokenQuantity =
    //                 tokenSellerStorage.tokenQuantity -
    //                 _tokenQuantity;
    //         }
    //         emit ItemDeListed(
    //             msg.sender,
    //             _nftAddress,
    //             _tokenId,
    //             _nftStandard,
    //             _tokenQuantity
    //         );
    //     }

    //     function rentItem(
    //         NFTStandard _nftStandard,
    //         uint256 _duration,
    //         address _nftAddress,
    //         uint256 _tokenId,
    //         uint256 _tokenQuantity,
    //         address _sellerAddress
    //     )
    //         external
    //         payable
    //         notAlreadyRentedSeller(
    //             allNftContractListings[
    //             _nftAddress
    //         ][_tokenId],
    //             _tokenQuantity,
    //             _sellerAddress
    //         )
    //     {
    //         if(_nftStandard == NFTStandard.E721){
    //             require(_tokenQuantity == 1, "Token Quantity cannot be greater than 1 for ERC721 Standard");
    //         }

    //         tokenSeller[] storage listings = allNftContractListings[
    //             _nftAddress
    //         ][_tokenId];
    //         uint256 index = getIndexOfArray(listings, _sellerAddress);

    //         tokenSeller storage tokenSellerStorage = listings[index];
    //         require(
    //             tokenSellerStorage.tokenQuantity -
    //                 tokenSellerStorage.tokenQuantityAlreadyRented >=
    //                 _tokenQuantity,
    //             "Specifed token amount is not rented"
    //         );
    //         if (_duration > tokenSellerStorage.maxRentDuration) {
    //             revert DurationMustBeLessThanOrEqualTomaxRentDuration();
    //         }
    //         if (msg.sender == _sellerAddress) {
    //             revert cantRentOwnedNfts(_tokenId, msg.sender, _nftAddress);
    //         }
    //         if (_duration < 1) {
    //             revert DurationMustBeAtleastOneDay();
    //         }
    //         if (msg.value < tokenSellerStorage.pricePerDay * _duration*_tokenQuantity) {
    //             revert PriceNotMet(
    //                 _nftAddress,
    //                 _tokenId,
    //                 tokenSellerStorage.pricePerDay
    //             );
    //         }
    //         updateRentItemStorage(tokenSellerStorage, _tokenQuantity,_duration);
    //         addRenterStructArray(_nftStandard,_nftAddress,_tokenId,_sellerAddress, _duration);
    //         s_proceeds[_sellerAddress] = msg.value;

    //         emit ItemRented(
    //             msg.sender,
    //             _nftAddress,
    //             _tokenId,
    //             _nftStandard,
    //             _tokenQuantity,
    //             _sellerAddress,
    //             tokenSellerStorage.pricePerDay
    //             //_duration
    //         );
    //     }

    //     //Supporting the rentItem function
    //     function updateRentItemStorage(tokenSeller storage tokenSellerStorage,uint _tokenQuantity, uint _duration) private {

    //             //tokenSeller storage tokenSellers = tokenSellerStorage;

    //             tokenRenter memory renterDetails;
    //             renterDetails.renterAddress = msg.sender;
    //             renterDetails.rentedDuration = _duration;
    //             renterDetails.tokenQuantityRented += _tokenQuantity;
    //             renterDetails.startTimeStamp = block.timestamp;

    //             tokenSellerStorage.tokenQuantity =
    //                 tokenSellerStorage.tokenQuantity - _tokenQuantity;

    //             tokenSellerStorage.tokenQuantityAlreadyRented =
    //                 tokenSellerStorage.tokenQuantityAlreadyRented +
    //                 _tokenQuantity;

    //             tokenSellerStorage.renterArray.push(renterDetails);
    //     }

    //     function addRenterStructArray(
    //         NFTStandard _nftStandard,
    //         address _nftAddress,
    //         uint256 _tokenId,
    //         address _sellerAddress,
    //         uint _rentedDuration
    //         ) private{
    //         RentersArrayStruct memory tempRenterStruct;
    //         tempRenterStruct.nftStandard = _nftStandard;
    //         tempRenterStruct.nftAddress = _nftAddress;
    //         tempRenterStruct.tokenId = _tokenId;
    //         tempRenterStruct.sellerAddress = _sellerAddress;
    //         tempRenterStruct.renterAddress = msg.sender;
    //         tempRenterStruct.startTimeStamp = block.timestamp;
    //         tempRenterStruct.rentedDuration = _rentedDuration;

    //         renterStructArray.push(tempRenterStruct);

    //     }

    // //delete it later
    //    function withdrawProceeds(address _sellerAddress) internal {
    //         uint256 proceeds = s_proceeds[_sellerAddress];
    //         if (proceeds <= 0) {
    //             revert NoProceeds();
    //         }
    //         s_proceeds[_sellerAddress] = 0;

    //         (bool success, ) = payable(_sellerAddress).call{value: proceeds}("");
    //         require(success, "Transfer failed");
    //     }

    //     function returnNftFromRent(
    //         NFTStandard _nftStandard,
    //         address _nftAddress,
    //         uint256 _tokenId,
    //         uint256 _tokenQuantity,
    //         address _sellerAddress
    //     )
    //         external
    //         isCurrentlyRentedByUser(
    //            allNftContractListings[_nftAddress][
    //             _tokenId
    //         ],
    //             _tokenQuantity,
    //             _sellerAddress
    //         )
    //     {
    //         if(_nftStandard == NFTStandard.E721){
    //             require(_tokenQuantity == 1, "Token Quantity cannot be greater than 1 for ERC721 Standard");
    //         }

    //         tokenSeller[] storage listings = allNftContractListings[
    //             _nftAddress
    //         ][_tokenId];
    //         uint256 index = getIndexOfArray(listings, _sellerAddress);
    //         tokenSeller storage tokenSellerStorage = listings[index];
    //         uint256 renterIndex = getIndexOfRenterArray(
    //             tokenSellerStorage.renterArray,
    //             msg.sender
    //         );

    //         tokenSellerStorage.tokenQuantity =
    //             tokenSellerStorage.tokenQuantity +
    //             _tokenQuantity;

    //         tokenSellerStorage.tokenQuantityAlreadyRented =
    //             tokenSellerStorage.tokenQuantityAlreadyRented -
    //             _tokenQuantity;

    //         tokenSellerStorage.renterArray[renterIndex].tokenQuantityRented =
    //             tokenSellerStorage.renterArray[renterIndex].tokenQuantityRented -
    //             _tokenQuantity;

    //         withdrawProceeds(_sellerAddress);

    //         removeRenterListing(tokenSellerStorage.renterArray, renterIndex);

    //         emit ItemReturned(
    //             msg.sender,
    //             _nftAddress,
    //             _tokenId,
    //             _nftStandard,
    //             _tokenQuantity,
    //             _sellerAddress,
    //             tokenSellerStorage.pricePerDay,
    //             tokenSellerStorage.renterArray[renterIndex].rentedDuration
    //         );

    //     }

    //     function getIndexOfArray(
    //         tokenSeller[] storage sellerArray,
    //         address _sellerAddress
    //     ) internal view returns (uint256) {
    //         uint256 index;
    //         bool value = false;
    //         for (uint256 i = 0; i < sellerArray.length; i++) {
    //             if (sellerArray[i].sellerAddress == _sellerAddress) {
    //                 index = i;
    //                 value = true;
    //                 break;
    //             }
    //         }
    //         if(value == false){
    //             revert NoSuchListing();
    //         }
    //         return index;
    //     }

    //     function getIndexOfRenterArray(
    //         tokenRenter[] storage rentersArray,
    //         address _renterAddress
    //     ) internal view returns (uint256) {
    //         uint256 index;
    //         bool value = false;
    //         for (uint256 i = 0; i < rentersArray.length; i++) {
    //             if (rentersArray[i].renterAddress == _renterAddress) {
    //                 index = i;
    //                 value = true;
    //                 break;
    //             }
    //         }
    //         if(value == false){
    //             revert NoSuchListing();
    //         }
    //         return index;
    //     }

    //     function removeListing(tokenSeller[] storage sellerArray, uint256 _index)
    //         internal
    //     {
    //         sellerArray[_index] = sellerArray[sellerArray.length - 1];
    //         sellerArray.pop();
    //     }

    //     function removeRenterListing(
    //         tokenRenter[] storage renterArray,
    //         uint256 _index
    //     ) internal {
    //         renterArray[_index] = renterArray[renterArray.length - 1];
    //         renterArray.pop();
    //     }

    function checkTokenDurationExp()
        external
        view
        returns (RentersArrayStruct[] memory tempArray);

    function updateRentersDetails(RentersArrayStruct[] memory _tempArray)
        external;

    // fallback() payable external {}

    // receive() external payable {
    //         // React to receiving ether
    // }
}

// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "./AutomationBase.sol";
import "./interfaces/AutomationCompatibleInterface.sol";

abstract contract AutomationCompatible is AutomationBase, AutomationCompatibleInterface {}

// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract AutomationBase {
  error OnlySimulatedBackend();

  /**
   * @notice method that allows it to be simulated via eth_call by checking that
   * the sender is the zero address.
   */
  function preventExecution() internal view {
    if (tx.origin != address(0)) {
      revert OnlySimulatedBackend();
    }
  }

  /**
   * @notice modifier that allows it to be simulated via eth_call by checking
   * that the sender is the zero address.
   */
  modifier cannotExecute() {
    preventExecution();
    _;
  }
}

// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

interface AutomationCompatibleInterface {
  /**
   * @notice method that is simulated by the keepers to see if any work actually
   * needs to be performed. This method does does not actually need to be
   * executable, and since it is only ever simulated it can consume lots of gas.
   * @dev To ensure that it is never called, you may want to add the
   * cannotExecute modifier from KeeperBase to your implementation of this
   * method.
   * @param checkData specified in the upkeep registration so it is always the
   * same for a registered upkeep. This can easily be broken down into specific
   * arguments using `abi.decode`, so multiple upkeeps can be registered on the
   * same contract and easily differentiated by the contract.
   * @return upkeepNeeded boolean to indicate whether the keeper should call
   * performUpkeep or not.
   * @return performData bytes that the keeper should call performUpkeep with, if
   * upkeep is needed. If you would like to encode data to decode later, try
   * `abi.encode`.
   */
  function checkUpkeep(bytes calldata checkData) external returns (bool upkeepNeeded, bytes memory performData);

  /**
   * @notice method that is actually executed by the keepers, via the registry.
   * The data returned by the checkUpkeep simulation will be passed into
   * this method to actually be executed.
   * @dev The input to this method should not be trusted, and the caller of the
   * method should not even be restricted to any single registry. Anyone should
   * be able call it, and the input should be validated, there is no guarantee
   * that the data passed in is the performData returned from checkUpkeep. This
   * could happen due to malicious keepers, racing keepers, or simply a state
   * change while the performUpkeep transaction is waiting for confirmation.
   * Always validate the data passed in.
   * @param performData is the data which was passed back from the checkData
   * simulation. If it is encoded, it can easily be decoded into other types by
   * calling `abi.decode`. This data should not be trusted, and should be
   * validated against the contract's current state.
   */
  function performUpkeep(bytes calldata performData) external;
}