// SPDX-License-Identifier: AGPLv3"

pragma solidity ^0.8.0;

import "./AccessControlEnumerable.sol";
import "./ERC721Enumerable.sol";
import "./ERC721Pausable.sol";
import "./Counters.sol";

 
contract TuneDexNFT is
    Context,
    AccessControlEnumerable,
    ERC721Enumerable,
    ERC721Pausable {
    using Counters for Counters.Counter;

    bytes32 public constant TUNEDEX_ADMIN_ROLE = keccak256("TUNEDEX_ADMIN_ROLE");
    bytes32 public constant TUNEDEX_OPERATOR_ROLE = keccak256("TUNEDEX_OPERATOR_ROLE");
    bytes32 public constant TUNEDEX_ARTIST_ROLE = keccak256("TUNEDEX_ARTIST_ROLE");

    Counters.Counter private _tokenIdTracker;

    // Mapping from token ID to token URI
    mapping(uint256 => string) private _tokenURI;

    /**
     * @dev Throws if called by any account other than the admin.
     */
    modifier onlyAdmin() {
        require(hasRole(TUNEDEX_ADMIN_ROLE, _msgSender()), "TuneDexNFT: must have admin role");
        _;
    }

    /**
     * @dev Throws if called by any account other than the operator.
     */
    modifier onlyArtist() {
        require(hasRole(TUNEDEX_ARTIST_ROLE, _msgSender()), "TuneDexNFT: must have artist role");
        _;
    }

    constructor(string memory name_, string memory symbol_)
        ERC721(name_, symbol_) {
        _setupRole(TUNEDEX_ADMIN_ROLE, _msgSender());
        _setRoleAdmin(TUNEDEX_ADMIN_ROLE, TUNEDEX_ADMIN_ROLE);
        _setRoleAdmin(TUNEDEX_OPERATOR_ROLE, TUNEDEX_ADMIN_ROLE);
        _setRoleAdmin(TUNEDEX_ARTIST_ROLE, TUNEDEX_OPERATOR_ROLE);
    }

    /**
     * @dev Pauses all token transfers.
     *
     * See {ERC721Pausable} and {Pausable-_pause}.
     *
     * Requirements:
     *
     * - the caller must have the `PAUSER_ROLE`.
     */
    function pause() public virtual onlyAdmin {
        _pause();
    }

    /**
     * @dev Unpauses all token transfers.
     *
     * See {ERC721Pausable} and {Pausable-_unpause}.
     *
     * Requirements:
     *
     * - the caller must have the `PAUSER_ROLE`.
     */
    function unpause() public virtual onlyAdmin {
        _unpause();
    }

    /**
     * @dev Creates a new token for `to`. Its token ID will be automatically
     * assigned (and available on the emitted {IERC721-Transfer} event), and the token
     * URI autogenerated based on the base URI passed at construction.
     *
     * See {ERC721-_mint}.
     *
     * Requirements:
     *
     * - the caller must have the `TUNEDEX_ARTIST_ROLE`.
     */
    function mint(address to, string memory uri) public virtual onlyArtist {
        uint256 tokenId = _tokenIdTracker.current();
        _safeMint(to, tokenId);
        _tokenURI[tokenId] = uri;
        _tokenIdTracker.increment();
    }

    /**
     * @dev Burns `tokenId`. See {ERC721-_burn}.
     *
     * Requirements:
     *
     * - The caller must own `tokenId` or be an approved operator.
     */
    function burn(uint256 tokenId) public virtual {
        require(_isApprovedOrOwner(_msgSender(), tokenId), "TuneDexNFT: caller is not owner nor approved");
        _burn(tokenId);
        delete _tokenURI[tokenId];
    }

    /**
     * @dev See {IERC721Metadata-tokenURI}.
     */
    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {
        require(_exists(tokenId), "TuneDexNFT: URI query for nonexistent token");
        return _tokenURI[tokenId];
    }

    /**
     * @dev Hook that is called before any token transfer. This includes minting
     * and burning.
     *
     * Calling conditions:
     *
     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be
     * transferred to `to`.
     * - When `from` is zero, `tokenId` will be minted for `to`.
     * - When `to` is zero, ``from``'s `tokenId` will be burned.
     * - `from` and `to` are never both zero.
     *
     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].
     */
    function _beforeTokenTransfer(
        address from,
        address to,
        uint256 tokenId
    ) internal virtual override(ERC721Enumerable, ERC721Pausable) whenNotPaused {
        super._beforeTokenTransfer(from, to, tokenId);
    }

    /**
     * @dev See {IERC165-supportsInterface}.
     */
    function supportsInterface(bytes4 interfaceId)
        public
        view
        virtual
        override(AccessControlEnumerable, ERC721, ERC721Enumerable)
        returns (bool)
    {
        return super.supportsInterface(interfaceId);
    }
}