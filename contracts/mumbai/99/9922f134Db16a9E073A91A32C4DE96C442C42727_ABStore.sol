/**
 *Submitted for verification at polygonscan.com on 2022-09-21
*/

// File: @chainlink/contracts/src/v0.8/VRFRequestIDBase.sol


pragma solidity ^0.8.0;

contract VRFRequestIDBase {
  /**
   * @notice returns the seed which is actually input to the VRF coordinator
   *
   * @dev To prevent repetition of VRF output due to repetition of the
   * @dev user-supplied seed, that seed is combined in a hash with the
   * @dev user-specific nonce, and the address of the consuming contract. The
   * @dev risk of repetition is mostly mitigated by inclusion of a blockhash in
   * @dev the final seed, but the nonce does protect against repetition in
   * @dev requests which are included in a single block.
   *
   * @param _userSeed VRF seed input provided by user
   * @param _requester Address of the requesting contract
   * @param _nonce User-specific nonce at the time of the request
   */
  function makeVRFInputSeed(
    bytes32 _keyHash,
    uint256 _userSeed,
    address _requester,
    uint256 _nonce
  ) internal pure returns (uint256) {
    return uint256(keccak256(abi.encode(_keyHash, _userSeed, _requester, _nonce)));
  }

  /**
   * @notice Returns the id for this request
   * @param _keyHash The serviceAgreement ID to be used for this request
   * @param _vRFInputSeed The seed to be passed directly to the VRF
   * @return The id for this request
   *
   * @dev Note that _vRFInputSeed is not the seed passed by the consuming
   * @dev contract, but the one generated by makeVRFInputSeed
   */
  function makeRequestId(bytes32 _keyHash, uint256 _vRFInputSeed) internal pure returns (bytes32) {
    return keccak256(abi.encodePacked(_keyHash, _vRFInputSeed));
  }
}

// File: @chainlink/contracts/src/v0.8/interfaces/LinkTokenInterface.sol


pragma solidity ^0.8.0;

interface LinkTokenInterface {
  function allowance(address owner, address spender) external view returns (uint256 remaining);

  function approve(address spender, uint256 value) external returns (bool success);

  function balanceOf(address owner) external view returns (uint256 balance);

  function decimals() external view returns (uint8 decimalPlaces);

  function decreaseApproval(address spender, uint256 addedValue) external returns (bool success);

  function increaseApproval(address spender, uint256 subtractedValue) external;

  function name() external view returns (string memory tokenName);

  function symbol() external view returns (string memory tokenSymbol);

  function totalSupply() external view returns (uint256 totalTokensIssued);

  function transfer(address to, uint256 value) external returns (bool success);

  function transferAndCall(
    address to,
    uint256 value,
    bytes calldata data
  ) external returns (bool success);

  function transferFrom(
    address from,
    address to,
    uint256 value
  ) external returns (bool success);
}

// File: @chainlink/contracts/src/v0.8/VRFConsumerBase.sol


pragma solidity ^0.8.0;



/** ****************************************************************************
 * @notice Interface for contracts using VRF randomness
 * *****************************************************************************
 * @dev PURPOSE
 *
 * @dev Reggie the Random Oracle (not his real job) wants to provide randomness
 * @dev to Vera the verifier in such a way that Vera can be sure he's not
 * @dev making his output up to suit himself. Reggie provides Vera a public key
 * @dev to which he knows the secret key. Each time Vera provides a seed to
 * @dev Reggie, he gives back a value which is computed completely
 * @dev deterministically from the seed and the secret key.
 *
 * @dev Reggie provides a proof by which Vera can verify that the output was
 * @dev correctly computed once Reggie tells it to her, but without that proof,
 * @dev the output is indistinguishable to her from a uniform random sample
 * @dev from the output space.
 *
 * @dev The purpose of this contract is to make it easy for unrelated contracts
 * @dev to talk to Vera the verifier about the work Reggie is doing, to provide
 * @dev simple access to a verifiable source of randomness.
 * *****************************************************************************
 * @dev USAGE
 *
 * @dev Calling contracts must inherit from VRFConsumerBase, and can
 * @dev initialize VRFConsumerBase's attributes in their constructor as
 * @dev shown:
 *
 * @dev   contract VRFConsumer {
 * @dev     constructor(<other arguments>, address _vrfCoordinator, address _link)
 * @dev       VRFConsumerBase(_vrfCoordinator, _link) public {
 * @dev         <initialization with other arguments goes here>
 * @dev       }
 * @dev   }
 *
 * @dev The oracle will have given you an ID for the VRF keypair they have
 * @dev committed to (let's call it keyHash), and have told you the minimum LINK
 * @dev price for VRF service. Make sure your contract has sufficient LINK, and
 * @dev call requestRandomness(keyHash, fee, seed), where seed is the input you
 * @dev want to generate randomness from.
 *
 * @dev Once the VRFCoordinator has received and validated the oracle's response
 * @dev to your request, it will call your contract's fulfillRandomness method.
 *
 * @dev The randomness argument to fulfillRandomness is the actual random value
 * @dev generated from your seed.
 *
 * @dev The requestId argument is generated from the keyHash and the seed by
 * @dev makeRequestId(keyHash, seed). If your contract could have concurrent
 * @dev requests open, you can use the requestId to track which seed is
 * @dev associated with which randomness. See VRFRequestIDBase.sol for more
 * @dev details. (See "SECURITY CONSIDERATIONS" for principles to keep in mind,
 * @dev if your contract could have multiple requests in flight simultaneously.)
 *
 * @dev Colliding `requestId`s are cryptographically impossible as long as seeds
 * @dev differ. (Which is critical to making unpredictable randomness! See the
 * @dev next section.)
 *
 * *****************************************************************************
 * @dev SECURITY CONSIDERATIONS
 *
 * @dev A method with the ability to call your fulfillRandomness method directly
 * @dev could spoof a VRF response with any random value, so it's critical that
 * @dev it cannot be directly called by anything other than this base contract
 * @dev (specifically, by the VRFConsumerBase.rawFulfillRandomness method).
 *
 * @dev For your users to trust that your contract's random behavior is free
 * @dev from malicious interference, it's best if you can write it so that all
 * @dev behaviors implied by a VRF response are executed *during* your
 * @dev fulfillRandomness method. If your contract must store the response (or
 * @dev anything derived from it) and use it later, you must ensure that any
 * @dev user-significant behavior which depends on that stored value cannot be
 * @dev manipulated by a subsequent VRF request.
 *
 * @dev Similarly, both miners and the VRF oracle itself have some influence
 * @dev over the order in which VRF responses appear on the blockchain, so if
 * @dev your contract could have multiple VRF requests in flight simultaneously,
 * @dev you must ensure that the order in which the VRF responses arrive cannot
 * @dev be used to manipulate your contract's user-significant behavior.
 *
 * @dev Since the ultimate input to the VRF is mixed with the block hash of the
 * @dev block in which the request is made, user-provided seeds have no impact
 * @dev on its economic security properties. They are only included for API
 * @dev compatability with previous versions of this contract.
 *
 * @dev Since the block hash of the block which contains the requestRandomness
 * @dev call is mixed into the input to the VRF *last*, a sufficiently powerful
 * @dev miner could, in principle, fork the blockchain to evict the block
 * @dev containing the request, forcing the request to be included in a
 * @dev different block with a different hash, and therefore a different input
 * @dev to the VRF. However, such an attack would incur a substantial economic
 * @dev cost. This cost scales with the number of blocks the VRF oracle waits
 * @dev until it calls responds to a request.
 */
abstract contract VRFConsumerBase is VRFRequestIDBase {
  /**
   * @notice fulfillRandomness handles the VRF response. Your contract must
   * @notice implement it. See "SECURITY CONSIDERATIONS" above for important
   * @notice principles to keep in mind when implementing your fulfillRandomness
   * @notice method.
   *
   * @dev VRFConsumerBase expects its subcontracts to have a method with this
   * @dev signature, and will call it once it has verified the proof
   * @dev associated with the randomness. (It is triggered via a call to
   * @dev rawFulfillRandomness, below.)
   *
   * @param requestId The Id initially returned by requestRandomness
   * @param randomness the VRF output
   */
  function fulfillRandomness(bytes32 requestId, uint256 randomness) internal virtual;

  /**
   * @dev In order to keep backwards compatibility we have kept the user
   * seed field around. We remove the use of it because given that the blockhash
   * enters later, it overrides whatever randomness the used seed provides.
   * Given that it adds no security, and can easily lead to misunderstandings,
   * we have removed it from usage and can now provide a simpler API.
   */
  uint256 private constant USER_SEED_PLACEHOLDER = 0;

  /**
   * @notice requestRandomness initiates a request for VRF output given _seed
   *
   * @dev The fulfillRandomness method receives the output, once it's provided
   * @dev by the Oracle, and verified by the vrfCoordinator.
   *
   * @dev The _keyHash must already be registered with the VRFCoordinator, and
   * @dev the _fee must exceed the fee specified during registration of the
   * @dev _keyHash.
   *
   * @dev The _seed parameter is vestigial, and is kept only for API
   * @dev compatibility with older versions. It can't *hurt* to mix in some of
   * @dev your own randomness, here, but it's not necessary because the VRF
   * @dev oracle will mix the hash of the block containing your request into the
   * @dev VRF seed it ultimately uses.
   *
   * @param _keyHash ID of public key against which randomness is generated
   * @param _fee The amount of LINK to send with the request
   *
   * @return requestId unique ID for this request
   *
   * @dev The returned requestId can be used to distinguish responses to
   * @dev concurrent requests. It is passed as the first argument to
   * @dev fulfillRandomness.
   */
  function requestRandomness(bytes32 _keyHash, uint256 _fee) internal returns (bytes32 requestId) {
    LINK.transferAndCall(vrfCoordinator, _fee, abi.encode(_keyHash, USER_SEED_PLACEHOLDER));
    // This is the seed passed to VRFCoordinator. The oracle will mix this with
    // the hash of the block containing this request to obtain the seed/input
    // which is finally passed to the VRF cryptographic machinery.
    uint256 vRFSeed = makeVRFInputSeed(_keyHash, USER_SEED_PLACEHOLDER, address(this), nonces[_keyHash]);
    // nonces[_keyHash] must stay in sync with
    // VRFCoordinator.nonces[_keyHash][this], which was incremented by the above
    // successful LINK.transferAndCall (in VRFCoordinator.randomnessRequest).
    // This provides protection against the user repeating their input seed,
    // which would result in a predictable/duplicate output, if multiple such
    // requests appeared in the same block.
    nonces[_keyHash] = nonces[_keyHash] + 1;
    return makeRequestId(_keyHash, vRFSeed);
  }

  LinkTokenInterface internal immutable LINK;
  address private immutable vrfCoordinator;

  // Nonces for each VRF key from which randomness has been requested.
  //
  // Must stay in sync with VRFCoordinator[_keyHash][this]
  mapping(bytes32 => uint256) /* keyHash */ /* nonce */
    private nonces;

  /**
   * @param _vrfCoordinator address of VRFCoordinator contract
   * @param _link address of LINK token contract
   *
   * @dev https://docs.chain.link/docs/link-token-contracts
   */
  constructor(address _vrfCoordinator, address _link) {
    vrfCoordinator = _vrfCoordinator;
    LINK = LinkTokenInterface(_link);
  }

  // rawFulfillRandomness is called by VRFCoordinator when it receives a valid VRF
  // proof. rawFulfillRandomness then calls fulfillRandomness, after validating
  // the origin of the call
  function rawFulfillRandomness(bytes32 requestId, uint256 randomness) external {
    require(msg.sender == vrfCoordinator, "Only VRFCoordinator can fulfill");
    fulfillRandomness(requestId, randomness);
  }
}

// File: final contracts/ABStore.sol

//SPDX-License-Identifier: MIT License
pragma solidity ^0.8.0;



contract AccessControl {
    address payable public creatorAddress;

    modifier onlyCREATOR() {
        require(msg.sender == creatorAddress, 'You are not the creator');
        _;
    }

    // Constructor
    constructor() {
        creatorAddress = payable(msg.sender);
    }

    function changeOwner(address payable _newOwner) public onlyCREATOR {
        creatorAddress = _newOwner;
    }
}

abstract contract IABToken is AccessControl {
    function mintABToken(
        address owner,
        uint8 _cardSeriesId,
        uint16 _power,
        uint16 _auraRed,
        uint16 _auraYellow,
        uint16 _auraBlue,
        string memory _name,
        uint16 _experience
    ) public virtual;

    function totalSupply() public virtual returns (uint256);
}

abstract contract IHalo {
    function transferFrom(
        address sender,
        address recipient,
        uint256 amount
    ) external virtual returns (bool);
}

contract ABStore is AccessControl, VRFConsumerBase {

    address public ABTokenDataContract;
    address payable public BattleMtnAddress;

    struct UltimatePackCommit {
        uint256 randomNumber;
        uint256 blockNumber;
    }

    address[] public pendingAddresses;
  
    mapping(address => UltimatePackCommit) public ultimatePackCommits;
    

    uint256 public bronzePrice = 100;
    uint256 public silverPrice = 200;
    uint256 public goldPrice = 300;

    // Price in Halo tokens for the special pack
    uint256 public specialPackHaloPrice = 1000000000000000000000;
    address public haloContractAddress = address(0);
    address public deadAddress = 0x000000000000000000000000000000000000dEaD;

    uint256 public sentValue = 0;

    bytes32 internal keyHash;
    uint256 internal fee;

    constructor()
        public
        VRFConsumerBase(
            0x8C7382F9D8f56b33781fE506E897a4F1e2d17255, // VRF Coordinator
            0x326C977E6efc84E512bB9C30f76E30c160eD06FB // LINK Token
        )
    {
        keyHash = 0x6e75b569a01ef56d18cab6a8e71e6600d6ce853834d4a5748b720d06f878b3a4;
        fee = 0.0001 * 10**18; // 0.0001 LINK
    }

    // Called once to initialize the store.
    function initStore() external onlyCREATOR {
        IABToken abTokenContract = IABToken(ABTokenDataContract);
        require(
            abTokenContract.totalSupply() == 0,
            'There are already tokens in the ABTokenDataContract'
        );

        // First three tokens are the null team for battle mountain
        // Create Berakiel
        abTokenContract.mintABToken(address(this), 0, 60, 0, 0, 1, '', 0);

        // Create the Pet
        abTokenContract.mintABToken(address(this), 24, 1, 2, 2, 2, '', 0);

        // Create the accessory
        abTokenContract.mintABToken(address(this), 43, 0, 0, 0, 0, '', 0);
    }

    function setPackPrices(
        uint8 _bronzePrice,
        uint8 _silverPrice,
        uint8 _goldPrice,
        uint256 _specialPackHaloPrice
    ) public onlyCREATOR {
        bronzePrice = _bronzePrice;
        silverPrice = _silverPrice;
        goldPrice = _goldPrice;
        specialPackHaloPrice = _specialPackHaloPrice;
    }

    function setHaloAddress(address _haloContractAddress) public onlyCREATOR {
        haloContractAddress = _haloContractAddress;
    }

    function getFreePack() public {
        IABToken abTokenContract = IABToken(ABTokenDataContract);

        // Create Berakiel
        uint16 power;
        (power) = getAngelPower(0);
        abTokenContract.mintABToken(msg.sender, 0, power, 0, 0, 1, '', 0);

        // Create the Pet
        uint8 petSeries = chooseFreePet();
        uint8 petSpeed = getRandomNumber(10, 1, msg.sender);
        abTokenContract.mintABToken(
            msg.sender,
            petSeries,
            petSpeed,
            2,
            2,
            2,
            '',
            0
        );
    }

    function buyBronzePack() public payable {
        IABToken abTokenContract = IABToken(ABTokenDataContract);

        require(msg.value >= bronzePrice, 'You need to send the bronze price');

        // Create the Angel
        mintAngel(chooseBronzeAngel());

        // Create the Pet
        uint8 petSeries = chooseBronzeSilverPet();
        uint8 petSpeed = getRandomNumber(20, 10, msg.sender);
        abTokenContract.mintABToken(
            msg.sender,
            petSeries,
            petSpeed,
            4,
            4,
            4,
            '',
            0
        );
    }

    function buySilverPack() public payable {
        IABToken abTokenContract = IABToken(ABTokenDataContract);

        require(msg.value >= silverPrice, 'You need to send the silver price');

        // Create the Angel
        mintAngel(chooseSilverAngel());

        // Create the Pet
        uint8 petSeries = chooseBronzeSilverPet();
        uint8 petSpeed = getRandomNumber(30, 21, msg.sender);
        abTokenContract.mintABToken(
            msg.sender,
            petSeries,
            petSpeed,
            4,
            4,
            4,
            '',
            0
        );

        // Create the accessory
        uint8 accSeries = getRandomNumber(53, 43, msg.sender);
        abTokenContract.mintABToken(msg.sender, accSeries, 0, 0, 0, 0, '', 0);
    }

    
    function buyGoldPack() public payable {
        IABToken abTokenContract = IABToken(ABTokenDataContract);

        require(msg.value >= goldPrice, 'You need to send the gold price');

        // Create the Angel
        mintAngel(chooseGoldAngel());

        // Create the Pet
        uint8 petSeries = chooseGoldPet();
        uint8 petSpeed = getRandomNumber(40, 31, msg.sender);
        abTokenContract.mintABToken(
            msg.sender,
            petSeries,
            petSpeed,
            4,
            4,
            4,
            '',
            0
        );

        // Create the accessory
        uint8 accSeries = getRandomNumber(59, 43, msg.sender);
        abTokenContract.mintABToken(msg.sender, accSeries, 0, 0, 0, 0, '', 0);
    }

    function chooseSilverAccessory() public view returns (uint8) {
           uint8 choice = getRandomNumber(100, 1, msg.sender);
        // Leather bracers
        if (choice <= 15) {
            return 43;
        }
        // Metal bracers
        if (choice <= 20) {
            return 44;
        }
        // Scholars Scroll
        if (choice <= 35) {
            return 45;
        }
        // Cosmic Scroll
        if (choice <= 40) {
            return 46;
        }
        // Red collar
        if (choice <= 55) {
            return 49;
        }
        // Ruby Collar
        if (choice <= 60) {
            return 50;
        }
        // Yellow collar
        if (choice <= 75) {
            return 51;
        }
        // Citrine Collar
        if (choice <= 80) {
            return 52;
        }
           // Blue collar
        if (choice <= 95) {
            return 53;
        }
        // Sapphire Collar
       return 54;
    }

    function chooseGoldAccessory() public view returns (uint8)  {
         uint8 choice = getRandomNumber(101, 2, msg.sender);

        // 50% chance to get silver level accessory
        if (choice <= 50) {
            return chooseSilverAccessory();
        }

        // Carrots
        if (choice < 63) {
            return 55;
        }

        // Cricket
        if (choice < 76) {
            return 56;
        }

        // Bird Seed
        if (choice < 89) {
            return 57;
        }

        // Cat Nip
       
        return 58;
    

    }

    function chooseBronzeAngel() public view returns (uint8) {
        uint8 choice = getRandomNumber(100, 1, msg.sender);
        // Arel
        if (choice <= 28) {
            return 4;
        }
        // Raguel
        if (choice <= 52) {
            return 5;
        }
        // Lilith
        if (choice <= 72) {
            return 6;
        }
        // Furlac
        if (choice <= 86) {
            return 7;
        }
        // Azazel
        if (choice <= 95) {
            return 8;
        }
        // Eleleth
        return 9;
    }

    function chooseSilverAngel() public view returns (uint8) {
        uint8 choice = getRandomNumber(100, 1, msg.sender);
        // Verin
        if (choice <= 20) {
            return 10;
        }
        // Ziwa
        if (choice <= 37) {
            return 11;
        }
        // Cimeriel
        if (choice <= 52) {
            return 12;
        }
        // Numinel
        if (choice <= 65) {
            return 13;
        }
        // Bat Gol
        if (choice <= 76) {
            return 14;
        }
        // Gabriel
        if (choice <= 85) {
            return 15;
        }
        // Metatron
        if (choice <= 92) {
            return 16;
        }
        // Rafael
        if (choice <= 97) {
            return 17;
        }
        // Melchezidek
        return 18;
    }

    function chooseGoldAngel() public view returns (uint8) {
        uint8 choice = getRandomNumber(100, 1, msg.sender);
        // Semyaza
        if (choice <= 30) {
            return 19;
        }
        // Abbadon
        if (choice <= 55) {
            return 20;
        }
        // Baalzebub
        if (choice <= 75) {
            return 21;
        }
        // Ben Nez
        if (choice <= 90) {
            return 22;
        }
        // Jophiel
        return 23;
    }

    function chooseFreePet() public view returns (uint8) {
        uint8 choice = getRandomNumber(100, 1, msg.sender);
        // Gecko
        if (choice <= 50) {
            return 24;
        }
        // Parakeet
        if (choice <= 75) {
            return 25;
        }
        // Angry Kitty
        if (choice <= 90) {
            return 26;
        }
        // Horse
        return 27;
    }

    function chooseBronzeSilverPet() public view returns (uint8) {
        uint8 choice = getRandomNumber(100, 1, msg.sender);
        // Komodo
        if (choice <= 50) {
            return 28;
        }
        // Falcon
        if (choice <= 75) {
            return 29;
        }
        // Bobcat
        if (choice <= 90) {
            return 30;
        }
        // Unicorn
        return 31;
    }

    function chooseGoldPet() public view returns (uint8) {
        uint8 choice = getRandomNumber(100, 1, msg.sender);
        // Rock Dragon
        if (choice <= 50) {
            return 32;
        }
        // Archaeopteryx
        if (choice <= 75) {
            return 33;
        }
        // Sabertooth
        if (choice <= 90) {
            return 34;
        }
        // Pegasus
        return 35;
    }

    /**
     * Callback function used by VRF Coordinator
     */
    function fulfillRandomness(bytes32 requestId, uint256 randomness)
        internal
        override
    {
        address committedAddress = pendingAddresses[pendingAddresses.length -1];
        pendingAddresses.pop();
        ultimatePackCommits[committedAddress].randomNumber =
            (randomness % 99) +
            1;
    }

    /**
     * Requests randomness
     */
    function getRandomNumber() public returns (bytes32 requestId) {
        require(
            LINK.balanceOf(address(this)) > fee,
            'Not enough LINK - someone must add to contract'
        );
        return requestRandomness(keyHash, fee);
    }

    // The best cards can only be obtained by burning Halo tokens
    function commitToBuySpecialPack() public {
        require(
            ultimatePackCommits[msg.sender].randomNumber == 0,
            'You have already committed'
        );

        require(
            ultimatePackCommits[msg.sender].blockNumber == 0,
            'Commit in progress'
        );

        IHalo Halo = IHalo(haloContractAddress);

        // Will fail if user does not have enough Halo tokens
        Halo.transferFrom(msg.sender, deadAddress, specialPackHaloPrice);

        UltimatePackCommit memory commit;

        commit.blockNumber = block.number;
        commit.randomNumber = 0;

        ultimatePackCommits[msg.sender] = commit;
        pendingAddresses.push(msg.sender);

        // Call chainlink  vrf to get random number
        getRandomNumber();
    }

    // To protect from various flashbots bundle enabled attacks
    // users must first commit to buy the special pack by burning HALO tokens
    // The receiveSpecialPack() function can be called a minimum of 10 blocks later
    function receiveSpecialPack() public {
        require(
            block.number > ultimatePackCommits[msg.sender].blockNumber + 20,
            'You need to wait longer'
        );
        require(
            ultimatePackCommits[msg.sender].randomNumber != 0,
            'You need to commit first'
        );
        IABToken abTokenContract = IABToken(ABTokenDataContract);

        uint256 choice = ultimatePackCommits[msg.sender].randomNumber;

        ultimatePackCommits[msg.sender].randomNumber = 0;
        ultimatePackCommits[msg.sender].blockNumber = 0;

        // Zadkiel
        if (choice <= 50) {
            mintAngel(1);
        }

          // Silver medal
        else if (choice > 50 && choice <= 65) {
             abTokenContract.mintABToken(msg.sender, 65, 0, 0, 0, 0, '', 0);
        }

        // Gold medal
        else if (choice > 65 && choice <= 75) {
             abTokenContract.mintABToken(msg.sender, 66, 0, 0, 0, 0, '', 0);
        }

        // Platinum medal
        else if (choice > 75 && choice <= 85) {
             abTokenContract.mintABToken(msg.sender, 67, 0, 0, 0, 0, '', 0);
        }

        // Lightning Rod
        else if (choice > 85 && choice <= 90) {
             abTokenContract.mintABToken(msg.sender, 59, 0, 0, 0, 0, '', 0);
        }

        // Holy Light Accessory
        else if (choice > 90 && choice <= 95) {
            abTokenContract.mintABToken(msg.sender, 60, 0, 0, 0, 0, '', 0);
        }
        // Lucifer
        else if (choice > 95 && choice <= 98) {
            mintAngel(2);
        }
        // Michael
        else {
            mintAngel(3);
        }
    }

    function getCommitStatus(address addressToCheck)
        public
        view
        returns (bool)
    {
        return ultimatePackCommits[addressToCheck].randomNumber != 0;
    }

    function mintAngel(uint8 _angelSeriesId) internal {
        IABToken abTokenContract = IABToken(ABTokenDataContract);
        (uint8 auraRed, uint8 auraYellow, uint8 auraBlue) = getAura(
            _angelSeriesId
        );
        uint16 power = getAngelPower(_angelSeriesId);
        abTokenContract.mintABToken(
            msg.sender,
            _angelSeriesId,
            power,
            auraRed,
            auraYellow,
            auraBlue,
            '',
            0
        );
    }

    function getAngelPower(uint8 _angelSeriesId) private view returns (uint16) {
        uint8 randomPower = getRandomNumber(10, 0, msg.sender);
        if (_angelSeriesId >= 4) {
            return
                uint16(100 + 10 * (uint16(_angelSeriesId) - 4) + randomPower);
        }
        if (_angelSeriesId == 0) {
            return (50 + randomPower);
        }
        if (_angelSeriesId == 1) {
            return (120 + randomPower);
        }
        if (_angelSeriesId == 2) {
            return (250 + randomPower);
        }
        if (_angelSeriesId == 3) {
            return (300 + randomPower);
        }
        return 1;
    }

    //Returns the Aura color of each angel
    function getAura(uint8 _angelSeriesId)
        public
        pure
        returns (
            uint8 auraRed,
            uint8 auraYellow,
            uint8 auraBlue
        )
    {
        if (_angelSeriesId == 0) {
            return (0, 0, 1);
        }
        if (_angelSeriesId == 1) {
            return (0, 1, 0);
        }
        if (_angelSeriesId == 2) {
            return (1, 0, 1);
        }
        if (_angelSeriesId == 3) {
            return (1, 1, 0);
        }
        if (_angelSeriesId == 4) {
            return (1, 0, 0);
        }
        if (_angelSeriesId == 5) {
            return (0, 1, 0);
        }
        if (_angelSeriesId == 6) {
            return (1, 0, 1);
        }
        if (_angelSeriesId == 7) {
            return (0, 1, 1);
        }
        if (_angelSeriesId == 8) {
            return (1, 1, 0);
        }
        if (_angelSeriesId == 9) {
            return (0, 0, 1);
        }
        if (_angelSeriesId == 10) {
            return (1, 0, 0);
        }
        if (_angelSeriesId == 11) {
            return (0, 1, 0);
        }
        if (_angelSeriesId == 12) {
            return (1, 0, 1);
        }
        if (_angelSeriesId == 13) {
            return (0, 1, 1);
        }
        if (_angelSeriesId == 14) {
            return (1, 1, 0);
        }
        if (_angelSeriesId == 15) {
            return (0, 0, 1);
        }
        if (_angelSeriesId == 16) {
            return (1, 0, 0);
        }
        if (_angelSeriesId == 17) {
            return (0, 1, 0);
        }
        if (_angelSeriesId == 18) {
            return (1, 0, 1);
        }
        if (_angelSeriesId == 19) {
            return (0, 1, 1);
        }
        if (_angelSeriesId == 20) {
            return (1, 1, 0);
        }
        if (_angelSeriesId == 21) {
            return (0, 0, 1);
        }
        if (_angelSeriesId == 22) {
            return (1, 0, 0);
        }
        if (_angelSeriesId == 23) {
            return (0, 1, 1);
        }
    }

    function setBattleMtnContract(address payable _BattleMtnAddress)
        public
        onlyCREATOR
    {
        BattleMtnAddress = _BattleMtnAddress;
    }

    function setABTokenDataContract(address _ABTokenDataContract)
        public
        onlyCREATOR
    {
        ABTokenDataContract = _ABTokenDataContract;
    }

    function getRandomNumber(
        uint16 maxRandom,
        uint8 min,
        address privateAddress
    ) public view returns (uint8) {
        uint256 genNum = uint256(
            keccak256(abi.encodePacked(block.timestamp, privateAddress))
        );
        return uint8((genNum % (maxRandom - min + 1)) + min);
    }

    function getStoreInfo()
        public
        view
        returns (uint256 totalSentValue, uint256 balance)
    {
        totalSentValue = sentValue;
        balance = address(this).balance;
    }

    function withdrawEther() public {
        uint256 value = address(this).balance;
        BattleMtnAddress.transfer(value);
        sentValue += value;
    }

}