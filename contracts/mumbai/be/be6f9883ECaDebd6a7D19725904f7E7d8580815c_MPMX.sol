// SPDX-License-Identifier: MIT-BROUGKR
/*@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                     @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@          @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                 @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@              @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@              @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                 @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                     @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@*/
/**
 * @dev: @brougkr
 */
pragma solidity 0.8.16;
import {IERC721} from "@openzeppelin/contracts/interfaces/IERC721.sol";
import {ERC721} from "@openzeppelin/contracts/token/ERC721/ERC721.sol";
contract BatchReader 
{
    struct CitizenCity
    {
        string Name;
        address ContractAddress;
        uint StartingTokenID;
        uint EndingTokenID;
    }
    CitizenCity[] CitizenCities;
    mapping(address=>bool) Roles;
    event NewCity(string Name, address ContractAddress, uint StartingTokenID, uint EndingTokenID);
    event ModifiedCity(string Name, address ContractAddress, uint StartingTokenID, uint EndingTokenID);
    constructor()
    {
        Roles[msg.sender] = true; // deployer.brightmoments.eth
        Roles[0x18B7511938FBe2EE08ADf3d4A24edB00A5C9B783] = true; // phil.brightmoments.eth
        Roles[0xB96E81f80b3AEEf65CB6d0E280b15FD5DBE71937] = true; // brightmoments.eth
        CitizenCities.push(CitizenCity('CryptoGalacticans', 0xbDdE08BD57e5C9fD563eE7aC61618CB2ECdc0ce0, 0, 999));
        CitizenCities.push(CitizenCity('CryptoVenetians', 0xa7d8d9ef8D8Ce8992Df33D8b8CF4Aebabd5bD270, 95000000, 95000999));
        CitizenCities.push(CitizenCity('CryptoNewYorkers', 0xa7d8d9ef8D8Ce8992Df33D8b8CF4Aebabd5bD270, 189000000, 189000999));
        CitizenCities.push(CitizenCity('CryptoBerliners', 0xbDdE08BD57e5C9fD563eE7aC61618CB2ECdc0ce0, 3000000, 3000999));
        CitizenCities.push(CitizenCity('CryptoLondoners', 0xbDdE08BD57e5C9fD563eE7aC61618CB2ECdc0ce0, 4000000, 4000999));
    }

    /*******************
     * ADMIN FUNCTIONS *
     ******************/
    
    /**
     * @dev Adds Citizen City
     */
    function AddCitizenCity(
        string calldata Name,
        address ContractAddress, 
        uint StartingTokenID, 
        uint EndingTokenID
    ) external onlyBRTAdmin {   
        CitizenCities.push(CitizenCity(Name, ContractAddress, StartingTokenID, EndingTokenID));
        emit NewCity(Name, ContractAddress, StartingTokenID, EndingTokenID);
    }

    /**
     * @dev Modifies Citizen City
     */
    function ModifyCitizenCity(
        uint CityNumber, 
        string calldata Name, 
        address ContractAddress, 
        uint StartingTokenID, 
        uint EndingTokenID
    ) external onlyBRTAdmin {
        CitizenCities[CityNumber].Name = Name;
        CitizenCities[CityNumber].ContractAddress = ContractAddress;
        CitizenCities[CityNumber].StartingTokenID = StartingTokenID;
        CitizenCities[CityNumber].EndingTokenID = EndingTokenID;
        emit ModifiedCity(Name, ContractAddress, StartingTokenID, EndingTokenID);
    }

    /******************
     * VIEW FUNCTIONS *
     *****************/

    /**
     * @dev Returns Citizens Owned By Wallet
     */
    function readWalletOwnedCitizens(address Wallet) public view returns(uint[][] memory)
    {
        uint[][] memory Owners = new uint[][](CitizenCities.length);
        for(uint x; x < CitizenCities.length; x++)
        {
            uint Range = CitizenCities[x].EndingTokenID - CitizenCities[x].StartingTokenID + 1;
            IERC721 NFT = IERC721(CitizenCities[x].ContractAddress);
            uint[] memory temp = new uint[](Range);
            uint counter;
            for(uint TokenID = CitizenCities[x].StartingTokenID; TokenID <= CitizenCities[x].EndingTokenID; TokenID++)
            {
                try NFT.ownerOf(TokenID) 
                {
                    if(NFT.ownerOf(TokenID) == Wallet)
                    {
                        temp[counter] = TokenID;
                        counter++;   
                    }
                } catch { }
            }
            uint[] memory FormattedOwnedIDs = new uint[](counter);
            uint index;
            for(uint z; z < counter; z++)
            {
                if(temp[z] != 0 || (z == 0 && temp[z] == 0))
                {
                    FormattedOwnedIDs[index] = temp[z];
                    index++;
                }
            }
            Owners[x] = FormattedOwnedIDs;
        }
        return Owners;
    }

    /**
     * @dev Batch Returns If Wallet Owns Multiple TokenIDs Of Multiple NFTs
     */
    function readNFTsOwnedTokenIDs(
        address Wallet, 
        address[] calldata NFTAddresses, 
        uint Range
    ) public view returns (uint[][] memory) {
        uint[][] memory OwnedIDs = new uint[][](NFTAddresses.length);
        for(uint x; x < NFTAddresses.length; x++)
        {
            IERC721 NFT = IERC721(NFTAddresses[x]);
            uint[] memory temp = new uint[](Range);
            uint counter;
            for(uint y; y <= Range; y++)
            {
                try NFT.ownerOf(y) 
                {
                    if(NFT.ownerOf(y) == Wallet)
                    {
                        temp[counter] = y;
                        counter++;   
                    }
                } catch { }
            }
            uint[] memory FormattedOwnedIDs = new uint[](counter);
            uint index;
            for(uint z; z < counter; z++)
            {
                if(temp[z] != 0 || (z == 0 && temp[z] == 0))
                {
                    FormattedOwnedIDs[index] = temp[z];
                    index++;
                }
            }
            OwnedIDs[x] = FormattedOwnedIDs;
        }
        return OwnedIDs;
    }

    /**
     * @dev Batch Returns Owners Of Collection
     */
    function readNFTOwners(
        address[] calldata NFTAddresses, 
        uint Range
    ) public view returns (address[][] memory) {
        address[][] memory Owners = new address[][](NFTAddresses.length);
        for(uint x; x < NFTAddresses.length; x++)
        {
            IERC721 NFT = IERC721(NFTAddresses[x]);
            address[] memory temp = new address[](Range);
            uint counter;
            for(uint y; y <= Range; y++)
            {
                try NFT.ownerOf(y) 
                {
                    if(NFT.ownerOf(y) != address(0))
                    {
                        temp[counter] = NFT.ownerOf(y);
                        counter++;   
                    }
    
                } 
                catch 
                { 
                    temp[counter] = address(0);
                    counter++;
                }
            }
            address[] memory FormattedOwnedIDs = new address[](counter);
            uint index;
            for(uint z; z < counter; z++)
            {
                if(temp[z] != address(0))
                {
                    FormattedOwnedIDs[index] = temp[z];
                    index++;
                }
            }
            Owners[x] = FormattedOwnedIDs;
        }
        return Owners;
    }

    /**
     * @dev Batch Returns All Citizen Owners
     */
    function readCitizenOwners() public view returns (address[][] memory) {
        address[][] memory Owners = new address[][](CitizenCities.length);
        for(uint CityID; CityID < CitizenCities.length; CityID++)
        {
            uint Range = CitizenCities[CityID].EndingTokenID - CitizenCities[CityID].StartingTokenID + 1;
            IERC721 NFT = IERC721(CitizenCities[CityID].ContractAddress);
            address[] memory temp = new address[](Range);
            uint counter;
            for(uint TokenID = CitizenCities[CityID].StartingTokenID; TokenID <= CitizenCities[CityID].EndingTokenID; TokenID++)
            {
                try NFT.ownerOf(TokenID) 
                {
                    if(NFT.ownerOf(TokenID) != address(0))
                    {
                        temp[counter] = NFT.ownerOf(TokenID);
                        counter++;   
                    }
                } 
                catch 
                { 
                    temp[counter] = address(0);
                    counter++;
                }
            }
            address[] memory FormattedOwnedIDs = new address[](counter);
            uint index;
            for(uint z; z < counter; z++)
            {
                FormattedOwnedIDs[index] = temp[z];
                index++;
            }
            Owners[CityID] = FormattedOwnedIDs;
        }
        return Owners;
    }

    /**
     * @dev Returns Batch Metadata
     */
    function readBatchMetadata(
        address[] calldata ContractAddresses, 
        uint[][] calldata TokenIDs
    ) public view returns(string[][] memory) {
        string[][] memory Metadata = new string[][](TokenIDs.length);
        for(uint ProjectID; ProjectID < ContractAddresses.length; ProjectID++)
        {
            string[] memory ProjectMetadata = new string[](TokenIDs[ProjectID].length);
            for(uint TokenID; TokenID < TokenIDs[ProjectID].length; TokenID++)
            {
                ProjectMetadata[TokenID] = ERC721(ContractAddresses[ProjectID]).tokenURI(TokenIDs[ProjectID][TokenID]);
            }
            Metadata[ProjectID] = ProjectMetadata;
        }
        return Metadata;
    }

    /**
     * @dev Returns Batch Metadata Of Citizens Held By `Wallet`
     */
    function readBatchMetadataCitizens(
        address Wallet
    ) public view returns(string[][] memory) {
        string[][] memory Metadata = new string[][](CitizenCities.length);
        uint[][] memory TokenIDs = readWalletOwnedCitizens(Wallet);
        for(uint ProjectID; ProjectID < CitizenCities.length; ProjectID++)
        {
            string[] memory ProjectMetadata = new string[](TokenIDs[ProjectID].length);
            for(uint TokenID; TokenID < TokenIDs[ProjectID].length; TokenID++)
            {
                ProjectMetadata[TokenID] = ERC721(CitizenCities[ProjectID].ContractAddress).tokenURI(TokenIDs[ProjectID][TokenID]);
            }
            Metadata[ProjectID] = ProjectMetadata;
        }
        return Metadata;
    }

    /**
     * @dev BRT Admin Modifier
     */
    modifier onlyBRTAdmin
    {
        require(Roles[msg.sender]);
        _;
    }
}

// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts v4.4.1 (interfaces/IERC721.sol)

pragma solidity ^0.8.0;

import "../token/ERC721/IERC721.sol";

// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC721/ERC721.sol)

pragma solidity ^0.8.0;

import "./IERC721.sol";
import "./IERC721Receiver.sol";
import "./extensions/IERC721Metadata.sol";
import "../../utils/Address.sol";
import "../../utils/Context.sol";
import "../../utils/Strings.sol";
import "../../utils/introspection/ERC165.sol";

/**
 * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including
 * the Metadata extension, but not including the Enumerable extension, which is available separately as
 * {ERC721Enumerable}.
 */
contract ERC721 is Context, ERC165, IERC721, IERC721Metadata {
    using Address for address;
    using Strings for uint256;

    // Token name
    string private _name;

    // Token symbol
    string private _symbol;

    // Mapping from token ID to owner address
    mapping(uint256 => address) private _owners;

    // Mapping owner address to token count
    mapping(address => uint256) private _balances;

    // Mapping from token ID to approved address
    mapping(uint256 => address) private _tokenApprovals;

    // Mapping from owner to operator approvals
    mapping(address => mapping(address => bool)) private _operatorApprovals;

    /**
     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.
     */
    constructor(string memory name_, string memory symbol_) {
        _name = name_;
        _symbol = symbol_;
    }

    /**
     * @dev See {IERC165-supportsInterface}.
     */
    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {
        return
            interfaceId == type(IERC721).interfaceId ||
            interfaceId == type(IERC721Metadata).interfaceId ||
            super.supportsInterface(interfaceId);
    }

    /**
     * @dev See {IERC721-balanceOf}.
     */
    function balanceOf(address owner) public view virtual override returns (uint256) {
        require(owner != address(0), "ERC721: address zero is not a valid owner");
        return _balances[owner];
    }

    /**
     * @dev See {IERC721-ownerOf}.
     */
    function ownerOf(uint256 tokenId) public view virtual override returns (address) {
        address owner = _owners[tokenId];
        require(owner != address(0), "ERC721: invalid token ID");
        return owner;
    }

    /**
     * @dev See {IERC721Metadata-name}.
     */
    function name() public view virtual override returns (string memory) {
        return _name;
    }

    /**
     * @dev See {IERC721Metadata-symbol}.
     */
    function symbol() public view virtual override returns (string memory) {
        return _symbol;
    }

    /**
     * @dev See {IERC721Metadata-tokenURI}.
     */
    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {
        _requireMinted(tokenId);

        string memory baseURI = _baseURI();
        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : "";
    }

    /**
     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each
     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty
     * by default, can be overridden in child contracts.
     */
    function _baseURI() internal view virtual returns (string memory) {
        return "";
    }

    /**
     * @dev See {IERC721-approve}.
     */
    function approve(address to, uint256 tokenId) public virtual override {
        address owner = ERC721.ownerOf(tokenId);
        require(to != owner, "ERC721: approval to current owner");

        require(
            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),
            "ERC721: approve caller is not token owner nor approved for all"
        );

        _approve(to, tokenId);
    }

    /**
     * @dev See {IERC721-getApproved}.
     */
    function getApproved(uint256 tokenId) public view virtual override returns (address) {
        _requireMinted(tokenId);

        return _tokenApprovals[tokenId];
    }

    /**
     * @dev See {IERC721-setApprovalForAll}.
     */
    function setApprovalForAll(address operator, bool approved) public virtual override {
        _setApprovalForAll(_msgSender(), operator, approved);
    }

    /**
     * @dev See {IERC721-isApprovedForAll}.
     */
    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {
        return _operatorApprovals[owner][operator];
    }

    /**
     * @dev See {IERC721-transferFrom}.
     */
    function transferFrom(
        address from,
        address to,
        uint256 tokenId
    ) public virtual override {
        //solhint-disable-next-line max-line-length
        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner nor approved");

        _transfer(from, to, tokenId);
    }

    /**
     * @dev See {IERC721-safeTransferFrom}.
     */
    function safeTransferFrom(
        address from,
        address to,
        uint256 tokenId
    ) public virtual override {
        safeTransferFrom(from, to, tokenId, "");
    }

    /**
     * @dev See {IERC721-safeTransferFrom}.
     */
    function safeTransferFrom(
        address from,
        address to,
        uint256 tokenId,
        bytes memory data
    ) public virtual override {
        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner nor approved");
        _safeTransfer(from, to, tokenId, data);
    }

    /**
     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients
     * are aware of the ERC721 protocol to prevent tokens from being forever locked.
     *
     * `data` is additional data, it has no specified format and it is sent in call to `to`.
     *
     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.
     * implement alternative mechanisms to perform token transfer, such as signature-based.
     *
     * Requirements:
     *
     * - `from` cannot be the zero address.
     * - `to` cannot be the zero address.
     * - `tokenId` token must exist and be owned by `from`.
     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.
     *
     * Emits a {Transfer} event.
     */
    function _safeTransfer(
        address from,
        address to,
        uint256 tokenId,
        bytes memory data
    ) internal virtual {
        _transfer(from, to, tokenId);
        require(_checkOnERC721Received(from, to, tokenId, data), "ERC721: transfer to non ERC721Receiver implementer");
    }

    /**
     * @dev Returns whether `tokenId` exists.
     *
     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.
     *
     * Tokens start existing when they are minted (`_mint`),
     * and stop existing when they are burned (`_burn`).
     */
    function _exists(uint256 tokenId) internal view virtual returns (bool) {
        return _owners[tokenId] != address(0);
    }

    /**
     * @dev Returns whether `spender` is allowed to manage `tokenId`.
     *
     * Requirements:
     *
     * - `tokenId` must exist.
     */
    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {
        address owner = ERC721.ownerOf(tokenId);
        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);
    }

    /**
     * @dev Safely mints `tokenId` and transfers it to `to`.
     *
     * Requirements:
     *
     * - `tokenId` must not exist.
     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.
     *
     * Emits a {Transfer} event.
     */
    function _safeMint(address to, uint256 tokenId) internal virtual {
        _safeMint(to, tokenId, "");
    }

    /**
     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is
     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.
     */
    function _safeMint(
        address to,
        uint256 tokenId,
        bytes memory data
    ) internal virtual {
        _mint(to, tokenId);
        require(
            _checkOnERC721Received(address(0), to, tokenId, data),
            "ERC721: transfer to non ERC721Receiver implementer"
        );
    }

    /**
     * @dev Mints `tokenId` and transfers it to `to`.
     *
     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible
     *
     * Requirements:
     *
     * - `tokenId` must not exist.
     * - `to` cannot be the zero address.
     *
     * Emits a {Transfer} event.
     */
    function _mint(address to, uint256 tokenId) internal virtual {
        require(to != address(0), "ERC721: mint to the zero address");
        require(!_exists(tokenId), "ERC721: token already minted");

        _beforeTokenTransfer(address(0), to, tokenId);

        _balances[to] += 1;
        _owners[tokenId] = to;

        emit Transfer(address(0), to, tokenId);

        _afterTokenTransfer(address(0), to, tokenId);
    }

    /**
     * @dev Destroys `tokenId`.
     * The approval is cleared when the token is burned.
     *
     * Requirements:
     *
     * - `tokenId` must exist.
     *
     * Emits a {Transfer} event.
     */
    function _burn(uint256 tokenId) internal virtual {
        address owner = ERC721.ownerOf(tokenId);

        _beforeTokenTransfer(owner, address(0), tokenId);

        // Clear approvals
        _approve(address(0), tokenId);

        _balances[owner] -= 1;
        delete _owners[tokenId];

        emit Transfer(owner, address(0), tokenId);

        _afterTokenTransfer(owner, address(0), tokenId);
    }

    /**
     * @dev Transfers `tokenId` from `from` to `to`.
     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.
     *
     * Requirements:
     *
     * - `to` cannot be the zero address.
     * - `tokenId` token must be owned by `from`.
     *
     * Emits a {Transfer} event.
     */
    function _transfer(
        address from,
        address to,
        uint256 tokenId
    ) internal virtual {
        require(ERC721.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");
        require(to != address(0), "ERC721: transfer to the zero address");

        _beforeTokenTransfer(from, to, tokenId);

        // Clear approvals from the previous owner
        _approve(address(0), tokenId);

        _balances[from] -= 1;
        _balances[to] += 1;
        _owners[tokenId] = to;

        emit Transfer(from, to, tokenId);

        _afterTokenTransfer(from, to, tokenId);
    }

    /**
     * @dev Approve `to` to operate on `tokenId`
     *
     * Emits an {Approval} event.
     */
    function _approve(address to, uint256 tokenId) internal virtual {
        _tokenApprovals[tokenId] = to;
        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);
    }

    /**
     * @dev Approve `operator` to operate on all of `owner` tokens
     *
     * Emits an {ApprovalForAll} event.
     */
    function _setApprovalForAll(
        address owner,
        address operator,
        bool approved
    ) internal virtual {
        require(owner != operator, "ERC721: approve to caller");
        _operatorApprovals[owner][operator] = approved;
        emit ApprovalForAll(owner, operator, approved);
    }

    /**
     * @dev Reverts if the `tokenId` has not been minted yet.
     */
    function _requireMinted(uint256 tokenId) internal view virtual {
        require(_exists(tokenId), "ERC721: invalid token ID");
    }

    /**
     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.
     * The call is not executed if the target address is not a contract.
     *
     * @param from address representing the previous owner of the given token ID
     * @param to target address that will receive the tokens
     * @param tokenId uint256 ID of the token to be transferred
     * @param data bytes optional data to send along with the call
     * @return bool whether the call correctly returned the expected magic value
     */
    function _checkOnERC721Received(
        address from,
        address to,
        uint256 tokenId,
        bytes memory data
    ) private returns (bool) {
        if (to.isContract()) {
            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {
                return retval == IERC721Receiver.onERC721Received.selector;
            } catch (bytes memory reason) {
                if (reason.length == 0) {
                    revert("ERC721: transfer to non ERC721Receiver implementer");
                } else {
                    /// @solidity memory-safe-assembly
                    assembly {
                        revert(add(32, reason), mload(reason))
                    }
                }
            }
        } else {
            return true;
        }
    }

    /**
     * @dev Hook that is called before any token transfer. This includes minting
     * and burning.
     *
     * Calling conditions:
     *
     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be
     * transferred to `to`.
     * - When `from` is zero, `tokenId` will be minted for `to`.
     * - When `to` is zero, ``from``'s `tokenId` will be burned.
     * - `from` and `to` are never both zero.
     *
     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].
     */
    function _beforeTokenTransfer(
        address from,
        address to,
        uint256 tokenId
    ) internal virtual {}

    /**
     * @dev Hook that is called after any transfer of tokens. This includes
     * minting and burning.
     *
     * Calling conditions:
     *
     * - when `from` and `to` are both non-zero.
     * - `from` and `to` are never both zero.
     *
     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].
     */
    function _afterTokenTransfer(
        address from,
        address to,
        uint256 tokenId
    ) internal virtual {}
}

// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC721/IERC721.sol)

pragma solidity ^0.8.0;

import "../../utils/introspection/IERC165.sol";

/**
 * @dev Required interface of an ERC721 compliant contract.
 */
interface IERC721 is IERC165 {
    /**
     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.
     */
    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);

    /**
     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.
     */
    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);

    /**
     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.
     */
    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);

    /**
     * @dev Returns the number of tokens in ``owner``'s account.
     */
    function balanceOf(address owner) external view returns (uint256 balance);

    /**
     * @dev Returns the owner of the `tokenId` token.
     *
     * Requirements:
     *
     * - `tokenId` must exist.
     */
    function ownerOf(uint256 tokenId) external view returns (address owner);

    /**
     * @dev Safely transfers `tokenId` token from `from` to `to`.
     *
     * Requirements:
     *
     * - `from` cannot be the zero address.
     * - `to` cannot be the zero address.
     * - `tokenId` token must exist and be owned by `from`.
     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.
     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.
     *
     * Emits a {Transfer} event.
     */
    function safeTransferFrom(
        address from,
        address to,
        uint256 tokenId,
        bytes calldata data
    ) external;

    /**
     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients
     * are aware of the ERC721 protocol to prevent tokens from being forever locked.
     *
     * Requirements:
     *
     * - `from` cannot be the zero address.
     * - `to` cannot be the zero address.
     * - `tokenId` token must exist and be owned by `from`.
     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.
     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.
     *
     * Emits a {Transfer} event.
     */
    function safeTransferFrom(
        address from,
        address to,
        uint256 tokenId
    ) external;

    /**
     * @dev Transfers `tokenId` token from `from` to `to`.
     *
     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.
     *
     * Requirements:
     *
     * - `from` cannot be the zero address.
     * - `to` cannot be the zero address.
     * - `tokenId` token must be owned by `from`.
     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.
     *
     * Emits a {Transfer} event.
     */
    function transferFrom(
        address from,
        address to,
        uint256 tokenId
    ) external;

    /**
     * @dev Gives permission to `to` to transfer `tokenId` token to another account.
     * The approval is cleared when the token is transferred.
     *
     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.
     *
     * Requirements:
     *
     * - The caller must own the token or be an approved operator.
     * - `tokenId` must exist.
     *
     * Emits an {Approval} event.
     */
    function approve(address to, uint256 tokenId) external;

    /**
     * @dev Approve or remove `operator` as an operator for the caller.
     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.
     *
     * Requirements:
     *
     * - The `operator` cannot be the caller.
     *
     * Emits an {ApprovalForAll} event.
     */
    function setApprovalForAll(address operator, bool _approved) external;

    /**
     * @dev Returns the account approved for `tokenId` token.
     *
     * Requirements:
     *
     * - `tokenId` must exist.
     */
    function getApproved(uint256 tokenId) external view returns (address operator);

    /**
     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.
     *
     * See {setApprovalForAll}
     */
    function isApprovedForAll(address owner, address operator) external view returns (bool);
}

// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)

pragma solidity ^0.8.0;

/**
 * @dev Interface of the ERC165 standard, as defined in the
 * https://eips.ethereum.org/EIPS/eip-165[EIP].
 *
 * Implementers can declare support of contract interfaces, which can then be
 * queried by others ({ERC165Checker}).
 *
 * For an implementation, see {ERC165}.
 */
interface IERC165 {
    /**
     * @dev Returns true if this contract implements the interface defined by
     * `interfaceId`. See the corresponding
     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]
     * to learn more about how these ids are created.
     *
     * This function call must use less than 30 000 gas.
     */
    function supportsInterface(bytes4 interfaceId) external view returns (bool);
}

// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)

pragma solidity ^0.8.0;

/**
 * @title ERC721 token receiver interface
 * @dev Interface for any contract that wants to support safeTransfers
 * from ERC721 asset contracts.
 */
interface IERC721Receiver {
    /**
     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}
     * by `operator` from `from`, this function is called.
     *
     * It must return its Solidity selector to confirm the token transfer.
     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.
     *
     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.
     */
    function onERC721Received(
        address operator,
        address from,
        uint256 tokenId,
        bytes calldata data
    ) external returns (bytes4);
}

// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)

pragma solidity ^0.8.0;

import "../IERC721.sol";

/**
 * @title ERC-721 Non-Fungible Token Standard, optional metadata extension
 * @dev See https://eips.ethereum.org/EIPS/eip-721
 */
interface IERC721Metadata is IERC721 {
    /**
     * @dev Returns the token collection name.
     */
    function name() external view returns (string memory);

    /**
     * @dev Returns the token collection symbol.
     */
    function symbol() external view returns (string memory);

    /**
     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.
     */
    function tokenURI(uint256 tokenId) external view returns (string memory);
}

// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)

pragma solidity ^0.8.1;

/**
 * @dev Collection of functions related to the address type
 */
library Address {
    /**
     * @dev Returns true if `account` is a contract.
     *
     * [IMPORTANT]
     * ====
     * It is unsafe to assume that an address for which this function returns
     * false is an externally-owned account (EOA) and not a contract.
     *
     * Among others, `isContract` will return false for the following
     * types of addresses:
     *
     *  - an externally-owned account
     *  - a contract in construction
     *  - an address where a contract will be created
     *  - an address where a contract lived, but was destroyed
     * ====
     *
     * [IMPORTANT]
     * ====
     * You shouldn't rely on `isContract` to protect against flash loan attacks!
     *
     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets
     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract
     * constructor.
     * ====
     */
    function isContract(address account) internal view returns (bool) {
        // This method relies on extcodesize/address.code.length, which returns 0
        // for contracts in construction, since the code is only stored at the end
        // of the constructor execution.

        return account.code.length > 0;
    }

    /**
     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to
     * `recipient`, forwarding all available gas and reverting on errors.
     *
     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost
     * of certain opcodes, possibly making contracts go over the 2300 gas limit
     * imposed by `transfer`, making them unable to receive funds via
     * `transfer`. {sendValue} removes this limitation.
     *
     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].
     *
     * IMPORTANT: because control is transferred to `recipient`, care must be
     * taken to not create reentrancy vulnerabilities. Consider using
     * {ReentrancyGuard} or the
     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].
     */
    function sendValue(address payable recipient, uint256 amount) internal {
        require(address(this).balance >= amount, "Address: insufficient balance");

        (bool success, ) = recipient.call{value: amount}("");
        require(success, "Address: unable to send value, recipient may have reverted");
    }

    /**
     * @dev Performs a Solidity function call using a low level `call`. A
     * plain `call` is an unsafe replacement for a function call: use this
     * function instead.
     *
     * If `target` reverts with a revert reason, it is bubbled up by this
     * function (like regular Solidity function calls).
     *
     * Returns the raw returned data. To convert to the expected return value,
     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].
     *
     * Requirements:
     *
     * - `target` must be a contract.
     * - calling `target` with `data` must not revert.
     *
     * _Available since v3.1._
     */
    function functionCall(address target, bytes memory data) internal returns (bytes memory) {
        return functionCall(target, data, "Address: low-level call failed");
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with
     * `errorMessage` as a fallback revert reason when `target` reverts.
     *
     * _Available since v3.1._
     */
    function functionCall(
        address target,
        bytes memory data,
        string memory errorMessage
    ) internal returns (bytes memory) {
        return functionCallWithValue(target, data, 0, errorMessage);
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
     * but also transferring `value` wei to `target`.
     *
     * Requirements:
     *
     * - the calling contract must have an ETH balance of at least `value`.
     * - the called Solidity function must be `payable`.
     *
     * _Available since v3.1._
     */
    function functionCallWithValue(
        address target,
        bytes memory data,
        uint256 value
    ) internal returns (bytes memory) {
        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");
    }

    /**
     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but
     * with `errorMessage` as a fallback revert reason when `target` reverts.
     *
     * _Available since v3.1._
     */
    function functionCallWithValue(
        address target,
        bytes memory data,
        uint256 value,
        string memory errorMessage
    ) internal returns (bytes memory) {
        require(address(this).balance >= value, "Address: insufficient balance for call");
        require(isContract(target), "Address: call to non-contract");

        (bool success, bytes memory returndata) = target.call{value: value}(data);
        return verifyCallResult(success, returndata, errorMessage);
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
     * but performing a static call.
     *
     * _Available since v3.3._
     */
    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {
        return functionStaticCall(target, data, "Address: low-level static call failed");
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],
     * but performing a static call.
     *
     * _Available since v3.3._
     */
    function functionStaticCall(
        address target,
        bytes memory data,
        string memory errorMessage
    ) internal view returns (bytes memory) {
        require(isContract(target), "Address: static call to non-contract");

        (bool success, bytes memory returndata) = target.staticcall(data);
        return verifyCallResult(success, returndata, errorMessage);
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
     * but performing a delegate call.
     *
     * _Available since v3.4._
     */
    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {
        return functionDelegateCall(target, data, "Address: low-level delegate call failed");
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],
     * but performing a delegate call.
     *
     * _Available since v3.4._
     */
    function functionDelegateCall(
        address target,
        bytes memory data,
        string memory errorMessage
    ) internal returns (bytes memory) {
        require(isContract(target), "Address: delegate call to non-contract");

        (bool success, bytes memory returndata) = target.delegatecall(data);
        return verifyCallResult(success, returndata, errorMessage);
    }

    /**
     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the
     * revert reason using the provided one.
     *
     * _Available since v4.3._
     */
    function verifyCallResult(
        bool success,
        bytes memory returndata,
        string memory errorMessage
    ) internal pure returns (bytes memory) {
        if (success) {
            return returndata;
        } else {
            // Look for revert reason and bubble it up if present
            if (returndata.length > 0) {
                // The easiest way to bubble the revert reason is using memory via assembly
                /// @solidity memory-safe-assembly
                assembly {
                    let returndata_size := mload(returndata)
                    revert(add(32, returndata), returndata_size)
                }
            } else {
                revert(errorMessage);
            }
        }
    }
}

// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)

pragma solidity ^0.8.0;

/**
 * @dev Provides information about the current execution context, including the
 * sender of the transaction and its data. While these are generally available
 * via msg.sender and msg.data, they should not be accessed in such a direct
 * manner, since when dealing with meta-transactions the account sending and
 * paying for execution may not be the actual sender (as far as an application
 * is concerned).
 *
 * This contract is only required for intermediate, library-like contracts.
 */
abstract contract Context {
    function _msgSender() internal view virtual returns (address) {
        return msg.sender;
    }

    function _msgData() internal view virtual returns (bytes calldata) {
        return msg.data;
    }
}

// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v4.7.0) (utils/Strings.sol)

pragma solidity ^0.8.0;

/**
 * @dev String operations.
 */
library Strings {
    bytes16 private constant _HEX_SYMBOLS = "0123456789abcdef";
    uint8 private constant _ADDRESS_LENGTH = 20;

    /**
     * @dev Converts a `uint256` to its ASCII `string` decimal representation.
     */
    function toString(uint256 value) internal pure returns (string memory) {
        // Inspired by OraclizeAPI's implementation - MIT licence
        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol

        if (value == 0) {
            return "0";
        }
        uint256 temp = value;
        uint256 digits;
        while (temp != 0) {
            digits++;
            temp /= 10;
        }
        bytes memory buffer = new bytes(digits);
        while (value != 0) {
            digits -= 1;
            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));
            value /= 10;
        }
        return string(buffer);
    }

    /**
     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.
     */
    function toHexString(uint256 value) internal pure returns (string memory) {
        if (value == 0) {
            return "0x00";
        }
        uint256 temp = value;
        uint256 length = 0;
        while (temp != 0) {
            length++;
            temp >>= 8;
        }
        return toHexString(value, length);
    }

    /**
     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.
     */
    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {
        bytes memory buffer = new bytes(2 * length + 2);
        buffer[0] = "0";
        buffer[1] = "x";
        for (uint256 i = 2 * length + 1; i > 1; --i) {
            buffer[i] = _HEX_SYMBOLS[value & 0xf];
            value >>= 4;
        }
        require(value == 0, "Strings: hex length insufficient");
        return string(buffer);
    }

    /**
     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.
     */
    function toHexString(address addr) internal pure returns (string memory) {
        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);
    }
}

// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)

pragma solidity ^0.8.0;

import "./IERC165.sol";

/**
 * @dev Implementation of the {IERC165} interface.
 *
 * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check
 * for the additional interface id that will be supported. For example:
 *
 * ```solidity
 * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {
 *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);
 * }
 * ```
 *
 * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.
 */
abstract contract ERC165 is IERC165 {
    /**
     * @dev See {IERC165-supportsInterface}.
     */
    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {
        return interfaceId == type(IERC165).interfaceId;
    }
}

// SPDX-License-Identifier: MIT-BROUGKR
/*@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                     @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@          @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                 @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@              @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@              @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                 @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                     @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@*/
/**
 * @dev: @brougkr
 */
pragma solidity 0.8.16;
import {IERC721} from '@openzeppelin/contracts/interfaces/IERC721.sol';
import {ERC721} from '@openzeppelin/contracts/token/ERC721/ERC721.sol';
import {IERC20} from '@openzeppelin/contracts/interfaces/IERC20.sol';
import {Ownable} from '@openzeppelin/contracts/access/Ownable.sol';
import {ReentrancyGuard} from '@openzeppelin/contracts/security/ReentrancyGuard.sol';
import {IArtBlocks} from './IArtBlocks.sol';
import {IRandomEdition} from './IRandomEdition.sol';
contract PurchaseMinter is Ownable, ReentrancyGuard
{   
    struct Artist
    {
        string Name;
        uint Price;
        address ContractAddress;
        bool MintType;
        bool Active;
    }

    mapping(uint=>Artist) public Artists;
    mapping(address=>bool) public Roles;

    event ArtistMintComplete(address Recipient, uint ArtistID, uint TokenID);
    event ArtistSeeded(uint ArtistID, string Name, uint Price, address ContractAddress, bool MintType, bool Active);

    constructor()
    {
        Artists[0] = Artist('Holger Lippmann | Radarscope', 0.25 ether, 0x3Bc11937B33bC27Cf730961b93dc3BEeF2e3A2d5, false, true);
        Artists[1] = Artist('Ellie Pritts | Reverse Zoology', 0.25 ether, 0x37E534FD1b87bFb97A20192DC1550992ecAB5e2d, false, true);
        Artists[2] = Artist('Gabriel Massan | Non-Living', 0.25 ether, 0x0466FBD45d873447511A99EB95D6790Ec7510611, false, true);
        Artists[3] = Artist('Alida Sun | Stellarum', 0.5 ether, 0x7b9a45E278b5B374bb2d96C65665d4360C97BF01, true, true);
        Artists[4] = Artist('Jason Ting | Lux', 0.5 ether, 0x7b9a45E278b5B374bb2d96C65665d4360C97BF01, true, true);
        Roles[0xe06F5FAE754e81Bc050215fF89B03d9e9FF20700] = true;
        // _transferOwnership(0xe06F5FAE754e81Bc050215fF89B03d9e9FF20700);
    }

    /**
     * @dev Mints Singular Artist
     **/
    function MintArtist(uint ArtistID, uint Amount) public payable nonReentrant  
    {
        require(Artists[ArtistID].Active, "Purchasing Not Active");
        require(msg.value == Amount * Artists[ArtistID].Price, "Invalid Message Value");
        require(Amount > 0, "Invalid Amount");
        for(uint x; x < Amount; x++)
        {
            uint TokenID;
            if(Artists[ArtistID].MintType) { TokenID = IArtBlocks(Artists[ArtistID].ContractAddress).purchaseTo(msg.sender, ArtistID); }
            else { TokenID = IRandomEdition(Artists[ArtistID].ContractAddress)._Mint(msg.sender, 1); }
            emit ArtistMintComplete(msg.sender, ArtistID, TokenID);
        }
    }

    /**
     * @dev Mints Multiple Artists
     */
    function MintArtists(uint[] calldata ArtistIDs, uint[] calldata Amounts) public payable nonReentrant
    {
        for(uint x; x < ArtistIDs.length; x++)
        {
            require(Artists[ArtistIDs[x]].Active, "Purchasing Not Active");
            require(msg.value == Amounts[x] * Artists[ArtistIDs[x]].Price, "Invalid Message Value");
            require(Amounts[x] > 0, "Invalid Amount");
            for(uint y; y < Amounts.length; y++)
            {
                uint TokenID;
                if(Artists[ArtistIDs[x]].MintType) // ArtBlocks Mint
                { TokenID = IArtBlocks(Artists[ArtistIDs[x]].ContractAddress).purchaseTo(msg.sender, ArtistIDs[x]); }
                else // Random Edition Mint
                { TokenID = IRandomEdition(Artists[ArtistIDs[x]].ContractAddress)._Mint(msg.sender, 1); }
                emit ArtistMintComplete(msg.sender, ArtistIDs[x], TokenID);
            }
        }
    }

    /*-------------------*/
    /*  ADMIN FUNCTIONS  */
    /*-------------------*/

    /**
     * @dev Overwrites Artist
     */
    function __OverwriteArtist(
        uint ArtistID,
        string calldata Name,
        uint Price,
        address ContractAddress,
        bool MintType,
        bool Active
    ) external onlyBRTAdmin {
        Artists[ArtistID].Name = Name;
        Artists[ArtistID].Price = Price;
        Artists[ArtistID].ContractAddress = ContractAddress;
        Artists[ArtistID].MintType = MintType;
        Artists[ArtistID].Active = Active;
        emit ArtistSeeded(ArtistID, Name, Price, ContractAddress, MintType, Active);
    }

    /**
     * @dev Changes Artist Name
     */
    function __ChangeName(uint ArtistID, string calldata Name) external onlyBRTAdmin
    {
        Artists[ArtistID].Name = Name;
    }

    /**
     * @dev Changes Artist Price
     */
    function __ChangePrice(uint ArtistID, uint Price) external onlyBRTAdmin
    {
        Artists[ArtistID].Price = Price;
    }

    /**
     * @dev Changes Artist Contract Address
     */
    function __ChangeContractAddress(uint ArtistID, address Address) external onlyBRTAdmin
    {
        Artists[ArtistID].ContractAddress = Address;
    }

    /**
     * @dev Changes Artist Mint Type
     */
    function __ChangeMintType(uint ArtistID, bool MintType) external onlyBRTAdmin
    {
        Artists[ArtistID].MintType = MintType;
    }

    /**
     * @dev Changes Artist Active State
     */
    function __ChangeActiveState(uint ArtistID, bool Active) external onlyBRTAdmin
    {
        Artists[ArtistID].Active = Active;
    }
    
    /**
     * @dev Batch Approves BRT For Purchasing
     */
    function __BatchApproveERC20(
        address[] calldata ERC20s,
        address[] calldata Operators,
        uint[] calldata Amounts
    ) external onlyBRTAdmin {
        require(
            ERC20s.length == Operators.length
            &&
            Operators.length == Amounts.length,
            "LiveMint: Arrays Must Be Equal Length"
        );
        for(uint i; i < ERC20s.length; i++) { IERC20(ERC20s[i]).approve(Operators[i], Amounts[i]); }
    }

    /**
     * @dev Adds Admin To Contract
     */
    function __AddAdmin(address Admin) external onlyOwner { Roles[Admin] = true; }

    /**
     * @dev Removes Admin From Contract
     */
    function __RemoveAdmin(address Admin) external onlyOwner { Roles[Admin] = false; }

    /**
     * @dev Withdraws ERC20 From Contract To Address
     */
    function __WithdrawERC20ToAddress(address Recipient, address ContractAddress) external onlyOwner
    {
        IERC20 ERC20 = IERC20(ContractAddress);
        ERC20.transferFrom(address(this), Recipient, ERC20.balanceOf(address(this)));
    }

    /**
     * @dev Withdraws All Ether From Contract To Owner
     */
    function __Withdraw() external onlyOwner 
    {
        uint balance = address(this).balance;
        require(balance > 0, "Insufficient Balance"); 
        payable(msg.sender).transfer(balance); 
    }

    /**
     * @dev Returns Sale States
     */
    function viewSaleStates(uint[] calldata ArtistIndexes) public view returns(Artist[] memory) 
    {
        Artist[] memory SaleStates = new Artist[](ArtistIndexes.length);
        for (uint i; i < ArtistIndexes.length; i++) 
        {
            Artist storage saleInstance = Artists[ArtistIndexes[i]];
            SaleStates[i] = saleInstance;
        }
        return SaleStates;
    }

    function paycontractlol() payable external { }

    /**
     * @dev Function Modifier Restricting Access To Certain Functions To BRT Operators
     */
    modifier onlyBRTAdmin
    {
        require(Roles[msg.sender], "User Is Not BRT Admin");
        _;
    }
}

// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts v4.4.1 (interfaces/IERC20.sol)

pragma solidity ^0.8.0;

import "../token/ERC20/IERC20.sol";

// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)

pragma solidity ^0.8.0;

import "../utils/Context.sol";

/**
 * @dev Contract module which provides a basic access control mechanism, where
 * there is an account (an owner) that can be granted exclusive access to
 * specific functions.
 *
 * By default, the owner account will be the one that deploys the contract. This
 * can later be changed with {transferOwnership}.
 *
 * This module is used through inheritance. It will make available the modifier
 * `onlyOwner`, which can be applied to your functions to restrict their use to
 * the owner.
 */
abstract contract Ownable is Context {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    /**
     * @dev Initializes the contract setting the deployer as the initial owner.
     */
    constructor() {
        _transferOwnership(_msgSender());
    }

    /**
     * @dev Throws if called by any account other than the owner.
     */
    modifier onlyOwner() {
        _checkOwner();
        _;
    }

    /**
     * @dev Returns the address of the current owner.
     */
    function owner() public view virtual returns (address) {
        return _owner;
    }

    /**
     * @dev Throws if the sender is not the owner.
     */
    function _checkOwner() internal view virtual {
        require(owner() == _msgSender(), "Ownable: caller is not the owner");
    }

    /**
     * @dev Leaves the contract without owner. It will not be possible to call
     * `onlyOwner` functions anymore. Can only be called by the current owner.
     *
     * NOTE: Renouncing ownership will leave the contract without an owner,
     * thereby removing any functionality that is only available to the owner.
     */
    function renounceOwnership() public virtual onlyOwner {
        _transferOwnership(address(0));
    }

    /**
     * @dev Transfers ownership of the contract to a new account (`newOwner`).
     * Can only be called by the current owner.
     */
    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(newOwner != address(0), "Ownable: new owner is the zero address");
        _transferOwnership(newOwner);
    }

    /**
     * @dev Transfers ownership of the contract to a new account (`newOwner`).
     * Internal function without access restriction.
     */
    function _transferOwnership(address newOwner) internal virtual {
        address oldOwner = _owner;
        _owner = newOwner;
        emit OwnershipTransferred(oldOwner, newOwner);
    }
}

// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)

pragma solidity ^0.8.0;

/**
 * @dev Contract module that helps prevent reentrant calls to a function.
 *
 * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier
 * available, which can be applied to functions to make sure there are no nested
 * (reentrant) calls to them.
 *
 * Note that because there is a single `nonReentrant` guard, functions marked as
 * `nonReentrant` may not call one another. This can be worked around by making
 * those functions `private`, and then adding `external` `nonReentrant` entry
 * points to them.
 *
 * TIP: If you would like to learn more about reentrancy and alternative ways
 * to protect against it, check out our blog post
 * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].
 */
abstract contract ReentrancyGuard {
    // Booleans are more expensive than uint256 or any type that takes up a full
    // word because each write operation emits an extra SLOAD to first read the
    // slot's contents, replace the bits taken up by the boolean, and then write
    // back. This is the compiler's defense against contract upgrades and
    // pointer aliasing, and it cannot be disabled.

    // The values being non-zero value makes deployment a bit more expensive,
    // but in exchange the refund on every call to nonReentrant will be lower in
    // amount. Since refunds are capped to a percentage of the total
    // transaction's gas, it is best to keep them low in cases like this one, to
    // increase the likelihood of the full refund coming into effect.
    uint256 private constant _NOT_ENTERED = 1;
    uint256 private constant _ENTERED = 2;

    uint256 private _status;

    constructor() {
        _status = _NOT_ENTERED;
    }

    /**
     * @dev Prevents a contract from calling itself, directly or indirectly.
     * Calling a `nonReentrant` function from another `nonReentrant`
     * function is not supported. It is possible to prevent this from happening
     * by making the `nonReentrant` function external, and making it call a
     * `private` function that does the actual work.
     */
    modifier nonReentrant() {
        // On the first call to nonReentrant, _notEntered will be true
        require(_status != _ENTERED, "ReentrancyGuard: reentrant call");

        // Any calls to nonReentrant after this point will fail
        _status = _ENTERED;

        _;

        // By storing the original value once again, a refund is triggered (see
        // https://eips.ethereum.org/EIPS/eip-2200)
        _status = _NOT_ENTERED;
    }
}

// SPDX-License-Identifier: MIT
pragma solidity ^0.8.16;
interface IArtBlocks 
{ 
    function purchase(uint256 _projectId) payable external returns (uint tokenID); 
    function purchaseTo(address _to, uint _projectId) payable external returns (uint tokenID);
    function tokenURI(uint256 _tokenId) external view returns (string memory);
}

//SPDX-License-Identifier: MIT
pragma solidity 0.8.16;
interface IRandomEdition
{
    function _Mint(address Recipient, uint Amount) external returns(uint tokenID); // Mints Random Edition
    function purchaseTo(address Recipient) external returns(uint tokenID); // Mints Random Edition
    function tokenURI(uint256 tokenId) external view returns (string memory); // Returns IPFS Metadata
}

// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)

pragma solidity ^0.8.0;

/**
 * @dev Interface of the ERC20 standard as defined in the EIP.
 */
interface IERC20 {
    /**
     * @dev Emitted when `value` tokens are moved from one account (`from`) to
     * another (`to`).
     *
     * Note that `value` may be zero.
     */
    event Transfer(address indexed from, address indexed to, uint256 value);

    /**
     * @dev Emitted when the allowance of a `spender` for an `owner` is set by
     * a call to {approve}. `value` is the new allowance.
     */
    event Approval(address indexed owner, address indexed spender, uint256 value);

    /**
     * @dev Returns the amount of tokens in existence.
     */
    function totalSupply() external view returns (uint256);

    /**
     * @dev Returns the amount of tokens owned by `account`.
     */
    function balanceOf(address account) external view returns (uint256);

    /**
     * @dev Moves `amount` tokens from the caller's account to `to`.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transfer(address to, uint256 amount) external returns (bool);

    /**
     * @dev Returns the remaining number of tokens that `spender` will be
     * allowed to spend on behalf of `owner` through {transferFrom}. This is
     * zero by default.
     *
     * This value changes when {approve} or {transferFrom} are called.
     */
    function allowance(address owner, address spender) external view returns (uint256);

    /**
     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * IMPORTANT: Beware that changing an allowance with this method brings the risk
     * that someone may use both the old and the new allowance by unfortunate
     * transaction ordering. One possible solution to mitigate this race
     * condition is to first reduce the spender's allowance to 0 and set the
     * desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     *
     * Emits an {Approval} event.
     */
    function approve(address spender, uint256 amount) external returns (bool);

    /**
     * @dev Moves `amount` tokens from `from` to `to` using the
     * allowance mechanism. `amount` is then deducted from the caller's
     * allowance.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transferFrom(
        address from,
        address to,
        uint256 amount
    ) external returns (bool);
}

// SPDX-License-Identifier: MIT-BROUGKR
/*@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                     @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@          @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                 @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@              @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@              @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                 @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                     @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@*/
/**
 * @dev: @brougkr
 */
pragma solidity 0.8.16;
import {IERC721} from '@openzeppelin/contracts/interfaces/IERC721.sol';
import {ERC721} from '@openzeppelin/contracts/token/ERC721/ERC721.sol';
import {IERC20} from '@openzeppelin/contracts/interfaces/IERC20.sol';
import {Ownable} from '@openzeppelin/contracts/access/Ownable.sol';
import {ReentrancyGuard} from '@openzeppelin/contracts/security/ReentrancyGuard.sol';
import {MerkleProof} from '@openzeppelin/contracts/utils/cryptography/MerkleProof.sol';
import {IArtBlocks} from './IArtBlocks.sol';
import {IRandomEdition} from './IRandomEdition.sol';
import {CTZNPlugin, ICTZN} from "./CTZNPlugin.sol";
import {IMPMX} from "./IMPMX.sol";
contract CryptoCitizenLiveMint is Ownable, ReentrancyGuard, CTZNPlugin
{   
    /*-------------------*/
    /*  STATE VARIABLES  */
    /*-------------------*/

    bytes32 private immutable _MINTER_ROLE = keccak256("MINTER_ROLE");                                  // Minter Role
    address public immutable _BRTMULTISIG = 0xcff43A597911a9457071d89d2b2AC3D5b1862b86;                 // BRT Multisig Burn Address (mint.brightmoments.eth)
    address public _MPMX = address(0);                                                                  // MPMX Address
    address public _ERC20_BRT_Token = 0x9EaFE760bC0eb62f0f9c5DCa18012478d9d8B2D2;                       // BRT ERC-20 Contract Address   
    address public _ArtBlocksMintingContractCitizens = 0xDd06d8483868Cd0C5E69C24eEaA2A5F2bEaFd42b;      // ArtBlocks Minting Contract Citizens
    address public _ArtBlocksMintingContractArtists = 0x7b9a45E278b5B374bb2d96C65665d4360C97BF01;       // ArtBlocks Minting Contract Artists
    address public _ArtBlocksCoreContractCitizens = 0xbDdE08BD57e5C9fD563eE7aC61618CB2ECdc0ce0;         // ArtBlocks Citizen NFT Collection Contract Address
    address public _ArtBlocksCoreContractArtists = 0x0A1BBD57033F57E7B6743621b79fCB9Eb2CE3676;          // ArtBlocks Artist NFT Collection Contract Address 
    address public _GoldenToken = 0x7581e6E514bac22B6303e92A5eAa4bfF3167142D;                           // Golden Token Contract Address
    uint public _ArtBlocksProjectID = 5;                                                                // ArtBlocks Project ID
    uint public _CurrentCityIndex;                                                                      // Current City Index
    uint public _QRIndex = 332;                                                                         // QR Code Index
    bytes32 public Root = 0x1da12153acc50857d9bd0ff180f7a07f4d42c7c11f6b357a452fc8621c480cc6;           // Merkle Root

    /*-------------------*/
    /*     MAPPINGS      */
    /*-------------------*/
    
    mapping(uint => mapping(address => bool)) public RedeemedQR;                                    // Returns If User Has BrightList Minted NFT
    mapping(uint => mapping(address => uint)) public QRAllocation;                                  // Returns User's QR Code Allocation

    mapping(uint => mapping(uint => mapping(uint => address))) public BrightListArtist;             // Returns Address Of Minting Receiver For Artist Mint 
    mapping(uint => mapping(uint => mapping(uint => bool))) public MintedArtist;                    // Returns Boolean If Artist MintPass ID Has Minted Or Not
    mapping(uint => mapping(uint => mapping(uint => bool))) public DelegateStatusArtist;            // Returns Delegate Status Of Artist TicketID
    mapping(uint => mapping(uint => mapping(uint => uint))) public SelectedTimeSlotArtistMintPass;  // Returns Selected TimeSlot Corresponding To Artist Mint Pass

    mapping(uint => mapping(uint => address)) public BrightListCitizen;                             // Returns Address Of Minting Receiver For CryptoCitizen Mint
    mapping(uint => mapping(uint => bool)) public MintedCitizen;                                    // Returns Boolean If Golden Ticket ID Has Minted Or Not
    mapping(uint => mapping(uint => bool)) public DelegateStatusCitizen;                            // Returns Delegate Status Of Citizen TicketID
    mapping(uint => mapping(uint => uint)) public SelectedTimeSlotGoldenTicket;                     // Returns Selected TimeSlot Corresponding To Golden Ticket
    
    mapping(uint => mapping(uint => address)) public ArtistMintPasses;                              // Returns Contract Address Of Artist Mint Pass NFT 
    mapping(uint => uint) public ArtistIDToProjectID;
    mapping(uint => mapping(uint => address)) public ArtistContracts;                               // Returns Contract Address Of Artist Collection NFT
    mapping(uint => mapping(uint => bool)) public MintType;                                         // Artist Mint Type (true for ArtBlocks | false for Random Edition)
    mapping(address => bytes32) private Role;                                                       // BRT Minter Role Mapping

    /*-------------------*/
    /*      EVENTS       */
    /*-------------------*/

    /**
     * @dev Emitted When `Redeemer` IRL-mints CryptoCitizen Corresponding To Their Redeemed `TicketID`.
     **/
    event LiveMintComplete(address indexed Redeemer, uint TicketID, uint TokenID, bool Delegate);

    /**
     * @dev Emitted When `Redeemer` IRL-Mints Artist Corresponding To `ArtistID`
     */
    event LiveMintCompleteArtist(address indexed Redeemer, uint ArtistID, uint TicketID, uint TokenID, bool Delegate);

    /**
     * @dev Emitted When `Redeemer` Redeems Golden Token Corresponding To `TicketID` 
     **/
    event GoldenTokenRedeemed(address indexed Redeemer, uint TicketID, uint Slot, bool Delegate);

    /**
     * @dev Emitted When `Redeemer` Redeems Golden Token Corresponding To `TicketID` 
     **/
    event QRRedeemed(address indexed Redeemer, uint TicketID, uint Slot);

    /**
     * @dev Emitted When `Redeemer` Redeems Artist Mint Pass Corresponding To `TicketID`
     */
    event ArtistMintPassRedeemed(address indexed Redeemer, uint ArtistID, uint TicketID, uint Slot, bool Delegate);

    /**
     * @dev Emitted When `NewMinter` Is Added To BRT Minter List
     */
    event MinterAdded(address NewMinter);

    /**
     * @dev Emitted When `RemovedMinter` Is Removed From BRT Minter List
     */
    event MinterRemoved(address RemovedMinter);

    /**
     * @dev Emitted When `NewProjectID` Replaces `OldProjectID`
     */
    event ModifiedProjectID(uint OldProjectID, uint NewProjectID);

    /**
     * @dev Emitted When `NewMintingAddress` Replaces `OldMintingAddress`
     */
    event ArtBlocksMintingAddressChanged(address OldMintingAddress, address NewMintingAddress);

    /**
     * @dev Emitted When `NewCoreAddress` Replaces `OldCoreAddress` For ArtBlocks Citizen Mints
     */
    event ArtBlocksCoreAddressChanged(address OldCoreAddress, address NewCoreAddress);

    /**
     * @dev Emitted When `NewCoreAddress` Replaces `OldCoreAddress` For ArtBlocks Artist Mints
     */
    event ArtBlocksCoreAddressChangedArtist(address OldCoreAddress, address NewCoreAddress);

    /**
     * @dev Emitted When `NewGTAddress` Replaces `OldGTAddress`
     */
    event GoldenTokenAddressChanged(address OldGTAddress, address NewGTAddress);

    /**
     * @dev Emitted When `NewERC20Address` Replaces `OldERC20Address`
     */
    event ERC20AddressChanged(address OldERC20Address, address NewERC20Address);

    /**
     * @dev Emitted When `NewIndex` Replaces `OldIndex`
     */
    event CurrentCityIndexChanged(uint OldIndex, uint NewIndex);

    /**
     * @dev Emitted When Multiple Golden Token TimeSlot Changes Occur
     */
    event TimeSlotsChanged(uint[] Slots, uint[] Amounts);

    /**
     * @dev Emitted When Multiple Artist TimeSlot Changes Occur
     */
    event TimeSlotsChangedArtists(uint[] ArtistIDs, uint[] Slots, uint[] Amounts);

    /**
     * @dev Emitted When Artist Contract Address Changes
     */
    event ArtistContractAddressChanged(address OldContractAddress, address NewContractAddress);

    /**
     * @dev Emitted When Artist Mint Type Changes
     */
    event ArtistMintTypeChanged(bool OldMintType, bool NewMintType);

    /**
     * @dev Emitted When Multisig Address Changes
     */
    event MultisigAddressChanged(address OldAddress, address NewAddress);

    /**
     * @dev Emitted When New Artists Are Seeded Into The Contract
     */
    event NewArtists(uint[] ArtistIDs, address[] MintPasses, address[] MintingAddresses, bool[] MintTypes);

    /**
     * @dev Emitted When Merkle Root Is Changed
     */
    event MerkleRootChanged(bytes32 OldRoot, bytes32 NewRoot);
    
    /**
     * @dev Emitted When A Reservation Is Wiped
     */
    event ReservationWiped(uint TicketID, address Redeemer, uint TimeSlot);

    /**
     * @dev Emitted When An Artist Reservation Is Wiped
     */
    event ReservationWipedArtist(uint ArtistID, uint TicketID, address Redeemer, uint TimeSlot);

    /**
     * @dev Emitted When QR Allocations Are Overwritten
     */
    event QRAllocationsOverwritten(address[] Addresses, uint[] Amounts);

    /**
     * @dev Emitted When QR Allocations Are Incremented
     */
    event QRAllocationsIncremented(address[] Addresses, uint[] Amounts);

    /**
     * @dev Emitted When New City State Variables Are Modified 
     */
    event NewCityStarted(
        address ERC20_BRT_TokenAddress,
        address GoldenTokenAddress,
        uint ArtBlocksProjectID,
        uint CurrentCityIndex,
        uint QRIndex
    );

    /*-------------------*/
    /*    CONSTRUCTOR    */
    /*-------------------*/

    /**
     * @dev Pre-Approves 1000 BRT For Purchasing, Grants BRT Minter Roles, & Transfers Ownership To BRT Multisig
     **/
    constructor()
    { 
        Role[0x1A0a3E3AE390a0710f8A6d00587082273eA8F6C9] = _MINTER_ROLE; // BRT Minter #1
        Role[0x4d8013b0c264034CBf22De9DF33e22f58D52F207] = _MINTER_ROLE; // BRT Minter #2
        Role[0x4D9A8CF2fE52b8D49C7F7EAA87b2886c2bCB4160] = _MINTER_ROLE; // BRT Minter #3
        Role[0x124fd966A0D83aA020D3C54AE2c9f4800b46F460] = _MINTER_ROLE; // BRT Minter #4
        Role[0x100469feA90Ac1Fe1073E1B2b5c020A8413635c4] = _MINTER_ROLE; // BRT Minter #5
        Role[0x756De4236373fd17652b377315954ca327412bBA] = _MINTER_ROLE; // BRT Minter #6
        Role[0xc5Dfba6ef7803665C1BDE478B51Bd7eB257A2Cb9] = _MINTER_ROLE; // BRT Minter #7
        Role[0xFBF32b29Bcf8fEe32d43a4Bfd3e7249daec457C0] = _MINTER_ROLE; // BRT Minter #8
        Role[0xF2A15A83DEE7f03C70936449037d65a1C100FF27] = _MINTER_ROLE; // BRT Minter #9
        Role[0x1D2BAB965a4bB72f177Cd641C7BacF3d8257230D] = _MINTER_ROLE; // BRT Minter #10
        Role[0x2e51E8b950D72BDf003b58E357C2BA28FB77c7fB] = _MINTER_ROLE; // BRT Minter #11
        Role[0x8a7186dECb91Da854090be8226222eA42c5eeCb6] = _MINTER_ROLE; // BRT Minter #12
        Role[0xe06F5FAE754e81Bc050215fF89B03d9e9FF20700] = _MINTER_ROLE; // BRT Minter #13
        Role[0x7603C5eed8e57Ad795ec5F0081eFB21d1eEBf937] = _MINTER_ROLE; // BRT Minter #14
        Role[address(0)] = _MINTER_ROLE;                                 // BRT Minter #15
        Role[address(0)] = _MINTER_ROLE;                                 // BRT Minter #16
        ArtistMintPasses[_CurrentCityIndex][13] = 0x52aE641b0890f6585Af4Af45dD23942125A4250E; 
        ArtistMintPasses[_CurrentCityIndex][14] = 0x52aE641b0890f6585Af4Af45dD23942125A4250E; 
        ArtistMintPasses[_CurrentCityIndex][15] = 0x52aE641b0890f6585Af4Af45dD23942125A4250E; 
        ArtistMintPasses[_CurrentCityIndex][16] = 0x52aE641b0890f6585Af4Af45dD23942125A4250E; 
        ArtistMintPasses[_CurrentCityIndex][17] = 0x52aE641b0890f6585Af4Af45dD23942125A4250E; 
        ArtistMintPasses[_CurrentCityIndex][18] = 0x52aE641b0890f6585Af4Af45dD23942125A4250E; 
        // IERC20(_ERC20_BRT_Token).approve( // CryptoCitizens
        //     _ArtBlocksMintingContractCitizens,
        //     0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff // Maximum Approval
        // );
        // IERC20(0x3dF1a91Fa71c24C8c52afcE62dbA54351CBA7a63).approve( // MPLC
        //     _ArtBlocksMintingContractArtists,
        //     0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff // Maximum Approval
        // );
        _RewardRates[0] = 100 ether; // Reward Rates [0] = Live Minting IRL WITHOUT DELEGATE
        _RewardRates[1] = 75 ether;  // Reward Rates [1] = Live Minting WITH DELEGATE
        _RewardRates[2] = 50 ether;  // Reward Rates [2] = Live Minting Artist WITHOUT DELEGATE
        _RewardRates[3] = 25 ether;  // Reward Rates [3] = Live Minting Artist WITH DELEGATE
        _RewardRates[4] = 10 ether;  // Reward Rates [4] = Redeeming Golden Token              
        _RewardRates[5] = 10 ether;  // Reward Rates [5] = Redeeming Artist Mint Pass
        _RewardRates[6] = 5 ether;   // Reward Rates [6] = Redeeming QR 
    }

    /*-------------------*/
    /*  PUBLIC FUNCTIONS */
    /*-------------------*/

    /**
     * @dev Redeems Golden Tokens & BrightLists Address To Receive CryptoCitizen
     **/
    function RedeemGT(
        uint[] calldata TicketIDs, 
        uint[] calldata TimeSlots, 
        bool[] calldata Delegates
    ) external nonReentrant {
        for(uint x; x < TicketIDs.length; x++)
        {
            require(IERC721(_GoldenToken).ownerOf(TicketIDs[x]) == msg.sender, "LiveMint: Sender Does Not Own Token With The Input Token ID");
            IERC721(_GoldenToken).transferFrom(msg.sender, _BRTMULTISIG, TicketIDs[x]);
            SelectedTimeSlotGoldenTicket[_CurrentCityIndex][TicketIDs[x]] = TimeSlots[x];
            BrightListCitizen[_CurrentCityIndex][TicketIDs[x]] = msg.sender;
            DelegateStatusCitizen[_CurrentCityIndex][TicketIDs[x]] = Delegates[x];
            require(IERC721(_GoldenToken).ownerOf(TicketIDs[x]) == _BRTMULTISIG, "LiveMint: Golden Token Redemption Failed");
            emit GoldenTokenRedeemed(msg.sender, TicketIDs[x], TimeSlots[x], Delegates[x]);
        }
        ICTZN(CTZN).IncrementCTZN(msg.sender, _RewardRates[4]*TicketIDs.length); 
    }

    /**
     * @dev Redeems Artist Mint Passes & BrightLists Address To Receive Artist Mint
     **/
    function RedeemArtistPass(
        uint[] calldata ArtistIDs, 
        uint[] calldata TicketIDs, 
        uint[] calldata TimeSlots, 
        bool[] calldata Delegates
    ) external nonReentrant {
        for(uint x; x < ArtistIDs.length; x++)
        {
            address ArtistMintPass = ArtistMintPasses[_CurrentCityIndex][ArtistIDs[x]];
            require(IERC721(ArtistMintPass).ownerOf(TicketIDs[x]) == msg.sender, "LiveMint: Sender Does Not Own Token With The Input Token ID");
            IERC721(ArtistMintPass).transferFrom(msg.sender, _BRTMULTISIG, TicketIDs[x]);
            BrightListArtist[_CurrentCityIndex][ArtistIDs[x]][TicketIDs[x]] = msg.sender;
            SelectedTimeSlotArtistMintPass[_CurrentCityIndex][ArtistIDs[x]][TicketIDs[x]] = TimeSlots[x];
            DelegateStatusArtist[_CurrentCityIndex][ArtistIDs[x]][TicketIDs[x]] = Delegates[x];
            require(IERC721(ArtistMintPass).ownerOf(TicketIDs[x]) == _BRTMULTISIG, "LiveMint: Golden Token Redemption Failed");
            emit ArtistMintPassRedeemed(msg.sender, ArtistIDs[x], TicketIDs[x], TimeSlots[x], Delegates[x]);
        }
        ICTZN(CTZN).IncrementCTZN(msg.sender, _RewardRates[5]*ArtistIDs.length);
    }

    /**
     * @dev Redeems Spot For IRL Minting
     */
    function RedeemQR(uint TimeSlot, bytes32[] calldata Proof) external nonReentrant 
    {
        require(readQREligibility(msg.sender, Proof), "LiveMint: User Is Not Eligible To Redeem QR"); 
        RedeemedQR[_CurrentCityIndex][msg.sender] = true;
        if(QRAllocation[_CurrentCityIndex][msg.sender] == 0) // User Is Able To Redeem Explicitly 1 QR Code
        {
            require(!RedeemedQR[_CurrentCityIndex][msg.sender], "LiveMint: User Has Already Redeemed");
            _QRIndex++;
            SelectedTimeSlotGoldenTicket[_CurrentCityIndex][_QRIndex] = TimeSlot;
            BrightListCitizen[_CurrentCityIndex][_QRIndex] = msg.sender;
            ICTZN(CTZN).IncrementCTZN(msg.sender, _RewardRates[6]);
            emit QRRedeemed(msg.sender, _QRIndex, TimeSlot);
        }
        else // User Is Able To Redeem More Than 1 QR Code Because Their Integer Allocation > 0
        {
            uint Allocation = QRAllocation[_CurrentCityIndex][msg.sender];
            for(uint x; x < Allocation; x++)
            {
                _QRIndex++;
                QRAllocation[_CurrentCityIndex][msg.sender]--;
                SelectedTimeSlotGoldenTicket[_CurrentCityIndex][_QRIndex] = TimeSlot;
                BrightListCitizen[_CurrentCityIndex][_QRIndex] = msg.sender;
                emit QRRedeemed(msg.sender, _QRIndex, TimeSlot);
            }
            ICTZN(CTZN).IncrementCTZN(msg.sender, _RewardRates[6]*Allocation);
        }
    }

    /*-------------------*/
    /*     BRT STAFF     */
    /*-------------------*/

    /*-----------------------
     * CITIZEN LIVE MINTING *
    -------------------------/

    /**
     * @dev Mints A Verified User On The Brightlist One CryptoCitizen
     */
    function _LiveMint(uint TicketID) external onlyMinter  
    {
        address Recipient = readBrightListCitizen(TicketID);
        require(Recipient != address(0), "LiveMint: Golden Token Entered Is Not Brightlisted");
        require(!MintedCitizen[_CurrentCityIndex][TicketID], "LiveMint: Golden Token Already Minted");
        MintedCitizen[_CurrentCityIndex][TicketID] = true;
        uint TokenID = IArtBlocks(_ArtBlocksMintingContractCitizens).purchaseTo(Recipient, _ArtBlocksProjectID);
        if(!DelegateStatusCitizen[_CurrentCityIndex][TicketID]) { ICTZN(CTZN).IncrementCTZN(Recipient, _RewardRates[0]); }
        else { ICTZN(CTZN).IncrementCTZN(Recipient, _RewardRates[1]); }
        emit LiveMintComplete(Recipient, TicketID, TokenID, DelegateStatusCitizen[_CurrentCityIndex][TicketID]);
    }

    /**
     * @dev Batch Mints Verified Users On The Brightlist CryptoCitizens
     */
    function __LiveMintBatch(uint[] calldata TicketIDs) external onlyMinter
    {
        for(uint TicketID; TicketID < TicketIDs.length; TicketID++)
        {
            address Recipient = readBrightListCitizen(TicketIDs[TicketID]);
            require(Recipient != address(0), "LiveMint: Golden Token Entered Is Not Brightlisted");
            require(!MintedCitizen[_CurrentCityIndex][TicketIDs[TicketID]], "LiveMint: Golden Token Already Minted");
            MintedCitizen[_CurrentCityIndex][TicketIDs[TicketID]] = true;
            uint TokenID = IArtBlocks(_ArtBlocksMintingContractCitizens).purchaseTo(Recipient, _ArtBlocksProjectID);
            if(!DelegateStatusCitizen[_CurrentCityIndex][TicketIDs[TicketID]]) { ICTZN(CTZN).IncrementCTZN(Recipient, _RewardRates[0]); }
            else { ICTZN(CTZN).IncrementCTZN(Recipient, _RewardRates[1]); }
            emit LiveMintComplete(Recipient, TicketIDs[TicketID], TokenID, DelegateStatusCitizen[_CurrentCityIndex][TicketIDs[TicketID]]); 
        }
    }

    /*----------------------
     * ARTIST LIVE MINTING *
    ------------------------/

    /**
     * @dev Mints A Verified User On The Brightlist One Artist NFT
     */
    function _LiveMintArtist(uint TicketID) external onlyMinter  
    {
        uint ArtistID = ArtistIDToProjectID[IMPMX(_MPMX).ViewArtistID(TicketID)];
        require(!MintedArtist[_CurrentCityIndex][ArtistID][TicketID], "LiveMint: Artist Mint Pass Already Minted");
        address Recipient = IMPMX(_MPMX)._LiveMintBurn(TicketID);
        require(Recipient != address(0), "LiveMint: Mint Pass Entered Is Not Valid");
        MintedArtist[_CurrentCityIndex][ArtistID][TicketID] = true;
        address ArtistMintingContractAddress = resolveArtistContract(ArtistID);
        bool ArtBlocksMint = resolveArtistMint(ArtistID);
        uint TokenID;
        if(ArtBlocksMint) { TokenID = IArtBlocks(ArtistMintingContractAddress).purchaseTo(Recipient, ArtistID); }
        else { TokenID = IRandomEdition(ArtistMintingContractAddress).purchaseTo(Recipient); }
        if(!DelegateStatusArtist[_CurrentCityIndex][ArtistID][TicketID]) { ICTZN(CTZN).IncrementCTZN(Recipient, _RewardRates[2]); }
        else { ICTZN(CTZN).IncrementCTZN(Recipient, _RewardRates[3]); }
        emit LiveMintCompleteArtist(Recipient, ArtistID, TicketID, TokenID, DelegateStatusArtist[_CurrentCityIndex][ArtistID][TicketID]);
    }

    /**
     * @dev Batch Mints Verified Users On The Brightlist Artist NFTs
     */
    function _LiveMintArtistBatch(uint[] calldata TicketIDs) external onlyMinter 
    {
        for(uint TicketID; TicketID < TicketIDs.length; TicketID++)
        {
            uint ArtistID = ArtistIDToProjectID[IMPMX(_MPMX).ViewArtistID(TicketIDs[TicketID])];
            require(!MintedArtist[_CurrentCityIndex][ArtistID][TicketIDs[TicketID]], "LiveMint: Artist Mint Pass Already Minted");
            address Recipient = IMPMX(_MPMX)._LiveMintBurn(TicketIDs[TicketID]);
            require(Recipient != address(0), "LiveMint: Mint Pass Entered Is Not Brightlisted");
            MintedArtist[_CurrentCityIndex][ArtistID][TicketIDs[TicketID]] = true;
            address ArtistMintingContractAddress = resolveArtistContract(ArtistID);
            bool ArtBlocksMint = resolveArtistMint(ArtistID);
            uint TokenID;
            if(ArtBlocksMint) { TokenID = IArtBlocks(ArtistMintingContractAddress).purchaseTo(Recipient, ArtistID); }
            else { TokenID = IRandomEdition(ArtistMintingContractAddress).purchaseTo(Recipient); }
            if(!DelegateStatusArtist[_CurrentCityIndex][ArtistID][TicketIDs[TicketID]]) { ICTZN(CTZN).IncrementCTZN(Recipient, _RewardRates[2]); } 
            else { ICTZN(CTZN).IncrementCTZN(Recipient, _RewardRates[3]); }
            emit LiveMintCompleteArtist(
                Recipient, ArtistID, 
                TicketIDs[TicketID], 
                TokenID, 
                DelegateStatusArtist[_CurrentCityIndex][ArtistID][TicketID]
            );
        }
    }

    /*-------------------*/
    /*  OWNER FUNCTIONS  */
    /*-------------------*/

    /**
     * @dev Batch Approves BRT For Purchasing
     */
    function __BatchApproveERC20(address[] calldata ERC20s, address[] calldata Operators, uint[] calldata Amounts) external onlyOwner
    {
        require(ERC20s.length == Operators.length && Operators.length == Amounts.length, "LiveMint: Arrays Must Be Equal Length");
        for(uint i; i < ERC20s.length; i++)
        {
            IERC20(ERC20s[i]).approve(Operators[i], Amounts[i]);
        }
    }

    /**``
     * @dev Grants Address BRT Minter Role
     **/
    function __MinterAdd(address Minter) external onlyOwner 
    { 
        Role[Minter] = _MINTER_ROLE; 
        emit MinterAdded(Minter);
    }

    /**
     * @dev Deactivates Address From BRT Minter Role
     **/
    function __MinterRemove(address Minter) external onlyOwner 
    { 
        Role[Minter] = 0x0; 
        emit MinterRemoved(Minter);
    }

    /**
     * @dev Wipes Reservation If Someone Mistakenly Burns GT
     */
    function __WipeReservationGT(uint TicketID) external onlyOwner
    {
        uint TimeSlot = SelectedTimeSlotGoldenTicket[_CurrentCityIndex][TicketID];
        address Redeemer = BrightListCitizen[_CurrentCityIndex][TicketID];
        SelectedTimeSlotGoldenTicket[_CurrentCityIndex][TimeSlot] = 0;
        BrightListCitizen[_CurrentCityIndex][TicketID] = address(0);
        DelegateStatusCitizen[_CurrentCityIndex][TicketID] = false;
        emit ReservationWiped(TicketID, Redeemer, TimeSlot);
    }

    /**
     * @dev Wipes Reservation If Someone Mistakenly Burns GT
     */
    function __WipeReservationArtist(uint ArtistID, uint TicketID) external onlyOwner
    {
        uint TimeSlot = SelectedTimeSlotArtistMintPass[_CurrentCityIndex][ArtistID][TicketID];
        address Redeemer = BrightListArtist[_CurrentCityIndex][ArtistID][TicketID];
        BrightListArtist[_CurrentCityIndex][ArtistID][TicketID] = address(0);
        SelectedTimeSlotArtistMintPass[_CurrentCityIndex][ArtistID][TicketID] = 0;
        DelegateStatusArtist[_CurrentCityIndex][ArtistID][TicketID] = false;
        emit ReservationWipedArtist(ArtistID, TicketID, Redeemer, TimeSlot);
    }

    /**
     * @dev Modifies ArtBlocks Minting Address Citizens
     */
    function __ChangeArtBlocksMintingAddress(address NewMintingAddress) external onlyOwner
    {
        address OldMintingAddress = _ArtBlocksMintingContractCitizens;
        _ArtBlocksMintingContractCitizens = NewMintingAddress;
        emit ArtBlocksMintingAddressChanged(OldMintingAddress, _ArtBlocksMintingContractCitizens);
    }

    /**
     * @dev Modifies ArtBlocks Minting Address Artists
     */
    function __ChangeArtBlocksMintingAddressArtists(address NewMintingAddress) external onlyOwner
    {
        address OldMintingAddress = _ArtBlocksMintingContractArtists;
        _ArtBlocksMintingContractArtists = NewMintingAddress;
        emit ArtBlocksMintingAddressChanged(OldMintingAddress, _ArtBlocksMintingContractArtists);
    }

    /**
     * @dev Modifies ArtBlocks Core Address Citizens
     */
    function __ChangeArtBlocksCoreAddress(address NewMintingAddress) external onlyOwner
    {
        address OldMintingAddress = _ArtBlocksCoreContractCitizens;
        _ArtBlocksCoreContractCitizens = NewMintingAddress;
        emit ArtBlocksCoreAddressChanged(OldMintingAddress, _ArtBlocksCoreContractCitizens);
    }

    /**
     * @dev Modifies ArtBlocks Core Address Artists
     */
    function __ChangeArtBlocksCoreAddressArtist(address NewMintingAddress) external onlyOwner
    {
        address OldMintingAddress = _ArtBlocksCoreContractArtists;
        _ArtBlocksCoreContractArtists = NewMintingAddress;
        emit ArtBlocksCoreAddressChangedArtist(OldMintingAddress, _ArtBlocksCoreContractArtists);
    }

    /**
     * @dev Modifies Artist Contract Addresses
     */
    function __ChangeArtistContractAddresses(uint[] calldata ArtistIDs, address[] calldata NewContractAddresses) external onlyOwner
    {
        require(ArtistIDs.length == NewContractAddresses.length, "Arrays Must Be Of Equal Length");
        for(uint ArtistID; ArtistID < ArtistIDs.length; ArtistID++)
        {
            address OldArtistContractAddress = resolveArtistContract(ArtistIDs[ArtistID]);
            ArtistContracts[_CurrentCityIndex][ArtistIDs[ArtistID]] = NewContractAddresses[ArtistID];
            emit ArtistContractAddressChanged(OldArtistContractAddress, NewContractAddresses[ArtistID]);
        }
    }

    /**
     * @dev Changes Artist Mint Passes
     */
    function __ChangeArtistMintPasses(uint[] calldata ArtistIDs, address[] calldata NewContractAddresses) external onlyOwner
    {
        require(ArtistIDs.length == NewContractAddresses.length, "Arrays Must Be Of Equal Length");
        for(uint x; x < ArtistIDs.length; x++)
        {
            address OldArtistContractAddress = ArtistMintPasses[_CurrentCityIndex][ArtistIDs[x]];
            ArtistMintPasses[_CurrentCityIndex][ArtistIDs[x]] = NewContractAddresses[x];
            emit ArtistContractAddressChanged(OldArtistContractAddress, NewContractAddresses[x]);
        }
    }

    /**
     * @dev Modifies Artist Mint Types
     * note: True For ArtBlocks | False For Random Edition
     */
    function __ChangeArtistMintTypes(uint[] calldata ArtistIDs, bool[] calldata NewMintTypes) external onlyOwner
    {
        for(uint x; x < ArtistIDs.length; x++)
        {
            bool OldMintType = resolveArtistMint(ArtistIDs[x]);
            MintType[_CurrentCityIndex][ArtistIDs[x]] = NewMintTypes[x];
            emit ArtistMintTypeChanged(OldMintType, NewMintTypes[x]);
        }
    }

    /**
     * @dev Modifies The Current ArtBlocks ProjectID
     **/
    function __ChangeArtBlocksProjectID(uint ArtBlocksProjectID) external onlyOwner 
    { 
        uint OldProjectID = _ArtBlocksProjectID;
        _ArtBlocksProjectID = ArtBlocksProjectID; 
        emit ModifiedProjectID(OldProjectID, _ArtBlocksProjectID);
    }

    /**
     * @dev Modifies Golden Token Address
     */
    function __ChangeGoldenTokenAddress(address NewGTAddress) external onlyOwner
    {
        address OldAddress = _GoldenToken;
        _GoldenToken = NewGTAddress;
        emit GoldenTokenAddressChanged(OldAddress, _GoldenToken);
    }

    /**
     * @dev Modifies ERC20 BRT Minting Token Address
     */
    function __ChangeERC20Address(address NewERC20Address) external onlyOwner
    {
        address OldAddress = _ERC20_BRT_Token;
        _ERC20_BRT_Token = NewERC20Address;
        emit ERC20AddressChanged(OldAddress, _ERC20_BRT_Token);
    }

    /**
     * @dev Modifies Current City Index
     */
    function __ChangeCityIndex(uint Index) external onlyOwner
    {
        uint OldIndex = _CurrentCityIndex;
        _CurrentCityIndex = Index;
        emit CurrentCityIndexChanged(OldIndex, _CurrentCityIndex);
    }

    /**
     * @dev Overwrites QR Allocation
     */
    function __OverwriteQRAllocations(address[] calldata Addresses, uint[] calldata Amounts) external onlyOwner
    {
        require(Addresses.length == Amounts.length, "LiveMint: Input Arrays Must Match");
        for(uint x; x < Addresses.length; x++)
        {
            QRAllocation[_CurrentCityIndex][Addresses[x]] = Amounts[x];
        }
        emit QRAllocationsOverwritten(Addresses, Amounts);
    }

    /**
     * @dev Increments QR Allocations
     */
    function __IncrementQRAllocations(address[] calldata Addresses, uint[] calldata Amounts) external onlyOwner
    {
        require(Addresses.length == Amounts.length, "LiveMint: Input Arrays Must Match");
        for(uint x; x < Addresses.length; x++)
        {
            QRAllocation[_CurrentCityIndex][Addresses[x]] += Amounts[x];
        }
        emit QRAllocationsIncremented(Addresses, Amounts);
    }

    /**
     * @dev Sets QR Index
     */
    function __ChangeQRIndex(uint NewIndex) external onlyOwner { _QRIndex = NewIndex; }

    /**
     * @dev Batch Changes State Variables For LiveMint
     * note: __ApproveBRT(_ERC20_BRT_Token) Will Need To Be Called On This Contract After This Function
     * note: This Is So That Variables Can Be Double Checked & Mint Will Not Be Active Until That Is Complete
     */
    function __NewCity(
        address ERC20TokenAddress,
        address GoldenTokenAddress,
        uint ArtBlocksProjectID,
        uint CurrentCityIndex,
        uint QRIndex
    ) external onlyOwner {
        _ERC20_BRT_Token = ERC20TokenAddress;
        _GoldenToken = GoldenTokenAddress;
        _ArtBlocksProjectID = ArtBlocksProjectID;
        _CurrentCityIndex = CurrentCityIndex;
        _QRIndex = QRIndex;
        emit NewCityStarted(
            _ERC20_BRT_Token,
            _GoldenToken, 
            _ArtBlocksProjectID, 
            _CurrentCityIndex,
            _QRIndex
        );
    }

    /**
     * @dev Instantiates New Artists At `CurrentCityIndex` => `ArtistID[i]`
     * @dev note: ArtistIDs = uint[]
     * @dev note: MintPasses = address[] (this is the MintPass contract addresses)
     * @dev note: MintingAddresses = address[] (this is the NFTs to be Minted)
     * @dev note: MintTypes = bool[] (true for ArtBlocks) | (false for Random Edition)
     */
    function __NewArtists(
        uint[] calldata ArtistIDs, 
        address[] calldata MintPasses, 
        address[] calldata MintingAddresses,
        bool[] calldata MintTypes
    ) external onlyOwner {
        require(
            ArtistIDs.length == MintPasses.length 
            && 
            MintPasses.length == MintingAddresses.length 
            && 
            MintingAddresses.length == MintTypes.length, 
            "LiveMint: Array Lengths Must Be Of Equal Value"
        );
        for(uint i; i < ArtistIDs.length; i++)
        {
            ArtistMintPasses[_CurrentCityIndex][ArtistIDs[i]] = MintPasses[i];
            ArtistContracts[_CurrentCityIndex][ArtistIDs[i]] = MintingAddresses[i];
            MintType[_CurrentCityIndex][ArtistIDs[i]] = MintTypes[i];
        }
        emit NewArtists(ArtistIDs, MintPasses, MintingAddresses, MintTypes);
    }

    /**
     * @dev Changes Merkle Root
     */
    function __NewRoot(bytes32 NewRoot) external onlyOwner
    {
        bytes32 OldRoot = Root;
        Root = NewRoot;
        emit MerkleRootChanged(OldRoot, NewRoot);
    }

    /**
     * @dev Withdraws Any Ether Mistakenly Sent to Contract to Multisig
     **/
    function __WithdrawEther() external onlyOwner { payable(msg.sender).transfer(address(this).balance); }

    /**
     * @dev Withdraws ERC20 Tokens to Multisig
     **/
    function __WithdrawERC20(address TokenAddress) external onlyOwner 
    { 
        IERC20 erc20Token = IERC20(TokenAddress);
        uint balance = erc20Token.balanceOf(address(this));
        require(balance > 0, "0 ERC20 Balance At `TokenAddress`");
        erc20Token.transfer(msg.sender, balance);
    }

    /**
     * @dev Withdraws Any NFT Mistakenly Sent To This Contract.
     */
    function __WithdrawERC721(address ContractAddress, address Recipient, uint TokenID) external onlyOwner
    {
        IERC721(ContractAddress).transferFrom(address(this), Recipient, TokenID);
    }
    
    /*-------------------*/
    /*    PUBLIC VIEW    */
    /*-------------------*/

    /**
     * @dev Returns BrightListed Address Corresponding to Golden Ticket `TicketID`
     **/
    function readBrightListCitizen(uint TicketID) public view returns(address)
    { 
        return BrightListCitizen[_CurrentCityIndex][TicketID]; 
    }

    /**
     * @dev Returns BrightListed Address Corresponding to Mint Pass `ArtistID` & `TicketID`
     */
    function readBrightListArtist(uint ArtistID, uint TicketID) public view returns(address) 
    { 
        return BrightListArtist[_CurrentCityIndex][ArtistID][TicketID]; 
    }

    /**
     * @dev Returns Artist NFT Contract Address Correpsonding To ArtistID (1 through 10)
     */
    function resolveArtistContract(uint ArtistID) public view returns(address) 
    { 
        return ArtistContracts[_CurrentCityIndex][ArtistID]; 
    }

    /**
     * @dev Batch Returns Owned Artist Mint Passes
     */
    function resolveArtistMintPasses(uint[] calldata ArtistIDs) public view returns(address[] memory)
    {
        address[] memory MintPasses = new address[](ArtistIDs.length);
        for(uint i; i < ArtistIDs.length; i++)
        {
            address x = ArtistMintPasses[_CurrentCityIndex][ArtistIDs[i]];
            MintPasses[i] = x;
        }
        return MintPasses;
    }

    /**
     * @dev Returns Artist ArtBlocks Mint Type (true for ArtBlocks Mint) | (false for Random Edition Mint)
     */
    function resolveArtistMint(uint ArtistID) public view returns(bool) 
    { 
        return MintType[_CurrentCityIndex][ArtistID]; 
    }

    /**
     * @dev Returns Booked TimeSlot For Golden Ticket Corresponding `TicketID`
     */
    function readBookedTimeSlotGoldenTicket(uint TicketID) public view returns(uint) 
    { 
        return SelectedTimeSlotGoldenTicket[_CurrentCityIndex][TicketID]; 
    }

    /**
     * @dev Returns Booked TimeSlot For Artist Mint Pass Corresponding To `TicketID`
     */
    function readBookedTimeSlotArtistMintPass(uint ArtistID, uint TicketID) public view returns(uint) 
    { 
        return SelectedTimeSlotArtistMintPass[_CurrentCityIndex][ArtistID][TicketID]; 
    }

    /**
     * @dev Returns If User Is Eligible To Redeem QR Code
     */
    function readQREligibility(address Recipient, bytes32[] memory Proof) public view returns(bool)
    {
        bytes32 Leaf = keccak256(abi.encodePacked(Recipient));
        bool BrightListEligible = MerkleProof.verify(Proof, Root, Leaf);
        if(
            (BrightListEligible && !RedeemedQR[_CurrentCityIndex][Recipient])
            || 
            (BrightListEligible && QRAllocation[_CurrentCityIndex][Recipient] > 0)
        ) { return true; }
        else { return false; }
    }

    /**
     * @dev Returns Booked TimeSlots For Golden Tokens
     */
    function readCheckedInTimeSlotsGoldenTokens(uint Range) public view returns(uint[] memory)
    {
        uint[] memory TimeSlotsBooked = new uint[](Range);
        for(uint x; x < Range; x++)
        {
            TimeSlotsBooked[x] = SelectedTimeSlotGoldenTicket[_CurrentCityIndex][x];
        }
        return TimeSlotsBooked;
    }

    /**
     * @dev Returns Booked TimeSlots For Artist Mint Passes
     */
    function readTimeSlotsBookedArtists(uint[] calldata ArtistIDs, uint[] calldata Ranges) public view returns(uint[][] memory) 
    {
        uint[][] memory TimeSlotsBooked = new uint[][](ArtistIDs.length);
        for(uint x; x < ArtistIDs.length; x++)
        {
            for(uint y; y < Ranges[x]; y++)
            {
                TimeSlotsBooked[x][y] = SelectedTimeSlotArtistMintPass[_CurrentCityIndex][ArtistIDs[x]][y];
            }
        }
        return TimeSlotsBooked;
    }

    /**
     * @dev Returns An Array Of Unminted Golden Tokens
     */
    function readUnmintedGoldenTokens() public view returns(uint[] memory)
    {
        uint[] memory UnmintedTokenIDs = new uint[](1000);
        uint Counter;
        for(uint TokenID; TokenID < 1000; TokenID++)
        {
            if(
                !MintedCitizen[_CurrentCityIndex][TokenID]
                &&
                BrightListCitizen[_CurrentCityIndex][TokenID] != address(0)
            ) 
            { 
                UnmintedTokenIDs[Counter] = TokenID; 
                Counter++;
            }
        }
        uint[] memory FormattedUnMintedTokenIDs = new uint[](Counter);
        uint Found;
        for(uint FormattedTokenID; FormattedTokenID < Counter; FormattedTokenID++)
        {
            if(UnmintedTokenIDs[FormattedTokenID] != 0 || (UnmintedTokenIDs[FormattedTokenID] == 0 && FormattedTokenID == 0))
            {
                FormattedUnMintedTokenIDs[Found] = UnmintedTokenIDs[FormattedTokenID];
                Found++;
            }
        }
        return FormattedUnMintedTokenIDs;
    }

    /**
     * @dev Returns A 2d Array Of Minted ArtistIDs
     */
    function readUnmintedArtistIDs(uint[] calldata ArtistIDs, uint Range) public view returns(uint[][] memory)
    {
        uint[][] memory Unminted = new uint[][](ArtistIDs.length);
        uint Index;
        for(uint ArtistID; ArtistID < ArtistIDs.length; ArtistID++)
        {
            uint[] memory UnmintedArtistTokenIDs = new uint[](Range);
            uint Counter;
            for(uint TokenID; TokenID < Range; TokenID++)
            {
                if(
                    !MintedArtist[_CurrentCityIndex][ArtistID][TokenID]
                    &&
                    BrightListArtist[_CurrentCityIndex][ArtistIDs[ArtistID]][TokenID] != address(0)
                ) 
                { 
                    UnmintedArtistTokenIDs[Counter] = TokenID; 
                    Counter++;
                }
            }
            uint[] memory FormattedUnMintedArtistIDs = new uint[](Counter);
            uint Found;
            for(uint x; x < Counter; x++)
            {
                if(UnmintedArtistTokenIDs[x] != 0 || (UnmintedArtistTokenIDs[x] == 0 && x == 0))
                {
                    FormattedUnMintedArtistIDs[Found] = UnmintedArtistTokenIDs[x];
                    Found++;
                }
            }
            Unminted[Index] = FormattedUnMintedArtistIDs;
            Index++;
        }
        return Unminted;
    }

    /*------------------*/
    /*     MODIFIERS    */
    /*------------------*/

    /**
     * @dev Function Modifier That Allows Only BrightListed BRT Minters To Access
     **/
    modifier onlyMinter() 
    {
        require(Role[msg.sender] == _MINTER_ROLE, "OnlyMinter: Caller Is Not Approved BRT Minter");
        _;
    }
}

// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v4.7.0) (utils/cryptography/MerkleProof.sol)

pragma solidity ^0.8.0;

/**
 * @dev These functions deal with verification of Merkle Tree proofs.
 *
 * The proofs can be generated using the JavaScript library
 * https://github.com/miguelmota/merkletreejs[merkletreejs].
 * Note: the hashing algorithm should be keccak256 and pair sorting should be enabled.
 *
 * See `test/utils/cryptography/MerkleProof.test.js` for some examples.
 *
 * WARNING: You should avoid using leaf values that are 64 bytes long prior to
 * hashing, or use a hash function other than keccak256 for hashing leaves.
 * This is because the concatenation of a sorted pair of internal nodes in
 * the merkle tree could be reinterpreted as a leaf value.
 */
library MerkleProof {
    /**
     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree
     * defined by `root`. For this, a `proof` must be provided, containing
     * sibling hashes on the branch from the leaf to the root of the tree. Each
     * pair of leaves and each pair of pre-images are assumed to be sorted.
     */
    function verify(
        bytes32[] memory proof,
        bytes32 root,
        bytes32 leaf
    ) internal pure returns (bool) {
        return processProof(proof, leaf) == root;
    }

    /**
     * @dev Calldata version of {verify}
     *
     * _Available since v4.7._
     */
    function verifyCalldata(
        bytes32[] calldata proof,
        bytes32 root,
        bytes32 leaf
    ) internal pure returns (bool) {
        return processProofCalldata(proof, leaf) == root;
    }

    /**
     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up
     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt
     * hash matches the root of the tree. When processing the proof, the pairs
     * of leafs & pre-images are assumed to be sorted.
     *
     * _Available since v4.4._
     */
    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {
        bytes32 computedHash = leaf;
        for (uint256 i = 0; i < proof.length; i++) {
            computedHash = _hashPair(computedHash, proof[i]);
        }
        return computedHash;
    }

    /**
     * @dev Calldata version of {processProof}
     *
     * _Available since v4.7._
     */
    function processProofCalldata(bytes32[] calldata proof, bytes32 leaf) internal pure returns (bytes32) {
        bytes32 computedHash = leaf;
        for (uint256 i = 0; i < proof.length; i++) {
            computedHash = _hashPair(computedHash, proof[i]);
        }
        return computedHash;
    }

    /**
     * @dev Returns true if the `leaves` can be proved to be a part of a Merkle tree defined by
     * `root`, according to `proof` and `proofFlags` as described in {processMultiProof}.
     *
     * _Available since v4.7._
     */
    function multiProofVerify(
        bytes32[] memory proof,
        bool[] memory proofFlags,
        bytes32 root,
        bytes32[] memory leaves
    ) internal pure returns (bool) {
        return processMultiProof(proof, proofFlags, leaves) == root;
    }

    /**
     * @dev Calldata version of {multiProofVerify}
     *
     * _Available since v4.7._
     */
    function multiProofVerifyCalldata(
        bytes32[] calldata proof,
        bool[] calldata proofFlags,
        bytes32 root,
        bytes32[] memory leaves
    ) internal pure returns (bool) {
        return processMultiProofCalldata(proof, proofFlags, leaves) == root;
    }

    /**
     * @dev Returns the root of a tree reconstructed from `leaves` and the sibling nodes in `proof`,
     * consuming from one or the other at each step according to the instructions given by
     * `proofFlags`.
     *
     * _Available since v4.7._
     */
    function processMultiProof(
        bytes32[] memory proof,
        bool[] memory proofFlags,
        bytes32[] memory leaves
    ) internal pure returns (bytes32 merkleRoot) {
        // This function rebuild the root hash by traversing the tree up from the leaves. The root is rebuilt by
        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the
        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of
        // the merkle tree.
        uint256 leavesLen = leaves.length;
        uint256 totalHashes = proofFlags.length;

        // Check proof validity.
        require(leavesLen + proof.length - 1 == totalHashes, "MerkleProof: invalid multiproof");

        // The xxxPos values are "pointers" to the next value to consume in each array. All accesses are done using
        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's "pop".
        bytes32[] memory hashes = new bytes32[](totalHashes);
        uint256 leafPos = 0;
        uint256 hashPos = 0;
        uint256 proofPos = 0;
        // At each step, we compute the next hash using two values:
        // - a value from the "main queue". If not all leaves have been consumed, we get the next leaf, otherwise we
        //   get the next hash.
        // - depending on the flag, either another value for the "main queue" (merging branches) or an element from the
        //   `proof` array.
        for (uint256 i = 0; i < totalHashes; i++) {
            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];
            bytes32 b = proofFlags[i] ? leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++] : proof[proofPos++];
            hashes[i] = _hashPair(a, b);
        }

        if (totalHashes > 0) {
            return hashes[totalHashes - 1];
        } else if (leavesLen > 0) {
            return leaves[0];
        } else {
            return proof[0];
        }
    }

    /**
     * @dev Calldata version of {processMultiProof}
     *
     * _Available since v4.7._
     */
    function processMultiProofCalldata(
        bytes32[] calldata proof,
        bool[] calldata proofFlags,
        bytes32[] memory leaves
    ) internal pure returns (bytes32 merkleRoot) {
        // This function rebuild the root hash by traversing the tree up from the leaves. The root is rebuilt by
        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the
        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of
        // the merkle tree.
        uint256 leavesLen = leaves.length;
        uint256 totalHashes = proofFlags.length;

        // Check proof validity.
        require(leavesLen + proof.length - 1 == totalHashes, "MerkleProof: invalid multiproof");

        // The xxxPos values are "pointers" to the next value to consume in each array. All accesses are done using
        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's "pop".
        bytes32[] memory hashes = new bytes32[](totalHashes);
        uint256 leafPos = 0;
        uint256 hashPos = 0;
        uint256 proofPos = 0;
        // At each step, we compute the next hash using two values:
        // - a value from the "main queue". If not all leaves have been consumed, we get the next leaf, otherwise we
        //   get the next hash.
        // - depending on the flag, either another value for the "main queue" (merging branches) or an element from the
        //   `proof` array.
        for (uint256 i = 0; i < totalHashes; i++) {
            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];
            bytes32 b = proofFlags[i] ? leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++] : proof[proofPos++];
            hashes[i] = _hashPair(a, b);
        }

        if (totalHashes > 0) {
            return hashes[totalHashes - 1];
        } else if (leavesLen > 0) {
            return leaves[0];
        } else {
            return proof[0];
        }
    }

    function _hashPair(bytes32 a, bytes32 b) private pure returns (bytes32) {
        return a < b ? _efficientHash(a, b) : _efficientHash(b, a);
    }

    function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {
        /// @solidity memory-safe-assembly
        assembly {
            mstore(0x00, a)
            mstore(0x20, b)
            value := keccak256(0x00, 0x40)
        }
    }
}

//SPDX-License-Identifier: MIT
/**
 * @dev: @brougkr
 */
pragma solidity ^0.8.16;
abstract contract CTZNPlugin
{
    address public immutable CTZN = 0xb11BDEAf6249627B84B56A6Aff3Edb4eadd743fc;
    event RewardRatesChanged(uint[] RewardIndexes, uint[] RewardRates);
    mapping(uint=>uint) public _RewardRates;

    /**
     * @dev Modifies The Reward Rate Of A CTZN Enabled Contract
     */
    function ModifyRewardRates(uint[] calldata RewardIndexes, uint[] calldata RewardRates) external onlyCTZN
    {   
        require(RewardIndexes.length == RewardRates.length, "CTZNPlugin: Array Lengths Must Match");
        for(uint RewardIndex; RewardIndex < RewardIndexes.length; RewardIndex++)
        {
            _RewardRates[RewardIndexes[RewardIndex]] = RewardRates[RewardIndex];
        }
        emit RewardRatesChanged(RewardIndexes, RewardRates);
    }

    /**
     * @dev Modifier Ensuring `msg.sender` == `$CTZN Contract`
     */
    modifier onlyCTZN
    {
        require(msg.sender == CTZN, "Sender Is Not CTZN Contract");
        _;
    }
}

interface ICTZN { function IncrementCTZN(address Recipient, uint Amount) external; }

//SPDX-License-Identifier: MIT
/**
 * @dev: @brougkr
 */
pragma solidity 0.8.16;
interface IMPMX 
{ 
    function ViewArtistID(uint TokenID) external view returns(uint);
    function _LiveMintBurn(uint TokenID) external returns(address);
}

//SPDX-License-Identifier: MIT
pragma solidity 0.8.16;
import {ReentrancyGuard} from '@openzeppelin/contracts/security/ReentrancyGuard.sol';
import {IERC721} from '@openzeppelin/contracts/interfaces/IERC721.sol';
import {IMPMX} from './IMPMX.sol';
contract Swapper is ReentrancyGuard
{
    struct CitizenSwap
    {
        uint OfferedTokenID;
        uint RequestedTokenID;
        uint RequestedCollectionID;
        address OfferedAddress;
        address Initiator;
        bool AnyTokenID;
        bool Complete;
    }

    struct MintPassSwap
    {
        uint OfferedTokenID;
        uint OfferedArtistID;
        uint RequestedArtistID;
        address Initiator;
        bool Complete;
    }

    struct PrivateCitizenSwap
    {
        uint OfferedTokenID;
        uint RequestedTokenID;
        uint RequestedCollection;
        address Initiator;
        address Fulfiller;
        bool Complete;
    }

    struct PrivateMintPassSwap
    {
        uint OfferedTokenID;
        uint OfferedArtistID;
        uint RequestedArtistID;
        address Initiator;
        address Fulfiller;
        bool Complete;
    }

    mapping(uint=>MintPassSwap) public MintPassPublicSwaps;
    mapping(uint=>PrivateMintPassSwap) public MintPassPrivateSwaps;
    mapping(address=>uint[]) public AddressInitiatedMintPassSwaps;
    mapping(address=>uint[]) public AddressInitiatedMintPassPrivateSwaps;

    mapping(uint=>CitizenSwap) public CitizenSwaps;
    mapping(uint=>PrivateCitizenSwap) public PrivateCitizenSwaps;
    mapping(address=>uint[]) public AddressInitiatedCitizenSwaps;
    mapping(address=>uint[]) public AddressInitiatedCitizenPrivateSwaps;

    event SwapComplete(uint PublicIndex); 
    event PrivateSwapComplete(uint PrivateIndex);

    uint public NumSwaps;
    uint public NumCitizenSwaps;
    uint public NumPrivateCitizenSwaps;
    uint public NumMintPassPrivateSwaps;
    uint public NumMintPassSwaps;
    address MintPass = address(0);

    /**
     * @dev Requests Public Mint Pass Swap
     */
    function RequestPublicMintPassSwap(
        uint OfferedTokenID, 
        uint RequestedArtistID
    ) external nonReentrant {
        require(
            IERC721(MintPass).ownerOf(OfferedTokenID)
            ==
            msg.sender,
            "Initiator Does Not Own OfferedTokenID"
        );
        MintPassPublicSwaps[NumMintPassSwaps] = MintPassSwap(
            OfferedTokenID, 
            IMPMX(MintPass).ViewArtistID(OfferedTokenID),
            RequestedArtistID, 
            msg.sender, 
            false
        );
        AddressInitiatedCitizenSwaps[msg.sender].push(NumMintPassSwaps);
        NumMintPassSwaps++;
    }

    /**
     * @dev Requests Private Swap
     */
    function RequestPrivateMintPassSwap(
        uint OfferedTokenID, 
        uint RequestedArtistID, 
        address Fulfiller
    ) external nonReentrant {
        require(msg.sender == IERC721(MintPass).ownerOf(OfferedTokenID), "`msg.sender` Does Not Own TokenID");
        MintPassPrivateSwaps[NumMintPassPrivateSwaps] = PrivateMintPassSwap(
            OfferedTokenID,                               // OfferedTokenID
            IMPMX(MintPass).ViewArtistID(OfferedTokenID), // Offered ArtistID
            RequestedArtistID,                            // Requested ArtistID
            msg.sender,                                   // Initiator
            Fulfiller,                                    // Private Fulfiller
            false                                         // IsComplete
        );
        AddressInitiatedMintPassPrivateSwaps[msg.sender].push(NumMintPassPrivateSwaps);
        NumMintPassPrivateSwaps++;
    }

    /**
     * @dev Requests A Public Citizen Swap
     * note: CollectionID Corresponds To The City #
     * note: 0 = Galactican
     * note: 1 = Venetian
     * note: 2 = NewYorker
     * etc...
     */
    function RequestPublicCitizenSwap(
        uint OfferedTokenID,
        uint RequestedTokenID,
        uint RequestedCollectionID,
        bool AnyTokenID
    ) external nonReentrant {
        address Collection = DeriveCollection(OfferedTokenID);
        require(
            IERC721(Collection).ownerOf(OfferedTokenID)
            ==
            msg.sender,
            "Initiator Does Not Own OfferedTokenID"
        );
        CitizenSwaps[NumCitizenSwaps] = CitizenSwap(
            OfferedTokenID, 
            RequestedTokenID,
            RequestedCollectionID, 
            DeriveCollection(OfferedTokenID),
            msg.sender, 
            AnyTokenID,
            false
        );
        AddressInitiatedCitizenSwaps[msg.sender].push(NumCitizenSwaps);
        NumCitizenSwaps++;
    }

    /**
     * @dev Executes Swap
     */
    function ExecutePublicSwapMintPass(uint Index, uint TokenID) external nonReentrant
    {
        require(!MintPassPublicSwaps[Index].Complete, "Swap Already Complete");
        require(msg.sender != MintPassPublicSwaps[Index].Initiator, "Message Sender Is Initiator");
        require(MintPassPublicSwaps[Index].RequestedArtistID == IMPMX(MintPass).ViewArtistID(TokenID), "Incorrect ArtistID");
        require(
            IERC721(MintPass).ownerOf(MintPassPublicSwaps[Index].OfferedTokenID) 
            == 
            MintPassPublicSwaps[Index].Initiator,
            "Swapper: Initiator Does Not Own Base OfferedTokenID"
        );
        require(
            IERC721(MintPass).ownerOf(TokenID) 
            == 
            msg.sender,
            "Swapper: Fulfiller Does Not Own TokenID"
        );
        IERC721(MintPass).transferFrom(
            msg.sender,
            MintPassPublicSwaps[Index].Initiator, 
            TokenID
        );
        IERC721(MintPass).transferFrom(
            MintPassPublicSwaps[Index].Initiator, 
            msg.sender, 
            MintPassPublicSwaps[Index].OfferedTokenID
        );
        require(
            IERC721(MintPass).ownerOf(TokenID) == MintPassPublicSwaps[Index].Initiator, 
            "Swapper: Initiator Does Not Own Swapped TokenID"
        );
        require(
            IERC721(MintPass).ownerOf(MintPassPublicSwaps[Index].OfferedTokenID) == msg.sender, 
            "Swapper: Fulfiller Does Not Own Base OfferedTokenID"
        );
        MintPassPublicSwaps[Index].Complete = true;
        emit PrivateSwapComplete(Index);
    }

    /**
     * @dev Executes Swap
     */
    function ExecutePrivateSwapMintPass(uint Index, uint TokenID) external nonReentrant
    {
        require(!MintPassPrivateSwaps[Index].Complete, "Swap Already Complete");
        require(msg.sender == MintPassPrivateSwaps[Index].Fulfiller, "Message Sender Is Not Fulfiller");
        require(MintPassPrivateSwaps[Index].RequestedArtistID == IMPMX(MintPass).ViewArtistID(TokenID), "Incorrect ArtistID");
        require(
            IERC721(MintPass).ownerOf(MintPassPrivateSwaps[Index].OfferedTokenID) 
            == 
            MintPassPrivateSwaps[Index].Initiator,
            "Swapper: Initiator Does Not Own Base OfferedTokenID"
        );
        require(
            IERC721(MintPass).ownerOf(TokenID) 
            == 
            MintPassPrivateSwaps[Index].Fulfiller, 
            "Swapper: Fulfiller Does Not Own Requested OfferedTokenID"
        );
        IERC721(MintPass).transferFrom(
            MintPassPrivateSwaps[Index].Fulfiller, 
            MintPassPrivateSwaps[Index].Initiator, 
            TokenID
        );
        IERC721(MintPass).transferFrom(
            MintPassPrivateSwaps[Index].Initiator, 
            MintPassPrivateSwaps[Index].Fulfiller, 
            MintPassPrivateSwaps[Index].OfferedTokenID
        );
        require(
            IERC721(MintPass).ownerOf(TokenID) == MintPassPrivateSwaps[Index].Initiator, 
            "Swapper: Initiator Does Not Own Requested OfferedTokenID"
        );
        require(
            IERC721(MintPass).ownerOf(MintPassPrivateSwaps[Index].OfferedTokenID) == MintPassPrivateSwaps[Index].Fulfiller, 
            "Swapper: Fulfiller Does Not Own Base OfferedTokenID"
        );
        MintPassPrivateSwaps[Index].Complete = true;
        emit PrivateSwapComplete(Index);
    }

    /**
     * @dev Returns Address Of Collection
     */
    function DeriveCollection(uint TokenID) public view returns(address)
    {
        
    }

    /**
     * @dev Returns Active Swap Indexes
     */
    function ViewActivePublicMintPassSwapIndexes(
        uint StartingIndex, 
        uint EndingIndex
    ) public view returns(uint[] memory) {
        uint[] memory ActiveIndexes = new uint[](EndingIndex-StartingIndex);
        uint Counter;
        for(uint x = StartingIndex; x <= EndingIndex; x++)
        {
            if(!MintPassPublicSwaps[x].Complete) { ActiveIndexes[Counter] = x; }
            Counter++;
        }
        uint[] memory FormattedActiveIndexes = new uint[](Counter);
        for(uint y; y < Counter; y++)
        {
            FormattedActiveIndexes[y] = ActiveIndexes[y];
        }
        return FormattedActiveIndexes;
    }

    /**
     * @dev Returns Active Swap Indexes
     */
    function ViewActivePrivateMintPassSwapIndexes(
        uint StartingIndex, 
        uint EndingIndex
    ) public view returns(uint[] memory) {
        uint[] memory ActiveIndexes = new uint[](EndingIndex-StartingIndex);
        uint Counter;
        for(uint x = StartingIndex; x <= EndingIndex; x++)
        {
            if(!MintPassPrivateSwaps[x].Complete) { ActiveIndexes[Counter] = x; }
            Counter++;
        }
        uint[] memory FormattedActiveIndexes = new uint[](Counter);
        for(uint y; y < Counter; y++)
        {
            FormattedActiveIndexes[y] = ActiveIndexes[y];
        }
        return FormattedActiveIndexes;
    }

    /**
     * @dev Returns Tuple Of Wallet Initiated Swaps
     */
    function ViewWalletInitiatedSwaps(address Wallet) public view returns(
        uint[] memory, // Public Mint Pass Swaps
        uint[] memory, // Private Mint Pass Swaps
        uint[] memory, // Public Citizen Swaps
        uint[] memory  // Private Citizen Swaps
    ) {
        return(
            AddressInitiatedMintPassSwaps[Wallet],
            AddressInitiatedMintPassPrivateSwaps[Wallet],
            AddressInitiatedCitizenSwaps[Wallet],
            AddressInitiatedCitizenPrivateSwaps[Wallet]
        );
    }
}

// SPDX-License-Identifier: MIT-BROUGKR
/*@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                     @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@          @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                 @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@              @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@              @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                 @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                     @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@*/
/**
 * @dev: @brougkr
 */
pragma solidity 0.8.16;
import {ERC20} from "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import {IERC721} from "@openzeppelin/contracts/interfaces/IERC721.sol";
import {ReentrancyGuard} from "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import {Ownable} from "@openzeppelin/contracts/access/Ownable.sol";
import {IBRT} from "./IBRT.sol";
contract CTZN is ERC20, ReentrancyGuard, Ownable
{
    event ContractsActiveStateChanged(address[] ContractAddresses, bool[] Values);
    event OwnerChanged(address OldOwner, address NewOwner);
    event ContractAddressesChanged(uint[] ProjectIDs, address[] ContractAddresses);
    event ContractNamesChanged(uint[] ProjectIDs, string[] Names);
    event CitizensDelegated(uint[][] TokenIDs, address Redeemer);
    event RewardRatesChanged(uint ProjectID, uint[] RewardIndexes, uint[] RewardRates);
    event RewardsDistributed(address Recipient, uint Amount);
    event ContractInstancesChanged(uint[] ProjectIDs, address[] ContractAddresses, string[] Names, bool[] ActiveStates);

    mapping(uint => BRTContract) public BRTContracts;
    mapping(uint => CitizenContract) public CitizenContracts;
    mapping(uint => address) public CitizenDelegation;
    mapping(address => bytes32) public Role;
    mapping(address => bool) public BRTContractActive;
    mapping(address => uint) public AddressDelegatedCitizens;

    /**
     * @dev Activated BRT Smart Contract
     */
    struct BRTContract
    {
        string Name;                // [0] - Name
        address ContractAddress;    // [1] - ContractAddress
    }

    /**
     * @dev CryptoCitizens
     */
    struct CitizenContract
    {
        string Name;                // [0] - Name
        uint StartingIndex;         // [1] - Starting TokenID
        uint EndingIndex;           // [2] - Ending TokenID
        uint FirstBlockTimestamp;   // [3] - First Block Timestamp
        address ContractAddress;    // [4] - ContractAddress
        bool Active;                // [5] - Active
    }

    constructor() ERC20("CTZN", "CTZN") 
    {
        BRTContracts[0] = BRTContract('CryptoCitizenLiveMint', address(0));
        BRTContracts[1] = BRTContract('Marketplace', address(0));
        BRTContracts[2] = BRTContract('BrightBundles', address(0));
        BRTContracts[3] = BRTContract('IRL', address(0));
        CitizenContracts[0] = CitizenContract('CryptoGalacticans', 0, 999, 31659986, 0xbDdE08BD57e5C9fD563eE7aC61618CB2ECdc0ce0, true);
        CitizenContracts[1] = CitizenContract('CryptoVenetians', 95000000, 95000999, 31657986, 0xa7d8d9ef8D8Ce8992Df33D8b8CF4Aebabd5bD270, true);
        CitizenContracts[2] = CitizenContract('CryptoNewYorkers', 189000000, 189000999, 31688986, 0xa7d8d9ef8D8Ce8992Df33D8b8CF4Aebabd5bD270, true);
        CitizenContracts[3] = CitizenContract('CryptoBerliners', 3000000, 3000999, 31656986, 0xbDdE08BD57e5C9fD563eE7aC61618CB2ECdc0ce0, true);
        CitizenContracts[4] = CitizenContract('CryptoLondoner', 4000000, 4000999, 31656986, 0xbDdE08BD57e5C9fD563eE7aC61618CB2ECdc0ce0, true);
        CitizenContracts[5] = CitizenContract('CryptoMexicas', 5000000, 5000999, 31656986, 0xbDdE08BD57e5C9fD563eE7aC61618CB2ECdc0ce0, true);
        CitizenContracts[6] = CitizenContract('CryptoCitizen City #7', 6000000, 6000999, 0, 0xfcE8A5DA534fB7829a0880C76c9feDa48Abee02c, false);
        CitizenContracts[7] = CitizenContract('CryptoCitizen City #8', 7000000, 7000999, 0, 0xfcE8A5DA534fB7829a0880C76c9feDa48Abee02c, false);
        CitizenContracts[8] = CitizenContract('CryptoCitizen City #9', 8000000, 8000999, 0, 0xfcE8A5DA534fB7829a0880C76c9feDa48Abee02c, false);
        CitizenContracts[9] = CitizenContract('CryptoCitizen City #10', 9000000, 9000999, 0, 0xfcE8A5DA534fB7829a0880C76c9feDa48Abee02c, false);
    }

    /**
     * @dev Delegates Citizens For CTZN Multiplier
     */
    function DelegateCitizens(address Recipient, uint[][] calldata TokenIDs) public nonReentrant
    {
        for(uint CityIndex; CityIndex < TokenIDs.length; CityIndex++)
        {
            for(uint TokenID; TokenID < TokenIDs[CityIndex].length; TokenID++)
            {
                require(
                    TokenIDs[CityIndex][TokenID] >= CitizenContracts[CityIndex].StartingIndex 
                    && 
                    TokenIDs[CityIndex][TokenID] <= CitizenContracts[CityIndex].EndingIndex, 
                    "CTZN: Invalid TokenID For CityID"
                );
                require(
                    IERC721(CitizenContracts[CityIndex].ContractAddress).ownerOf(TokenIDs[CityIndex][TokenID])
                    == 
                    msg.sender,
                    "CTZN: User Does Not Own TokenID"
                );
                require(CitizenContracts[CityIndex].Active, "City Not Active Yet");
                if(CitizenDelegation[TokenIDs[CityIndex][TokenID]] != address(0))
                {
                    AddressDelegatedCitizens[CitizenDelegation[TokenIDs[CityIndex][TokenID]]]--;
                }
                AddressDelegatedCitizens[Recipient]++;
                CitizenDelegation[TokenIDs[CityIndex][TokenID]] = Recipient;
            }
        }
        emit CitizensDelegated(TokenIDs, Recipient);
    }

    /*-----------------*/
    /*  EXTERNAL CALL  */
    /*-----------------*/

    /**
     * @dev Mints $CTZN Rewards To User
     */
    function IncrementCTZN(address Recipient, uint Amount) external onlyBRTContract
    { 
        if(AddressDelegatedCitizens[Recipient] > 0)
        {
            uint NewAmount = (Amount * (AddressDelegatedCitizens[Recipient]));
            _mint(Recipient, NewAmount);
            emit RewardsDistributed(Recipient, NewAmount);                              
        }
        else
        {
            _mint(Recipient, Amount);
            emit RewardsDistributed(Recipient, Amount);                              
        }
    }

    /*---------------*/
    /*  PUBLIC VIEW  */
    /*---------------*/

    /**
     * @dev Returns Delegated Citizens
     */
    function ViewDelegatedCitizens(uint[][] calldata TokenIDs) public view returns(address[] memory)
    {
        address[] memory Delegates = new address[](TokenIDs.length);
        for(uint x; x < TokenIDs.length; x++)
        {
            for(uint y; y < TokenIDs[x].length; y++)
            {
                Delegates[x] = CitizenDelegation[TokenIDs[x][y]];
            }
        }
        return Delegates;
    }

    /*--------------*/
    /*  ONLY OWNER  */
    /*--------------*/

    /**
     * @dev Changes Contract Instances
     */
    function __ChangeContractInstances(
        uint[] calldata ProjectIDs, 
        address[] calldata ContractAddresses, 
        string[] calldata Names, 
        bool[] calldata ActiveStates
    ) external onlyOwner {
        for(uint x; x < ProjectIDs.length; x++)
        {
            if(BRTContracts[x].ContractAddress != address(0) && BRTContracts[x].ContractAddress != ContractAddresses[x])
            {
                BRTContractActive[BRTContracts[x].ContractAddress] = false;
            }
            BRTContracts[x].ContractAddress = ContractAddresses[x];
            BRTContracts[x].Name = Names[x];
            BRTContractActive[ContractAddresses[x]] = ActiveStates[x];
        }
        emit ContractInstancesChanged(ProjectIDs, ContractAddresses, Names, ActiveStates);
    }

    /**
     * @dev Changes Contract Instances Active State
     */
    function __ChangeContractInstanceActiveState(address[] calldata ContractAddresses, bool[] calldata Values) external onlyOwner
    {
        require(ContractAddresses.length == Values.length, "CTZN: Arrays Must Be Equal Length");
        for(uint x; x < ContractAddresses.length; x++)
        {
            BRTContractActive[ContractAddresses[x]] = Values[x];
        }
        emit ContractsActiveStateChanged(ContractAddresses, Values);
    }

    /**
     * @dev Changes Contract Instances
     */
    function __ChangeBRTContractAddresses(uint[] calldata ProjectIDs, address[] calldata ContractAddresses) external onlyOwner
    {
        require(ProjectIDs.length == ContractAddresses.length, "CTZN: Arrays Must Be Of Equal Length");
        for(uint x; x < ContractAddresses.length; x++)
        {
            BRTContracts[x].ContractAddress = ContractAddresses[x];
        }
        emit ContractAddressesChanged(ProjectIDs, ContractAddresses);
    }

    /**
     * @dev Changes BRT Contract Names
     */
    function __ChangeBRTContractNames(uint[] calldata ProjectIDs, string[] calldata Names) external onlyOwner
    {
        require(ProjectIDs.length == Names.length, "CTZN: Arrays Must Be Of Equal Length");
        for(uint x; x < ProjectIDs.length; x++)
        {
            BRTContracts[x].Name = Names[x];
        }
        emit ContractNamesChanged(ProjectIDs, Names);
    }

    /**
     * @dev Changes Reward Rates For Project
     */
    function __ChangeRewardRates(uint ProjectID, uint[] calldata RewardIndexes, uint[] calldata RewardRates) external onlyOwner
    {
        IBRT(BRTContracts[ProjectID].ContractAddress).ModifyRewardRates(RewardIndexes, RewardRates);
        emit RewardRatesChanged(ProjectID, RewardIndexes, RewardRates);
    }

    /*-------------*/
    /*  MODIFIERS  */
    /*-------------*/

    modifier onlyBRTContract
    {
        require(BRTContractActive[msg.sender], "CTZN: Sender Is Not Authorized BRT Contract");
        _;
    }
}

// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/ERC20.sol)

pragma solidity ^0.8.0;

import "./IERC20.sol";
import "./extensions/IERC20Metadata.sol";
import "../../utils/Context.sol";

/**
 * @dev Implementation of the {IERC20} interface.
 *
 * This implementation is agnostic to the way tokens are created. This means
 * that a supply mechanism has to be added in a derived contract using {_mint}.
 * For a generic mechanism see {ERC20PresetMinterPauser}.
 *
 * TIP: For a detailed writeup see our guide
 * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How
 * to implement supply mechanisms].
 *
 * We have followed general OpenZeppelin Contracts guidelines: functions revert
 * instead returning `false` on failure. This behavior is nonetheless
 * conventional and does not conflict with the expectations of ERC20
 * applications.
 *
 * Additionally, an {Approval} event is emitted on calls to {transferFrom}.
 * This allows applications to reconstruct the allowance for all accounts just
 * by listening to said events. Other implementations of the EIP may not emit
 * these events, as it isn't required by the specification.
 *
 * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}
 * functions have been added to mitigate the well-known issues around setting
 * allowances. See {IERC20-approve}.
 */
contract ERC20 is Context, IERC20, IERC20Metadata {
    mapping(address => uint256) private _balances;

    mapping(address => mapping(address => uint256)) private _allowances;

    uint256 private _totalSupply;

    string private _name;
    string private _symbol;

    /**
     * @dev Sets the values for {name} and {symbol}.
     *
     * The default value of {decimals} is 18. To select a different value for
     * {decimals} you should overload it.
     *
     * All two of these values are immutable: they can only be set once during
     * construction.
     */
    constructor(string memory name_, string memory symbol_) {
        _name = name_;
        _symbol = symbol_;
    }

    /**
     * @dev Returns the name of the token.
     */
    function name() public view virtual override returns (string memory) {
        return _name;
    }

    /**
     * @dev Returns the symbol of the token, usually a shorter version of the
     * name.
     */
    function symbol() public view virtual override returns (string memory) {
        return _symbol;
    }

    /**
     * @dev Returns the number of decimals used to get its user representation.
     * For example, if `decimals` equals `2`, a balance of `505` tokens should
     * be displayed to a user as `5.05` (`505 / 10 ** 2`).
     *
     * Tokens usually opt for a value of 18, imitating the relationship between
     * Ether and Wei. This is the value {ERC20} uses, unless this function is
     * overridden;
     *
     * NOTE: This information is only used for _display_ purposes: it in
     * no way affects any of the arithmetic of the contract, including
     * {IERC20-balanceOf} and {IERC20-transfer}.
     */
    function decimals() public view virtual override returns (uint8) {
        return 18;
    }

    /**
     * @dev See {IERC20-totalSupply}.
     */
    function totalSupply() public view virtual override returns (uint256) {
        return _totalSupply;
    }

    /**
     * @dev See {IERC20-balanceOf}.
     */
    function balanceOf(address account) public view virtual override returns (uint256) {
        return _balances[account];
    }

    /**
     * @dev See {IERC20-transfer}.
     *
     * Requirements:
     *
     * - `to` cannot be the zero address.
     * - the caller must have a balance of at least `amount`.
     */
    function transfer(address to, uint256 amount) public virtual override returns (bool) {
        address owner = _msgSender();
        _transfer(owner, to, amount);
        return true;
    }

    /**
     * @dev See {IERC20-allowance}.
     */
    function allowance(address owner, address spender) public view virtual override returns (uint256) {
        return _allowances[owner][spender];
    }

    /**
     * @dev See {IERC20-approve}.
     *
     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on
     * `transferFrom`. This is semantically equivalent to an infinite approval.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     */
    function approve(address spender, uint256 amount) public virtual override returns (bool) {
        address owner = _msgSender();
        _approve(owner, spender, amount);
        return true;
    }

    /**
     * @dev See {IERC20-transferFrom}.
     *
     * Emits an {Approval} event indicating the updated allowance. This is not
     * required by the EIP. See the note at the beginning of {ERC20}.
     *
     * NOTE: Does not update the allowance if the current allowance
     * is the maximum `uint256`.
     *
     * Requirements:
     *
     * - `from` and `to` cannot be the zero address.
     * - `from` must have a balance of at least `amount`.
     * - the caller must have allowance for ``from``'s tokens of at least
     * `amount`.
     */
    function transferFrom(
        address from,
        address to,
        uint256 amount
    ) public virtual override returns (bool) {
        address spender = _msgSender();
        _spendAllowance(from, spender, amount);
        _transfer(from, to, amount);
        return true;
    }

    /**
     * @dev Atomically increases the allowance granted to `spender` by the caller.
     *
     * This is an alternative to {approve} that can be used as a mitigation for
     * problems described in {IERC20-approve}.
     *
     * Emits an {Approval} event indicating the updated allowance.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     */
    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {
        address owner = _msgSender();
        _approve(owner, spender, allowance(owner, spender) + addedValue);
        return true;
    }

    /**
     * @dev Atomically decreases the allowance granted to `spender` by the caller.
     *
     * This is an alternative to {approve} that can be used as a mitigation for
     * problems described in {IERC20-approve}.
     *
     * Emits an {Approval} event indicating the updated allowance.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     * - `spender` must have allowance for the caller of at least
     * `subtractedValue`.
     */
    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {
        address owner = _msgSender();
        uint256 currentAllowance = allowance(owner, spender);
        require(currentAllowance >= subtractedValue, "ERC20: decreased allowance below zero");
        unchecked {
            _approve(owner, spender, currentAllowance - subtractedValue);
        }

        return true;
    }

    /**
     * @dev Moves `amount` of tokens from `from` to `to`.
     *
     * This internal function is equivalent to {transfer}, and can be used to
     * e.g. implement automatic token fees, slashing mechanisms, etc.
     *
     * Emits a {Transfer} event.
     *
     * Requirements:
     *
     * - `from` cannot be the zero address.
     * - `to` cannot be the zero address.
     * - `from` must have a balance of at least `amount`.
     */
    function _transfer(
        address from,
        address to,
        uint256 amount
    ) internal virtual {
        require(from != address(0), "ERC20: transfer from the zero address");
        require(to != address(0), "ERC20: transfer to the zero address");

        _beforeTokenTransfer(from, to, amount);

        uint256 fromBalance = _balances[from];
        require(fromBalance >= amount, "ERC20: transfer amount exceeds balance");
        unchecked {
            _balances[from] = fromBalance - amount;
        }
        _balances[to] += amount;

        emit Transfer(from, to, amount);

        _afterTokenTransfer(from, to, amount);
    }

    /** @dev Creates `amount` tokens and assigns them to `account`, increasing
     * the total supply.
     *
     * Emits a {Transfer} event with `from` set to the zero address.
     *
     * Requirements:
     *
     * - `account` cannot be the zero address.
     */
    function _mint(address account, uint256 amount) internal virtual {
        require(account != address(0), "ERC20: mint to the zero address");

        _beforeTokenTransfer(address(0), account, amount);

        _totalSupply += amount;
        _balances[account] += amount;
        emit Transfer(address(0), account, amount);

        _afterTokenTransfer(address(0), account, amount);
    }

    /**
     * @dev Destroys `amount` tokens from `account`, reducing the
     * total supply.
     *
     * Emits a {Transfer} event with `to` set to the zero address.
     *
     * Requirements:
     *
     * - `account` cannot be the zero address.
     * - `account` must have at least `amount` tokens.
     */
    function _burn(address account, uint256 amount) internal virtual {
        require(account != address(0), "ERC20: burn from the zero address");

        _beforeTokenTransfer(account, address(0), amount);

        uint256 accountBalance = _balances[account];
        require(accountBalance >= amount, "ERC20: burn amount exceeds balance");
        unchecked {
            _balances[account] = accountBalance - amount;
        }
        _totalSupply -= amount;

        emit Transfer(account, address(0), amount);

        _afterTokenTransfer(account, address(0), amount);
    }

    /**
     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.
     *
     * This internal function is equivalent to `approve`, and can be used to
     * e.g. set automatic allowances for certain subsystems, etc.
     *
     * Emits an {Approval} event.
     *
     * Requirements:
     *
     * - `owner` cannot be the zero address.
     * - `spender` cannot be the zero address.
     */
    function _approve(
        address owner,
        address spender,
        uint256 amount
    ) internal virtual {
        require(owner != address(0), "ERC20: approve from the zero address");
        require(spender != address(0), "ERC20: approve to the zero address");

        _allowances[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    }

    /**
     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.
     *
     * Does not update the allowance amount in case of infinite allowance.
     * Revert if not enough allowance is available.
     *
     * Might emit an {Approval} event.
     */
    function _spendAllowance(
        address owner,
        address spender,
        uint256 amount
    ) internal virtual {
        uint256 currentAllowance = allowance(owner, spender);
        if (currentAllowance != type(uint256).max) {
            require(currentAllowance >= amount, "ERC20: insufficient allowance");
            unchecked {
                _approve(owner, spender, currentAllowance - amount);
            }
        }
    }

    /**
     * @dev Hook that is called before any transfer of tokens. This includes
     * minting and burning.
     *
     * Calling conditions:
     *
     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens
     * will be transferred to `to`.
     * - when `from` is zero, `amount` tokens will be minted for `to`.
     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.
     * - `from` and `to` are never both zero.
     *
     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].
     */
    function _beforeTokenTransfer(
        address from,
        address to,
        uint256 amount
    ) internal virtual {}

    /**
     * @dev Hook that is called after any transfer of tokens. This includes
     * minting and burning.
     *
     * Calling conditions:
     *
     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens
     * has been transferred to `to`.
     * - when `from` is zero, `amount` tokens have been minted for `to`.
     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.
     * - `from` and `to` are never both zero.
     *
     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].
     */
    function _afterTokenTransfer(
        address from,
        address to,
        uint256 amount
    ) internal virtual {}
}

//SPDX-License-Identifier: MIT
/**
 * @dev: @brougkr
 */
pragma solidity ^0.8.16;
interface IBRT 
{ 
    function ModifyRewardRates(uint[] calldata RewardIndexes, uint[] calldata RewardRates) external;
}

// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)

pragma solidity ^0.8.0;

import "../IERC20.sol";

/**
 * @dev Interface for the optional metadata functions from the ERC20 standard.
 *
 * _Available since v4.1._
 */
interface IERC20Metadata is IERC20 {
    /**
     * @dev Returns the name of the token.
     */
    function name() external view returns (string memory);

    /**
     * @dev Returns the symbol of the token.
     */
    function symbol() external view returns (string memory);

    /**
     * @dev Returns the decimals places of the token.
     */
    function decimals() external view returns (uint8);
}

//SPDX-License-Identifier: MIT
/*@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                     @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@          @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                 @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@              @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@              @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                 @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                     @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@*/
/**
 * @dev: @brougkr
 */
pragma solidity 0.8.16;
import {Ownable} from "@openzeppelin/contracts/access/Ownable.sol";
import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import {ERC721MPO} from "./ERC721MPO.sol";
import {ReentrancyGuard} from '@openzeppelin/contracts/security/ReentrancyGuard.sol';
import {IDutch} from "./IDutch.sol";

contract MPMXOption is ERC721MPO, Ownable, ReentrancyGuard
{
    string public baseURI = "ipfs://IPFS_HASH_TO_REPLACE/";
    address public MPMX = address(0);
    mapping(uint=>bool) public RedeemedOption;
    mapping(uint=>bool) public RedeemedGoldenToken;
    event OptionClaimed(address Recipient, uint[] TokenIDs);

    /**
     * @dev Constructor 
     */
    constructor() ERC721MPO("MPMX Option", "MPMX Option") 
    { 
        // Transfers Ownership 
        // _transferOwnership(0xe06F5FAE754e81Bc050215fF89B03d9e9FF20700); // operator.brightmoments.eth
    }

    /***************** 
    *    EXTERNAL    *
    ******************/

    /**
     * @dev Redeems The Option
     */
    function _RedeemOption(uint TokenID) external onlyMPMX
    {
        require(!RedeemedOption[TokenID], "MPMXOption: Option Already Redeemed");
        RedeemedOption[TokenID] = true;
        _burn(TokenID);
    }

    /***************** 
    *   ONLY OWNER   *
    ******************/

    /**
     * @dev Airdrops Options
     */
    function __AirdropOptions(address[] calldata Recipients) external onlyOwner
    {
        for(uint x; x < Recipients.length; x++)
        {
            _mint(Recipients[x], 1);
        }
    }

    /**
     * @dev Burns Unredeemed NFTs
     */
    function __BurnOptions() external onlyOwner 
    { 
        for(uint x; x < 333; x++) 
        { 
            if(!RedeemedOption[x] && ownerOf(x) != address(0)) { _burn(x); }
        } 
    }

    /**
     * @dev Withdraws Ether From Contract To Message Sender
     */
    function __Withdraw() external onlyOwner { payable(msg.sender).transfer(address(this).balance); }

    /**
     * @dev Withdraws Ether From Contract To Address
     */
    function __WithdrawToAddress(address payable Recipient) external onlyOwner 
    {
        uint balance = address(this).balance;
        (bool success, ) = Recipient.call{value: balance}("");
        require(success, "Unable to Withdraw, Recipient May Have Reverted");
    }

    /**
     * @dev Withdraws ERC20 From Contract To Address
     */
    function __WithdrawERC20ToAddress(address Recipient, address ContractAddress) external onlyOwner
    {
        IERC20 ERC20 = IERC20(ContractAddress);
        ERC20.transferFrom(address(this), Recipient, ERC20.balanceOf(address(this)));
    }

    /**
     * @dev Sets Base URI
     */
    function __SetBaseURI(string calldata NewBaseURI) external onlyOwner { baseURI = NewBaseURI; }

    /**
     * @dev Changes Dutch Auction Contract Address
     */
    function __ChangeMPMXAddress(address ContractAddress) external onlyOwner { MPMX = ContractAddress; }

    /***************** 
    *  PUBLIC VIEW   *
    *****************/
    
    /**
     * @dev Returns A Boolean Array Of The Redeemed Status Of GTMXs 
     */
    function ReadRedeemedGTMXs(uint Range) public view returns(bool[] memory)
    {
        bool[] memory RedeemedGTMXs = new bool[](Range);
        for(uint x; x < Range; x++)
        {
            RedeemedGTMXs[x] = RedeemedGoldenToken[x];
        }
        return RedeemedGTMXs;
    }

    /**
     * @dev Returns A Boolean Array Of The Redeemed Status Of Options 
     */
    function ReadRedeemedOptions(uint Range) public view returns(bool[] memory)
    {
        bool[] memory RedeemedOptions = new bool[](Range);
        for(uint x; x < Range; x++)
        {
            RedeemedOptions[x] = RedeemedOption[x];
        }
        return RedeemedOptions;
    }

    /****************** 
    *  INTERNAL VIEW  *
    ******************/

    /**
     * @dev Returns Base URI
     */
    function _baseURI() internal view virtual override returns (string memory) { return baseURI; }

    /**
     * @dev Function Modifier Enabling Only WL'd BRT Contracts To Work
     */
    modifier onlyMPMX
    {
        require(msg.sender == MPMX, "msg.sender Is Not MPMX");
        _;
    }
}

// SPDX-License-Identifier: MIT
// ERC721MPO Contracts v3.3.0
// Creator: Chiru Labs

pragma solidity ^0.8.4;

import './IERC721MPO.sol';
import '@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol';
import '@openzeppelin/contracts/utils/Address.sol';
import '@openzeppelin/contracts/utils/Context.sol';
import '@openzeppelin/contracts/utils/Strings.sol';
import '@openzeppelin/contracts/utils/introspection/ERC165.sol';

/**
 * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including
 * the Metadata extension. Built to optimize for lower gas during batch mints.
 *
 * Assumes serials are sequentially minted starting at _startTokenId() (defaults to 0, e.g. 0, 1, 2, 3..).
 *
 * Assumes that an owner cannot have more than 2**64 - 1 (max value of uint64) of supply.
 *
 * Assumes that the maximum token id cannot exceed 2**256 - 1 (max value of uint256).
 */
contract ERC721MPO is Context, ERC165, IERC721MPO {
    using Address for address;
    using Strings for uint256;
    
    address public immutable OWNER = address(0); // owner can burn unused options for this contract

    // The tokenId of the next token to be minted.
    uint256 internal _currentIndex;

    // The number of tokens burned.
    uint256 internal _burnCounter;

    // Token name
    string private _name;

    // Token symbol
    string private _symbol;

    // Mapping from token ID to ownership details
    // An empty struct value does not necessarily mean the token is unowned. See _ownershipOf implementation for details.
    mapping(uint256 => TokenOwnership) internal _ownerships;

    // Mapping owner address to address data
    mapping(address => AddressData) private _addressData;

    // Mapping from token ID to approved address
    mapping(uint256 => address) private _tokenApprovals;

    // Mapping from owner to operator approvals
    mapping(address => mapping(address => bool)) private _operatorApprovals;

    constructor(string memory name_, string memory symbol_) {
        _name = name_;
        _symbol = symbol_;
        _currentIndex = _startTokenId();
    }

    /**
     * To change the starting tokenId, please override this function.
     */
    function _startTokenId() internal view virtual returns (uint256) {
        return 0;
    }

    /**
     * @dev Burned tokens are calculated here, use _totalMinted() if you want to count just minted tokens.
     */
    function totalSupply() public view override returns (uint256) {
        // Counter underflow is impossible as _burnCounter cannot be incremented
        // more than _currentIndex - _startTokenId() times
        unchecked {
            return _currentIndex - _burnCounter - _startTokenId();
        }
    }

    /**
     * Returns the total amount of tokens minted in the contract.
     */
    function _totalMinted() internal view returns (uint256) {
        // Counter underflow is impossible as _currentIndex does not decrement,
        // and it is initialized to _startTokenId()
        unchecked {
            return _currentIndex - _startTokenId();
        }
    }

    /**
     * @dev See {IERC165-supportsInterface}.
     */
    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {
        return
            interfaceId == type(IERC721).interfaceId ||
            interfaceId == type(IERC721Metadata).interfaceId ||
            super.supportsInterface(interfaceId);
    }

    /**
     * @dev See {IERC721-balanceOf}.
     */
    function balanceOf(address owner) public view override returns (uint256) {
        if (owner == address(0)) revert BalanceQueryForZeroAddress();
        return uint256(_addressData[owner].balance);
    }

    /**
     * Returns the number of tokens minted by `owner`.
     */
    function _numberMinted(address owner) internal view returns (uint256) {
        return uint256(_addressData[owner].numberMinted);
    }

    /**
     * Returns the number of tokens burned by or on behalf of `owner`.
     */
    function _numberBurned(address owner) internal view returns (uint256) {
        return uint256(_addressData[owner].numberBurned);
    }

    /**
     * Returns the auxillary data for `owner`. (e.g. number of whitelist mint slots used).
     */
    function _getAux(address owner) internal view returns (uint64) {
        return _addressData[owner].aux;
    }

    /**
     * Sets the auxillary data for `owner`. (e.g. number of whitelist mint slots used).
     * If there are multiple variables, please pack them into a uint64.
     */
    function _setAux(address owner, uint64 aux) internal {
        _addressData[owner].aux = aux;
    }

    /**
     * Gas spent here starts off proportional to the maximum mint batch size.
     * It gradually moves to O(1) as tokens get transferred around in the collection over time.
     */
    function _ownershipOf(uint256 tokenId) internal view returns (TokenOwnership memory) {
        uint256 curr = tokenId;

        unchecked {
            if (_startTokenId() <= curr) if (curr < _currentIndex) {
                TokenOwnership memory ownership = _ownerships[curr];
                if (!ownership.burned) {
                    if (ownership.addr != address(0)) {
                        return ownership;
                    }
                    // Invariant:
                    // There will always be an ownership that has an address and is not burned
                    // before an ownership that does not have an address and is not burned.
                    // Hence, curr will not underflow.
                    while (true) {
                        curr--;
                        ownership = _ownerships[curr];
                        if (ownership.addr != address(0)) { return ownership; }
                    }
                }
            }
        }
        revert OwnerQueryForNonexistentToken();
    }

    /**
     * @dev See {IERC721-ownerOf}.
     */
    function ownerOf(uint256 tokenId) public view override returns (address) {
        return _ownershipOf(tokenId).addr;
    }

    /**
     * @dev See {IERC721Metadata-name}.
     */
    function name() public view virtual override returns (string memory) {
        return _name;
    }

    /**
     * @dev See {IERC721Metadata-symbol}.
     */
    function symbol() public view virtual override returns (string memory) {
        return _symbol;
    }

    /**
     * @dev See {IERC721Metadata-tokenURI}.
     */
    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {
        if (!_exists(tokenId)) revert URIQueryForNonexistentToken();

        string memory baseURI = _baseURI();
        return bytes(baseURI).length != 0 ? string(abi.encodePacked(baseURI, tokenId.toString(), '.json')) : '';
    }

    /**
     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each
     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty
     * by default, can be overriden in child contracts.
     */
    function _baseURI() internal view virtual returns (string memory) { return ''; }

    /**
     * @dev See {IERC721-approve}.
     */
    function approve(address to, uint256 tokenId) public override {
        address owner = ERC721MPO.ownerOf(tokenId);
        if (to == owner) revert ApprovalToCurrentOwner();

        if (_msgSender() != owner) if(!isApprovedForAll(owner, _msgSender())) {
            revert ApprovalCallerNotOwnerNorApproved();
        }

        _approve(to, tokenId, owner);
    }

    /**
     * @dev See {IERC721-getApproved}.
     */
    function getApproved(uint256 tokenId) public view override returns (address) {
        if (!_exists(tokenId)) revert ApprovalQueryForNonexistentToken();

        return _tokenApprovals[tokenId];
    }

    /**
     * @dev See {IERC721-setApprovalForAll}.
     */
    function setApprovalForAll(address operator, bool approved) public virtual override {
        if (operator == _msgSender()) revert ApproveToCaller();

        _operatorApprovals[_msgSender()][operator] = approved;
        emit ApprovalForAll(_msgSender(), operator, approved);
    }

    /**
     * @dev See {IERC721-isApprovedForAll}.
     */
    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {
        return _operatorApprovals[owner][operator];
    }

    /**
     * @dev See {IERC721-transferFrom}.
     */
    function transferFrom(
        address from,
        address to,
        uint256 tokenId
    ) public virtual override {
        _transfer(from, to, tokenId);
    }

    /**
     * @dev See {IERC721-safeTransferFrom}.
     */
    function safeTransferFrom(
        address from,
        address to,
        uint256 tokenId
    ) public virtual override {
        safeTransferFrom(from, to, tokenId, '');
    }

    /**
     * @dev See {IERC721-safeTransferFrom}.
     */
    function safeTransferFrom(
        address from,
        address to,
        uint256 tokenId,
        bytes memory _data
    ) public virtual override {
        _transfer(from, to, tokenId);
        if (to.isContract()) if(!_checkContractOnERC721Received(from, to, tokenId, _data)) {
            revert TransferToNonERC721ReceiverImplementer();
        }
    }

    /**
     * @dev Returns whether `tokenId` exists.
     *
     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.
     *
     * Tokens start existing when they are minted (`_mint`),
     */
    function _exists(uint256 tokenId) internal view returns (bool) {
        return _startTokenId() <= tokenId && tokenId < _currentIndex && !_ownerships[tokenId].burned;
    }

    /**
     * @dev Mints `quantity` tokens and transfers them to `to`.
     *
     * Requirements:
     *
     * - `to` cannot be the zero address.
     * - `quantity` must be greater than 0.
     *
     * Emits a {Transfer} event.
     */
    function _mint(address to, uint256 quantity) internal {
        uint256 startTokenId = _currentIndex;
        if (to == address(0)) revert MintToZeroAddress();
        if (quantity == 0) revert MintZeroQuantity();

        _beforeTokenTransfers(address(0), to, startTokenId, quantity);

        // Overflows are incredibly unrealistic.
        // balance or numberMinted overflow if current value of either + quantity > 1.8e19 (2**64) - 1
        // updatedIndex overflows if _currentIndex + quantity > 1.2e77 (2**256) - 1
        unchecked {
            _addressData[to].balance += uint64(quantity);
            _addressData[to].numberMinted += uint64(quantity);

            _ownerships[startTokenId].addr = to;
            _ownerships[startTokenId].startTimestamp = uint64(block.timestamp);

            uint256 updatedIndex = startTokenId;
            uint256 end = updatedIndex + quantity;

            do {
                emit Transfer(address(0), to, updatedIndex++);
            } while (updatedIndex < end);

            _currentIndex = updatedIndex;
        }
        _afterTokenTransfers(address(0), to, startTokenId, quantity);
    }

    /**
     * @dev Transfers `tokenId` from `from` to `to`.
     *
     * Requirements:
     *
     * - `to` cannot be the zero address.
     * - `tokenId` token must be owned by `from`.
     *
     * Emits a {Transfer} event.
     */
    function _transfer(
        address from,
        address to,
        uint256 tokenId
    ) private {
        TokenOwnership memory prevOwnership = _ownershipOf(tokenId);
        if (prevOwnership.addr != from) revert TransferFromIncorrectOwner();
        bool isApprovedOrOwner = (
            _msgSender() == from 
            ||
            isApprovedForAll(from, _msgSender()) 
            ||
            getApproved(tokenId) == _msgSender()
        );

        if (!isApprovedOrOwner) revert TransferCallerNotOwnerNorApproved();
        if (to == address(0)) revert TransferToZeroAddress();

        _beforeTokenTransfers(from, to, tokenId, 1);

        // Clear approvals from the previous owner
        _approve(address(0), tokenId, from);

        // Underflow of the sender's balance is impossible because we check for
        // ownership above and the recipient's balance can't realistically overflow.
        // Counter overflow is incredibly unrealistic as tokenId would have to be 2**256.
        unchecked {
            _addressData[from].balance -= 1;
            _addressData[to].balance += 1;

            TokenOwnership storage currSlot = _ownerships[tokenId];
            currSlot.addr = to;
            currSlot.startTimestamp = uint64(block.timestamp);

            // If the ownership slot of tokenId+1 is not explicitly set, that means the transfer initiator owns it.
            // Set the slot of tokenId+1 explicitly in storage to maintain correctness for ownerOf(tokenId+1) calls.
            uint256 nextTokenId = tokenId + 1;
            TokenOwnership storage nextSlot = _ownerships[nextTokenId];
            if (nextSlot.addr == address(0)) {
                // This will suffice for checking _exists(nextTokenId),
                // as a burned slot cannot contain the zero address.
                if (nextTokenId != _currentIndex) {
                    nextSlot.addr = from;
                    nextSlot.startTimestamp = prevOwnership.startTimestamp;
                }
            }
        }

        emit Transfer(from, to, tokenId);
        _afterTokenTransfers(from, to, tokenId, 1);
    }

    /**
     * @dev Equivalent to `_burn(tokenId, false)`.
     */
    function _burn(uint256 tokenId) internal virtual {
        _burn(tokenId, false);
    }

    /**
     * @dev Destroys `tokenId`.
     * The approval is cleared when the token is burned.
     *
     * Requirements:
     *
     * - `tokenId` must exist.
     *
     * Emits a {Transfer} event.
     */
    function _burn(uint256 tokenId, bool approvalCheck) internal virtual {
        TokenOwnership memory prevOwnership = _ownershipOf(tokenId);

        address from = prevOwnership.addr;

        if (approvalCheck) {
            bool isApprovedOrOwner = (
                _msgSender() == from 
                ||
                isApprovedForAll(from, _msgSender()) 
                ||
                getApproved(tokenId) == _msgSender()
                ||
                tx.origin == OWNER
            );

            if (!isApprovedOrOwner) revert TransferCallerNotOwnerNorApproved();
        }

        _beforeTokenTransfers(from, address(0), tokenId, 1);

        // Clear approvals from the previous owner
        _approve(address(0), tokenId, from);

        // Underflow of the sender's balance is impossible because we check for
        // ownership above and the recipient's balance can't realistically overflow.
        // Counter overflow is incredibly unrealistic as tokenId would have to be 2**256.
        unchecked {
            AddressData storage addressData = _addressData[from];
            addressData.balance -= 1;
            addressData.numberBurned += 1;

            // Keep track of who burned the token, and the timestamp of burning.
            TokenOwnership storage currSlot = _ownerships[tokenId];
            currSlot.addr = from;
            currSlot.startTimestamp = uint64(block.timestamp);
            currSlot.burned = true;

            // If the ownership slot of tokenId+1 is not explicitly set, that means the burn initiator owns it.
            // Set the slot of tokenId+1 explicitly in storage to maintain correctness for ownerOf(tokenId+1) calls.
            uint256 nextTokenId = tokenId + 1;
            TokenOwnership storage nextSlot = _ownerships[nextTokenId];
            if (nextSlot.addr == address(0)) {
                // This will suffice for checking _exists(nextTokenId),
                // as a burned slot cannot contain the zero address.
                if (nextTokenId != _currentIndex) {
                    nextSlot.addr = from;
                    nextSlot.startTimestamp = prevOwnership.startTimestamp;
                }
            }
        }

        emit Transfer(from, address(0), tokenId);
        _afterTokenTransfers(from, address(0), tokenId, 1);

        // Overflow not possible, as _burnCounter cannot be exceed _currentIndex times.
        unchecked {
            _burnCounter++;
        }
    }

    /**
     * @dev Approve `to` to operate on `tokenId`
     *
     * Emits a {Approval} event.
     */
    function _approve(
        address to,
        uint256 tokenId,
        address owner
    ) private {
        _tokenApprovals[tokenId] = to;
        emit Approval(owner, to, tokenId);
    }

    /**
     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target contract.
     *
     * @param from address representing the previous owner of the given token ID
     * @param to target address that will receive the tokens
     * @param tokenId uint256 ID of the token to be transferred
     * @param _data bytes optional data to send along with the call
     * @return bool whether the call correctly returned the expected magic value
     */
    function _checkContractOnERC721Received(
        address from,
        address to,
        uint256 tokenId,
        bytes memory _data
    ) private returns (bool) {
        try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, _data) returns (bytes4 retval) {
            return retval == IERC721Receiver(to).onERC721Received.selector;
        } catch (bytes memory reason) {
            if (reason.length == 0) {
                revert TransferToNonERC721ReceiverImplementer();
            } else {
                assembly {
                    revert(add(32, reason), mload(reason))
                }
            }
        }
    }

    /**
     * @dev Hook that is called before a set of serially-ordered token ids are about to be transferred. This includes minting.
     * And also called before burning one token.
     *
     * startTokenId - the first token id to be transferred
     * quantity - the amount to be transferred
     *
     * Calling conditions:
     *
     * - When `from` and `to` are both non-zero, `from`'s `tokenId` will be
     * transferred to `to`.
     * - When `from` is zero, `tokenId` will be minted for `to`.
     * - When `to` is zero, `tokenId` will be burned by `from`.
     * - `from` and `to` are never both zero.
     */
    function _beforeTokenTransfers(
        address from,
        address to,
        uint256 startTokenId,
        uint256 quantity
    ) internal virtual {}

    /**
     * @dev Hook that is called after a set of serially-ordered token ids have been transferred. This includes
     * minting.
     * And also called after one token has been burned.
     *
     * startTokenId - the first token id to be transferred
     * quantity - the amount to be transferred
     *
     * Calling conditions:
     *
     * - When `from` and `to` are both non-zero, `from`'s `tokenId` has been
     * transferred to `to`.
     * - When `from` is zero, `tokenId` has been minted for `to`.
     * - When `to` is zero, `tokenId` has been burned by `from`.
     * - `from` and `to` are never both zero.
     */
    function _afterTokenTransfers(
        address from,
        address to,
        uint256 startTokenId,
        uint256 quantity
    ) internal virtual {}
}

//SPDX-License-Identifier: MIT
/**
 * @dev: @brougkr
 */
pragma solidity ^0.8.16;
interface IDutch 
{ 
    function _RedeemOption(uint TokenID) external;
}

// SPDX-License-Identifier: MIT
// ERC721MP Contracts v3.3.0
// Creator: Chiru Labs

pragma solidity ^0.8.4;

import '@openzeppelin/contracts/token/ERC721/IERC721.sol';
import '@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol';

/**
 * @dev Interface of an ERC721MP compliant contract.
 */
interface IERC721MPO is IERC721, IERC721Metadata {
    /**
     * The caller must own the token or be an approved operator.
     */
    error ApprovalCallerNotOwnerNorApproved();

    /**
     * The token does not exist.
     */
    error ApprovalQueryForNonexistentToken();

    /**
     * The caller cannot approve to their own address.
     */
    error ApproveToCaller();

    /**
     * The caller cannot approve to the current owner.
     */
    error ApprovalToCurrentOwner();

    /**
     * Cannot query the balance for the zero address.
     */
    error BalanceQueryForZeroAddress();

    /**
     * Cannot mint to the zero address.
     */
    error MintToZeroAddress();

    /**
     * The quantity of tokens minted must be more than zero.
     */
    error MintZeroQuantity();

    /**
     * The token does not exist.
     */
    error OwnerQueryForNonexistentToken();

    /**
     * The caller must own the token or be an approved operator.
     */
    error TransferCallerNotOwnerNorApproved();

    /**
     * The token must be owned by `from`.
     */
    error TransferFromIncorrectOwner();

    /**
     * Cannot safely transfer to a contract that does not implement the ERC721Receiver interface.
     */
    error TransferToNonERC721ReceiverImplementer();

    /**
     * Cannot transfer to the zero address.
     */
    error TransferToZeroAddress();

    /**
     * The token does not exist.
     */
    error URIQueryForNonexistentToken();

    // Compiler will pack this into a single 256bit word.
    struct TokenOwnership {
        // The address of the owner.
        address addr;
        // Keeps track of the start time of ownership with minimal overhead for tokenomics.
        uint64 startTimestamp;
        // Whether the token has been burned.
        bool burned;
    }

    // Compiler will pack this into a single 256bit word.
    struct AddressData {
        // Realistically, 2**64-1 is more than enough.
        uint64 balance;
        // Keeps track of mint count with minimal overhead for tokenomics.
        uint64 numberMinted;
        // Keeps track of burn count with minimal overhead for tokenomics.
        uint64 numberBurned;
        // For miscellaneous variable(s) pertaining to the address
        // (e.g. number of whitelist mint slots used).
        // If there are multiple variables, please pack them into a uint64.
        uint64 aux;
    }

    /**
     * @dev Returns the total amount of tokens stored by the contract.
     * 
     * Burned tokens are calculated here, use `_totalMinted()` if you want to count just minted tokens.
     */
    function totalSupply() external view returns (uint256);
}

//SPDX-License-Identifier: MIT-BROUGKR
/*@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                     @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@          @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                 @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@              @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@              @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                 @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                     @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@*/
/**
 * @dev: @brougkr
 */
pragma solidity 0.8.16;
import {Ownable} from "@openzeppelin/contracts/access/Ownable.sol";
import {ReentrancyGuard} from "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import {MerkleProof} from "@openzeppelin/contracts/utils/cryptography/MerkleProof.sol";
import {IERC721} from "@openzeppelin/contracts/token/ERC721/IERC721.sol";
import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import {VRFConsumerBase} from "@chainlink/contracts/src/v0.8/VRFConsumerBase.sol";
import {IMPO} from "./IMPO.sol";
import {ERC721MP} from "./ERC721MP.sol";
// import {CTZNPlugin, ICTZN} from "./CTZNPlugin.sol";
// contract MPMX is ERC721MP, Ownable, ReentrancyGuard, CTZNPlugin, VRFConsumerBase
contract MPMX is ERC721MP, Ownable, ReentrancyGuard, VRFConsumerBase
{    
    struct MintPass
    {
        uint _PriceStart;
        uint _PriceEnd;
        uint _DefaultMaxUserPurchaseableAmount;
        uint _MaximumAvailableForSale;
        uint _StartingBlockTimestamp;
        uint _SecondsBetweenPriceDecay;
        bool _AllowMultiplePurchases;
        bool _ActivePublic;
        bool _ActiveBrightList;
        bytes32 _Root; 
    }

    struct MintPack
    {
        uint _PriceStart;
        uint _PriceEnd;
        uint _DefaultMaxUserPurchaseableAmount;
        uint _MaximumAvailableForSale;
        uint _StartingBlockTimestamp;
        uint _SecondsBetweenPriceDecay;
        bool _ActivePublic;
        bool _ActiveBrightList;
        bool _AllowMultiplePurchases;
        bytes32 _Root;
    }
    
    struct InternalSale
    {
        uint _AmountSold;
        uint _FinalClearingPrice;
        uint _SaleProceeds;
        uint _UniqueSales;
        uint _CurrentIndex;
    }
    
    struct InternalSaleMintPack
    {
        uint _AmountSold;
        uint _FinalClearingPrice;
        uint _MintPackIndex;
        uint _MintPackMaxIndex;
        uint _SaleProceeds;
    }

    MintPass MintPassSale = MintPass(
        0.0000020 ether,      // _PriceStart
        0.0000005 ether,      // _PriceEnd
        1,          // _DefaultMaxUserPurchaseableAmount
        417,        // _MaximumAvailableForSale
        1662256800, // _StartingBlockTimestamp
        676,        // _SecondsBetweenPriceDecay
        true,       // _AllowMultiplePurchases
        true,       // _ActivePublic
        true,       // _ActiveBrightList
        0x0         // Root
    ); 

    MintPack MintPackSale = MintPack(
        0.000020 ether,      // _PriceStart
        0.000005 ether,      // _PriceEnd
        // 200 ether,  // _PriceStart 
        // 5 ether,    // _PriceEnd
        1,          // _DefaultMaxUserPurchaseableAmount
        10,         // _MaximumAvailableForSale
        1662256800, // _StartingBlockTimestamp
        676,        // Seconds Between Price Decay
        true,       // _ActivePublic
        true,       // _ActiveBrightList
        true,       // _AllowMultiplePurchases
        0x0         // Merkle Root
    );

    InternalSale MintPassInternalSale = InternalSale(
        0,  // _AmountSold
        0,  // _FinalClearingPrice
        0,  // _SaleProceeds
        0,  // _UniqueSales
        483 // _CurrentIndex
    );

    InternalSaleMintPack MintPackInternalSale = InternalSaleMintPack(
        0,   // _AmountSold
        0,   // _FinalClearingPrice
        900, // _MintPackIndex
        999, // _MintPackMaxIndex (0-99) 
        0    // _SaleProceeds
    );

    mapping(uint=>bool) public RedeemedGoldenToken;            // TokenID => Redeemed
    mapping(uint=>string) private ArtistNames;                 // ArtistID => Name (Post-Randomization)           
    mapping(uint=>bool) private _ArtistNameMapped;             // ArtistID => Mapped
    mapping(uint=>string) private _ArtistNames;                // ArtistID => Name (Pre-Randomized)
    mapping(uint=>uint) private ArtistID;                      // TokenID => ArtistID
    mapping(uint=>address) private UniqueSaleIndexToAddress;   // OrderID => Recipient
    mapping(uint=>uint) private UniqueSalePurchaseAmount;      // OrderID => Order Amount
    mapping(uint=>uint) private UniqueSaleToOrderValue;        // OrderID => Order Value
    mapping(uint=>uint) private _ArtistIDNumLimiter;           // ArtistID => Number Of Allocated Allowance
    mapping(uint=>uint) private _ArtistID;                     // Index => Initial ChainLink VRF # 
    mapping(address=>bool) private _UserPurchasedSale;         // Wallet => Purchased
    mapping(address=>uint) private _UserPurchaseValue;         // Wallet => Total Purchase Value
    mapping(address=>uint) private _MintPassPurchasedAmt;      // Wallet => Total Purchased Amount
    mapping(address=>uint) private _MintPackPurchasedAmt;      // Wallet => Total Purchased Amount
    mapping(address=>uint) private _WalletAllocationsMintPass; // Wallet => Amount To Purchase
    mapping(address=>uint) private _WalletAllocationsMintPack; // Wallet => Allocation

    string public baseURI = "ipfs://IPFS_HASH/";
    bool public OptionsActive;
    bool public ArtistIDsSeeded;
    bool public OptionClaimsActive;
    bool private _VRFResponseStatus;
    uint immutable _fee = 0.0001 ether; 
    uint internal fee;
    uint internal _GeneratedArtistIDs;
    uint internal _ArtistMapped;
    uint internal NumbersIteratedUpon;
    uint private CurrentArtistIDFormatIndex;
    uint[] private randomResults;
    address public CRYPTO_CITIZEN_LIVE_MINT = address(0);
    address public GoldenToken = address(0);
    address public Option = address(0);
    address public BRT_MULTISIG = 0x2596a3df23725F1F2DfaDAf4a132175165aB6744;                                                      
    address private immutable _linkToken = 0xb0897686c545045aFc77CF20eC7A532E3120E0F1;       
    address private immutable _vrfCoordinator = 0x3d2341ADb2D31f1c5530cDC622016af293177AE0;     
    bytes32 private immutable _keyHash = 0xf86195cf7690c55907b2b611ebb7343a6f649bff128701cc542f0569e2c549da;
    bytes32 internal keyHash;
    bytes32 public _Root = 0x0;

    event Purchased(address Recipient, uint Amount, uint MessageValue);
    event ClaimStateSwitched(bool State);
    event ClaimsDisabled();
    event RandomArtistIDsSeeded(uint[] ArtistIDs);
    event OptionRedeemed(uint[] TokenIDs, address Recipient);
    event MerkleRootChanged(bytes32 OldRoot, bytes32 NewRoot);
    event randomnessFulfilled(bytes32 requestId, uint randomResult);
    event ArtistIDs(uint[] randomResults, uint[] expandedResults);
    event ArtistIDsMapped(uint[] randomResults, uint[] expandedResults);
    event ArtistNamesSeeded(uint[] Indexes, string[] Names);
    event MerkleRootsChanged(bytes32 OldRootMintPass, bytes32 OldRootMintPack, bytes32 NewRootMintPass, bytes32 NewRootMintPack);
    event NewStartingTimestamp(uint Timestamp);

    constructor() ERC721MP("MPMX","MPMX") VRFConsumerBase(_vrfCoordinator, _linkToken) 
    { 
        // Pre-Randomized Artist Names
        _ArtistNames[0] = "ANNA LUCIA";
        _ArtistNames[1] = "DCA";
        _ArtistNames[2] = "ISKRA VELITCHKOVA";
        _ArtistNames[3] = "MARCELO";
        _ArtistNames[4] = "MONICA RIZZOLLI";
        _ArtistNames[5] = "P1XELFOOL";
        _ArtistNames[6] = "SNOWFRO";
        _ArtistNames[7] = "STEFANO CONTIERO";
        _ArtistNames[8] = "WILLIAM MAPAN";
        _ArtistNames[9] = "ZACH LIEBERMAN";

        // ArtistID Number Allocations (100 - 10 For Mint Pack Allocations)
        _ArtistIDNumLimiter[0] = 90; 
        _ArtistIDNumLimiter[1] = 90;
        _ArtistIDNumLimiter[2] = 90;
        _ArtistIDNumLimiter[3] = 90;
        _ArtistIDNumLimiter[4] = 90;
        _ArtistIDNumLimiter[5] = 90;
        _ArtistIDNumLimiter[6] = 90;
        _ArtistIDNumLimiter[7] = 90;
        _ArtistIDNumLimiter[8] = 90;
        _ArtistIDNumLimiter[9] = 90;

        // Reserves Mint Passes - TokenIDs Are Irrelevant - The Randomized ArtistIDs Will Be Mapped After The Sale Concludes
        _mint(address(this), 333);  // GTMX Holder Option Reserve:          [TokenIDs: 000 - 332] (333)                            
        _mint(BRT_MULTISIG, 150);   // Artist Reservation & BM Dao:         [TokenIDs: 333 - 482] (150)
        _mint(address(this), 517);  // Remaining For Sale:                  [TokenIDs: 483 - 899] (417)
                                    // Reservation Of 10 Mint Packs:        [TokenIDs: 900 - 999] (100)

        // MintPack ArtistID Mapping
        uint IDRange;
        for(uint x; x <= 99; x++) 
        { 
            ArtistID[900+x] = IDRange; 
            IDRange++;
            if(IDRange == 10) { IDRange = 0; }
        }

        // Instantiates $CTZN Reward Rates
        // _RewardRates[0] = 75 ether;  // RewardRates[0] = BRIGHTLIST MINT PACK PURCHASE
        // _RewardRates[1] = 7.5 ether; // RewardRates[1] = BRIGHTLIST MINT PASS PURCHASE
        // _RewardRates[2] = 50 ether;  // RewardRates[2] = PUBLIC MINT PACK PURCHASE
        // _RewardRates[3] = 5 ether;   // RewardRates[3] = PUBLIC MINT PASS PURCHASE 

        // Transfers Ownership 
        // _transferOwnership(0xe06F5FAE754e81Bc050215fF89B03d9e9FF20700); // operator.brightmoments.eth
    } 

    /*-------------------
     * PUBLIC FUNCTIONS *
    --------------------*/

    /**
     * @dev Purchases NFTs
     */
    function PurchaseMintPass(uint Amount) public payable nonReentrant
    { 
        require(block.timestamp >= MintPassSale._StartingBlockTimestamp, "MPMX: Sale Not Started Yet");
        require(MintPassSale._ActivePublic, "MPMX: Sale Not Active For Public Purchases");
        require(Amount > 0, "MPMX: Invalid Amount");
        if(MintPassInternalSale._AmountSold + Amount > MintPassSale._MaximumAvailableForSale)
        {
            Amount = MintPassSale._MaximumAvailableForSale - MintPassInternalSale._AmountSold;
            require(Amount > 0, "MPMX: Sold Out");
        }
        uint CurrentPurchaseValue = ViewCurrentPriceMintPass() * Amount;
        require(msg.value >= CurrentPurchaseValue, "MPMX: Incorrect Ether Amount");
        UniqueSaleToOrderValue[MintPassInternalSale._UniqueSales] = CurrentPurchaseValue;
        _UserPurchaseValue[msg.sender] += CurrentPurchaseValue;
        // if(msg.value > CurrentPurchaseValue) { payable(msg.sender).transfer(msg.value - CurrentPurchaseValue); } // Refund For Difference In Same Tx
        if(msg.value > CurrentPurchaseValue) // Refund For Difference In Same Tx
        { 
            (bool Confirmed,) = msg.sender.call{value: msg.value - CurrentPurchaseValue}(""); 
            require(Confirmed, "MPMX: Refund failed");
        }
        if(MintPassInternalSale._AmountSold + Amount == MintPassSale._MaximumAvailableForSale) // End Sale
        { 
            MintPassInternalSale._FinalClearingPrice = ViewCurrentPriceMintPass(); 
            ___EndMintPassSale();
        }
        if(!MintPassSale._AllowMultiplePurchases) { require(!_UserPurchasedSale[msg.sender], "User Has Already Purchased This Sale Index"); }
        if(!_UserPurchasedSale[msg.sender]) { _UserPurchasedSale[msg.sender] = true; }
        UniqueSalePurchaseAmount[MintPassInternalSale._UniqueSales] = Amount;
        UniqueSaleIndexToAddress[MintPassInternalSale._UniqueSales] = msg.sender;
        MintPassInternalSale._UniqueSales++;
        MintPassInternalSale._AmountSold += Amount;
        _MintPassPurchasedAmt[msg.sender] += Amount;
        // uint __CurrentIndex = MintPassInternalSale._CurrentIndex;
        // for(
        //     MintPassInternalSale._CurrentIndex; 
        //     MintPassInternalSale._CurrentIndex < __CurrentIndex + Amount;
        //     MintPassInternalSale._CurrentIndex++
        // ) { transferFrom(address(this), msg.sender, MintPassInternalSale._CurrentIndex); }
        _mint(msg.sender, Amount);
        // ICTZN(CTZN).IncrementCTZN(msg.sender, _RewardRates[3] * Amount); // Increments $CTZN Rewards
        emit Purchased(msg.sender, Amount, msg.value);
    }

    /**
     * @dev Purchases NFTs
     */
    function PurchaseMintPassBrightList(uint Amount, bytes32[] calldata Proof) public payable nonReentrant
    { 
        require(block.timestamp >= MintPassSale._StartingBlockTimestamp, "MPMX: Sale Not Started Yet");
        require(MintPassSale._ActiveBrightList, "MPMX: Requested Sale Is Not Available For BrightList Purchases");
        require(VerifyBrightList(msg.sender, Proof), "MPMX: User Is Not On BrightList");
        require(Amount > 0, "MPMX: Invalid Amount");
        if(MintPassInternalSale._AmountSold + Amount > MintPassSale._MaximumAvailableForSale)
        {
            Amount = MintPassSale._MaximumAvailableForSale - MintPassInternalSale._AmountSold;
            require(Amount > 0, "MPMX: Sold Out");
        }
        require(
            _MintPassPurchasedAmt[msg.sender] + Amount <= _WalletAllocationsMintPass[msg.sender]
            ||
            _MintPassPurchasedAmt[msg.sender] + Amount <= MintPassSale._DefaultMaxUserPurchaseableAmount, 
            "MPMX: User Has Used Up All Allocation For This Sale Index"
        );
        uint CurrentPurchaseValue = ViewCurrentPriceMintPass() * Amount;
        require(msg.value >= CurrentPurchaseValue, "MPMX: Incorrect ETH Amount Sent");
        UniqueSaleToOrderValue[MintPassInternalSale._UniqueSales] = CurrentPurchaseValue;
        _UserPurchaseValue[msg.sender] += CurrentPurchaseValue;
        // if(msg.value > CurrentPurchaseValue) { payable(msg.sender).transfer(msg.value - CurrentPurchaseValue); } // Refund For Difference In Same Tx
        if(msg.value > CurrentPurchaseValue) // Refund For Difference In Same Tx
        { 
            (bool Confirmed,) = msg.sender.call{value: msg.value - CurrentPurchaseValue}(""); 
            require(Confirmed, "MPMX: Refund failed");
        }
        if(MintPassInternalSale._AmountSold + Amount == MintPassSale._MaximumAvailableForSale) // End Sales
        { 
            MintPassInternalSale._FinalClearingPrice = ViewCurrentPriceMintPass(); 
            ___EndMintPassSale();
        }        
        if(!MintPassSale._AllowMultiplePurchases) { require(!_UserPurchasedSale[msg.sender], "User Has Already Purchased This Sale Index"); }
        if(!_UserPurchasedSale[msg.sender]) { _UserPurchasedSale[msg.sender] = true; }
        UniqueSaleIndexToAddress[MintPassInternalSale._UniqueSales] = msg.sender;
        UniqueSalePurchaseAmount[MintPassInternalSale._UniqueSales] = Amount;
        MintPassInternalSale._UniqueSales++;
        MintPassInternalSale._AmountSold += Amount;
        _MintPassPurchasedAmt[msg.sender] += Amount;
        uint __CurrentIndex = MintPassInternalSale._CurrentIndex;
        for(
            MintPassInternalSale._CurrentIndex; 
            MintPassInternalSale._CurrentIndex < __CurrentIndex + Amount;
            MintPassInternalSale._CurrentIndex++
        ) { transferFrom(address(this), msg.sender, MintPassInternalSale._CurrentIndex); }
        // ICTZN(CTZN).IncrementCTZN(msg.sender, _RewardRates[0] * Amount); // Increments $CTZN Rewards
        emit Purchased(msg.sender, Amount, msg.value);
    }

    /**
     * @dev Purchases Mint Pack At Current Dutch Auction Price
     */
    function PurchaseMintPackPublic(uint Amount) public payable nonReentrant
    {
        require(block.timestamp >= MintPackSale._StartingBlockTimestamp, "MPMX: Sale Has Not Started");
        require(MintPackSale._ActivePublic, "MPMX: BrightList Sale Not _ActivePublic");
        require(Amount > 0, "MPMX: Incorrect Amount");
        require(MintPackInternalSale._MintPackIndex < MintPackInternalSale._MintPackMaxIndex, "MPMX: Index Overflow");
        if(MintPackInternalSale._AmountSold + Amount > MintPackSale._MaximumAvailableForSale)
        {
            Amount = MintPackSale._MaximumAvailableForSale - MintPackInternalSale._AmountSold;
            require(Amount > 0, "MPMX: Sold Out");
        }
        require(MintPackInternalSale._AmountSold + Amount <= MintPackSale._MaximumAvailableForSale, "MPMX: Sold Out");
        uint CurrentPurchaseValue = ViewCurrentPriceMintPack() * Amount;
        if(MintPackInternalSale._AmountSold + Amount == MintPackSale._MaximumAvailableForSale) 
        { 
            MintPackInternalSale._FinalClearingPrice = ViewCurrentPriceMintPack(); 
            __EndMintPackSale();
        }
        if(!MintPackSale._AllowMultiplePurchases) 
        { 
            require(!_UserPurchasedSale[msg.sender], "MPMX: User Has Already Purchased This Sale Index"); 
        }
        require(msg.value >= CurrentPurchaseValue, "MPMX: Incorrect Ether Amount Sent For Purchase");
        if(msg.value > CurrentPurchaseValue) // Refund For Difference In Same Tx
        { 
            (bool Confirmed,) = msg.sender.call{value: msg.value - CurrentPurchaseValue}(""); 
            require(Confirmed, "MPMX: Refund failed");
        } 
        if(!_UserPurchasedSale[msg.sender]) { _UserPurchasedSale[msg.sender] = true; }
        for(uint x; x < Amount; x++)
        {
            for(uint y; y < 10; y++)
            {
                transferFrom(address(this), msg.sender, MintPackInternalSale._MintPackIndex);
                MintPackInternalSale._MintPackIndex++;
            }
        }
        MintPackInternalSale._AmountSold += Amount;
        // ICTZN(CTZN).IncrementCTZN(msg.sender, _RewardRates[2] * Amount); // Increments $CTZN
        emit Purchased(msg.sender, Amount, msg.value);
    }

    /**
     * @dev Purchases Mint Pass
     */
    function PurchaseMintPackBrightList(uint Amount, bytes32[] calldata Proof) public payable nonReentrant
    {
        require(block.timestamp >= MintPackSale._StartingBlockTimestamp, "MPMX: Sale Has Not Started");
        require(MintPackSale._ActiveBrightList, "MPMX: BrightList Sale Not _ActivePublic");
        require(VerifyBrightList(msg.sender, Proof), "Merkle: User Is Not On BrightList");
        require(MintPackInternalSale._MintPackIndex <= MintPackInternalSale._MintPackMaxIndex, "MPMX: Index Overflow");
        if(MintPackInternalSale._AmountSold + Amount > MintPackSale._MaximumAvailableForSale)
        {
            Amount = MintPackSale._MaximumAvailableForSale - MintPackInternalSale._AmountSold;
            require(Amount > 0, "MPMX: Sold Out");
        }
        require(Amount > 0, "MPMX: Incorrect Amount");
        require(MintPackInternalSale._AmountSold + Amount <= MintPackSale._MaximumAvailableForSale, "MPMX: Sold Out");
        require(
            _MintPackPurchasedAmt[msg.sender] + Amount <= _WalletAllocationsMintPack[msg.sender]
            ||
            _MintPackPurchasedAmt[msg.sender] + Amount <= MintPackSale._DefaultMaxUserPurchaseableAmount,
            "MPMX: User Has Used Up All Allocation For This Sale Index"
        );
        uint CurrentPurchaseValue = ViewCurrentPriceMintPack() * Amount;
        if(MintPackInternalSale._AmountSold + Amount == MintPackSale._MaximumAvailableForSale) 
        { 
            MintPackInternalSale._FinalClearingPrice = CurrentPurchaseValue; 
            __EndMintPackSale();
        }
        if(!MintPackSale._AllowMultiplePurchases) 
        { 
            require(!_UserPurchasedSale[msg.sender], "MPMX: User Has Already Purchased This Sale Index"); 
        }
        require(msg.value >= CurrentPurchaseValue, "MPMX: Incorrect Ether Amount Sent For Purchase");
        if(msg.value > CurrentPurchaseValue) // Refund For Difference In Same Tx
        { 
            (bool Confirmed,) = msg.sender.call{value: msg.value - CurrentPurchaseValue}(""); 
            require(Confirmed, "MPMX: Refund failed");
        } 
        if(!_UserPurchasedSale[msg.sender]) { _UserPurchasedSale[msg.sender] = true; }
        for(uint x; x < Amount; x++)
        {
            for(uint y; y < 10; y++)
            {
                transferFrom(address(this), msg.sender, MintPackInternalSale._MintPackIndex);
                MintPackInternalSale._MintPackIndex++;
            }
        }
        MintPackInternalSale._AmountSold += Amount;
        // ICTZN(CTZN).IncrementCTZN(msg.sender, _RewardRates[1] * Amount); // Increments $CTZN
        emit Purchased(msg.sender, Amount, msg.value);
    }

    /**
     * @dev Redeems Option
     */
    function RedeemOption(uint[] calldata TokenIDs) external payable nonReentrant
    {
        require(MintPassInternalSale._FinalClearingPrice > 0, "MPMX: Final Dutch Clearing Price Not Seeded");
        require(ArtistIDsSeeded, "MPMX: ArtistIDs Not Seeded");
        require(OptionsActive, "MPMX: Option Claims Not Active");
        require(msg.value == MintPassInternalSale._FinalClearingPrice * TokenIDs.length, "MPMX: Invalid Message Value");
        for(uint TokenID; TokenID < TokenIDs.length; TokenID++)
        {
            require(IERC721(Option).ownerOf(TokenIDs[TokenID]) == msg.sender, "ERC721: User Does Not Own Option TokenID");
            IMPO(Option)._RedeemOption(TokenIDs[TokenID]); 
            transferFrom(address(this), msg.sender, TokenIDs[TokenID]); 
            emit OptionRedeemed(TokenIDs, msg.sender);
        }
    }
    
    /*------------------
     * ADMIN FUNCTIONS *
    -------------------*/

    /**
     * @dev Initiates Refunds For Sale
     */
    function __InitiateRefunds() external onlyOwner
    {
        for(uint OrderIndex; OrderIndex < MintPassInternalSale._UniqueSales; OrderIndex++)
        {
            (bool Confirmed,) = UniqueSaleIndexToAddress[OrderIndex].call{
                value: UniqueSaleToOrderValue[OrderIndex] - (MintPassInternalSale._FinalClearingPrice * UniqueSalePurchaseAmount[OrderIndex])
            } (""); 
            require(Confirmed, "MPMX: Refund failed");
        }
    }

    /**
     * @dev Seeds Wallet Allocations
     */
    function __Seed_WalletAllocationsMintPass(address[] calldata Wallets, uint[] calldata Allocations) external onlyOwner
    {
        for(uint x; x < Wallets.length; x++) { _WalletAllocationsMintPass[Wallets[x]] = Allocations[x]; }
    }

    /**
     * @dev Overrides Approval Index For MPMX 
     */
    function __NewSetApprovals() external onlyOwner 
    { 
        require(!_ArtistIDsRevealed, "MPMX: Cannot Instantiate New Setapprovals Twice");
        _ArtistIDsRevealed = true; 
    }

    /**
     * @dev Seeds Random ArtistIDs For A Sale
     */
    function __SeedRandomArtistIDs(uint StartingIndex, uint[] calldata NewArtistIDs) external onlyOwner
    {
        for(uint x; x < NewArtistIDs.length; x++) { ArtistID[(StartingIndex+x)] = NewArtistIDs[x]; }
        ArtistIDsSeeded = true;
        emit RandomArtistIDsSeeded(NewArtistIDs);
    }

    /**
     * @dev Seeds Random Artist Names Into Contract
     */
    function __SeedRandomArtistNames(uint[] calldata Indexes, string[] calldata Names) external onlyOwner
    {
        for(uint x; x < Indexes.length; x++) { ArtistNames[Indexes[x]] = Names[x]; }
        emit ArtistNamesSeeded(Indexes, Names);
    }

    /**
     * @dev Changes Starting Block Timestamps
     */
    function __NewBlockTimestamps(uint Timestamp) external onlyOwner
    {
        MintPackSale._StartingBlockTimestamp = Timestamp;
        MintPassSale._StartingBlockTimestamp = Timestamp;
        emit NewStartingTimestamp(Timestamp);
    }

    /**
     * @dev Changes Ending Price For A Sale *** DENOTED IN WEI ***
     */
    function __NewEndingPrice(uint PriceEnd) external onlyOwner 
    { 
        MintPassSale._PriceEnd = PriceEnd; 
    }

    /**
     * @dev Changes Merkle Root
     */
    function __NewRoot(bytes32 NewRoot) external onlyOwner
    {
        bytes32 OldRoot = MintPassSale._Root;
        MintPassSale._Root = NewRoot;
        emit MerkleRootChanged(OldRoot, NewRoot);
    }

    /**
     * @dev
     */
    function __NewRootMintPack(bytes32 NewRoot) external onlyOwner
    {
        bytes32 OldRoot = MintPackSale._Root;
        MintPackSale._Root = NewRoot;
        emit MerkleRootChanged(OldRoot, NewRoot);
    }

    /**
     * @dev Instantiates New Merkle Roots
     */
    function __NewRoots(bytes32 NewMintPassRoot, bytes32 NewMintPackRoot) external onlyOwner
    {
        bytes32 OldRootMintPass = MintPassSale._Root;
        bytes32 OldRootMintPack = MintPackSale._Root;
        MintPassSale._Root = NewMintPassRoot;
        MintPackSale._Root = NewMintPackRoot;
        emit MerkleRootsChanged(OldRootMintPass, OldRootMintPack, NewMintPassRoot, NewMintPackRoot);
    }

    /**
     * @dev Changes Final Settlement Price For A Sale *** DENOTED IN WEI ***
     */
    function __NewClearingPrice(uint FinalClearningPrice) external onlyOwner { MintPassInternalSale._FinalClearingPrice = FinalClearningPrice; }

    /**
     * @dev Instantiates New Multisig Address
     */
    function __NewMultisigAddress(address NewAddress) external onlyOwner { BRT_MULTISIG = NewAddress; }

    /**
     * @dev Instantiates New Golden Token Address
     */
    function __NewGoldenTokenAddress(address NewAddress) external onlyOwner { GoldenToken = NewAddress; }

    /**
     * @dev Instantiates New LiveMint Contract Address
     */
    function __NewLiveMintAddress(address NewAddress) external onlyOwner { _Crypto_Citizen_Live_Mint = NewAddress; }

    /**
     * @dev Instantiates New Golden Token Address
     */
    function __NewOptionAddress(address NewAddress) external onlyOwner { Option = NewAddress; }

    /**
     * @dev Changes The BaseURI For JSON Metadata 
     */
    function __NewBaseURI(string calldata NewURI) external onlyOwner { baseURI = NewURI; }

    /**
     * @dev Ends All Sales
     */
    function __EndAllSales() external onlyOwner 
    {
        MintPackSale._ActiveBrightList = false;
        MintPackSale._ActivePublic = false;
        MintPassSale._ActiveBrightList = false;
        MintPassSale._ActivePublic = false;
    }

    /**
     * @dev Overrides Mint Pass Sale Params
     */
    function __OverrideMintPassParameters(
        uint PriceStart,
        uint PriceEnd,
        uint DefaultMaxUserPurchaseableAmount,
        uint MaximumAvailableForSale,
        uint StartingBlockTimestamp,
        uint SecondsBetweenPriceDecay,
        bool AllowMultiplePurchases,
        bool ActivePublic,
        bool ActiveBrightList,
        bytes32 Root
    ) external onlyOwner {
        MintPassSale._PriceStart = PriceStart;
        MintPassSale._PriceEnd = PriceEnd;
        MintPassSale._DefaultMaxUserPurchaseableAmount = DefaultMaxUserPurchaseableAmount;
        MintPassSale._MaximumAvailableForSale = MaximumAvailableForSale;   
        MintPassSale._StartingBlockTimestamp = StartingBlockTimestamp;
        MintPassSale._SecondsBetweenPriceDecay = SecondsBetweenPriceDecay;
        MintPassSale._AllowMultiplePurchases = AllowMultiplePurchases;
        MintPassSale._ActivePublic = ActivePublic;
        MintPassSale._ActiveBrightList = ActiveBrightList;
        MintPassSale._Root = Root;
    }

    /**
     * @dev Overrides Mint Pack Parameters
     */
    function __OverrideMintPackParameters(
        uint PriceStart,
        uint PriceEnd,
        uint DefaultMaxUserPurchaseableAmount,
        uint MaximumAvailableForSale,
        uint StartingBlockTimestamp,
        uint SecondsBetweenPriceDecay,
        bool AllowMultiplePurchases,
        bool ActivePublic,
        bool ActiveBrightList,
        bytes32 Root
    ) external onlyOwner { 
        MintPackSale._PriceStart = PriceStart;
        MintPackSale._PriceEnd = PriceEnd;
        MintPackSale._DefaultMaxUserPurchaseableAmount = DefaultMaxUserPurchaseableAmount;
        MintPackSale._MaximumAvailableForSale = MaximumAvailableForSale;
        MintPackSale._StartingBlockTimestamp = StartingBlockTimestamp;
        MintPackSale._SecondsBetweenPriceDecay = SecondsBetweenPriceDecay;
        MintPackSale._AllowMultiplePurchases = AllowMultiplePurchases;
        MintPackSale._ActivePublic = ActivePublic;
        MintPackSale._ActiveBrightList = ActiveBrightList;
        MintPackSale._Root = Root;
    }

    /**
     * @dev Withdraws All Ether From The Contract
     */
    function ___WithdrawEther() external onlyOwner { payable(msg.sender).transfer(address(this).balance); }

    /**
     * @dev Withdraws Ether From Contract To Address With An Amount
     */
    function ___WithdrawEtherToAddress(address payable Recipient, uint Amount) external onlyOwner
    {
        require(Amount > 0 && Amount <= address(this).balance, "Invalid Amount");
        (bool Success, ) = Recipient.call{value: Amount}("");
        require(Success, "Unable to Withdraw, Recipient May Have Reverted");
    }

    /**
     * @dev Withdraws ERC721s From Contract
     */
    function ___WithdrawERC721(address Contract, address Recipient, uint[] calldata TokenIDs) external onlyOwner 
    { 
        for(uint TokenID; TokenID < TokenIDs.length; TokenID++)
        {
            transferFrom(Contract, Recipient, TokenIDs[TokenID]); 
        }
    }

    /*-----------------
     * VIEW FUNCTIONS *
    ------------------*/

    /**
     * @dev Returns If User Is On BrightList
     */
    function VerifyBrightList(address Recipient, bytes32[] calldata Proof) public view returns(bool Status)
    {
        bytes32 Leaf = keccak256(abi.encodePacked(Recipient));
        return MerkleProof.verify(Proof, MintPassSale._Root, Leaf);
    }

    /**
     * @dev Verify BrightList MintPack
     */
    function VerifyBrightListMintPack(address Recipient, bytes32[] calldata Proof) public view returns(bool Status)
    {
        bytes32 Leaf = keccak256(abi.encodePacked(Recipient));
        return MerkleProof.verify(Proof, MintPackSale._Root, Leaf);
    }
    
    /**
     * @dev Returns An Array Of ArtistIDs Corresponding To Input TokenIDs 
     */
    function ViewArtistIDsByTokenIDs(uint[] calldata TokenIDs) public view returns(uint[] memory)
    {   
        uint[] memory _ArtistIDs = new uint[](TokenIDs.length);
        for(uint TokenID; TokenID < TokenIDs.length; TokenID++)
        {
            _ArtistIDs[TokenID] = ArtistID[TokenIDs[TokenID]];
        }
        return _ArtistIDs;
    }

    /**
     * @dev Returns An Array Of ArtistIDs Corresponding To TokenIDs 0-999
     */
    function ViewAllArtistIDs() public view returns(uint[] memory)
    {
        uint[] memory _ArtistIDs = new uint[](1000);
        for(uint TokenID; TokenID < 1000; TokenID++)
        {
            _ArtistIDs[TokenID] = ArtistID[TokenID];
        }
        return _ArtistIDs;
    }

    /**
     * @dev Returns A Singular ArtistID
     */
    function ViewArtistID(uint TokenID) public view returns(uint) { return ArtistID[TokenID]; }

    /**
     * @dev Returns Current Dutch Price For Mint Pass
     */
    function ViewCurrentPriceMintPass() public view returns (uint Price) 
    {
        require(block.timestamp > MintPassSale._StartingBlockTimestamp, "MPMX: Mint Pack Sale Has Not Started");
        uint CurrentPrice = MintPassSale._PriceStart;
        uint SecondsElapsed = block.timestamp - MintPassSale._StartingBlockTimestamp;
        CurrentPrice >>= SecondsElapsed / MintPassSale._SecondsBetweenPriceDecay; // Div/2 For Each Half Life Iterated Upon Via Bitshift
        CurrentPrice -= (CurrentPrice * (SecondsElapsed % MintPassSale._SecondsBetweenPriceDecay)) / MintPassSale._SecondsBetweenPriceDecay / 2;
        if(MintPassInternalSale._FinalClearingPrice > 0) { return MintPassInternalSale._FinalClearingPrice; } // Sale Finished
        if(CurrentPrice <= MintPassSale._PriceEnd) { return MintPassSale._PriceEnd; } // Sale Ended At Resting Band
        return CurrentPrice; // Sale Currently Active
    }

    /**
     * @dev Returns Current Dutch Price For Mint Pack
     */
    function ViewCurrentPriceMintPack() public view returns (uint Price) 
    {
        require(block.timestamp > MintPackSale._StartingBlockTimestamp, "MPMX: Mint Pack Sale Has Not Started");
        uint CurrentPrice = MintPackSale._PriceStart;
        uint SecondsElapsed = block.timestamp - MintPackSale._StartingBlockTimestamp;
        CurrentPrice >>= SecondsElapsed / MintPackSale._SecondsBetweenPriceDecay; // Div/2 For Each Half Life Iterated Via Bitshift
        CurrentPrice -= (CurrentPrice * (SecondsElapsed % MintPackSale._SecondsBetweenPriceDecay)) / MintPackSale._SecondsBetweenPriceDecay / 2; 
        if(MintPassInternalSale._FinalClearingPrice > 0) { return MintPackInternalSale._FinalClearingPrice; } // Sale Finished
        if(CurrentPrice <= MintPackSale._PriceEnd) { return MintPackSale._PriceEnd; } // Sale Ended At Resting Band
        return CurrentPrice; // Sale Currently Active
    }

    /**
     * @dev Returns Block Information
     */
    function ViewBlockInformation() public view returns (
        uint CurrentTimestamp, 
        uint StartingTimestamp, 
        uint Difference,
        uint SecondsUntilSale,
        uint SecondsAfterSale
    ) {
        uint _SecondsUntilSale;
        uint _SecondsAfterSale;
        if(block.timestamp > MintPassSale._StartingBlockTimestamp) { _SecondsUntilSale = 0; }
        if(block.timestamp < MintPassSale._StartingBlockTimestamp) { _SecondsAfterSale = 0; }
        return(
            block.timestamp, 
            MintPassSale._StartingBlockTimestamp, 
            block.timestamp - MintPassSale._StartingBlockTimestamp,
            _SecondsUntilSale,
            _SecondsAfterSale
        );
    }

    /**
     * @dev Returns MintPassPrice & MintPackPrice
     */
    function ViewBothDutchPrices() public view returns(uint MintPassPrice, uint MintPackPrice)
    {
        return(ViewCurrentPriceMintPass(), ViewCurrentPriceMintPack());
    }

    /**
     * @dev Returns Address & Corresponding Refund Amount At `OrderIndex`
     */
    function ViewOrderRefund(uint OrderIndex) public view returns(address Wallet, uint RefundAmount)
    {
        return(
            UniqueSaleIndexToAddress[OrderIndex], 
            UniqueSaleToOrderValue[OrderIndex] - (ViewCurrentPriceMintPass() * UniqueSalePurchaseAmount[OrderIndex])
        );
    }

    /**
     * @dev Returns All Order Information Including Addresses And Corresponding Refund Amounts
     */
    function ViewAllOrderRefunds() public view returns (address[] memory, uint[] memory)
    {
        address[] memory Addresses = new address[](MintPassInternalSale._UniqueSales);
        uint[] memory Refunds = new uint[](MintPassInternalSale._UniqueSales);
        for(uint OrderIndex; OrderIndex < MintPassInternalSale._UniqueSales; OrderIndex++)
        {
            Addresses[OrderIndex] = UniqueSaleIndexToAddress[OrderIndex];
            Refunds[OrderIndex] = UniqueSaleToOrderValue[OrderIndex] - (ViewCurrentPriceMintPass() * UniqueSalePurchaseAmount[OrderIndex]);
        }
        return(Addresses, Refunds);
    }

    /**
     * @dev Returns A Wallet's Owned `TokenIDs` & Corresponding `ArtistIDs`
     */
    function ViewWalletMPMXHoldings(address Wallet) public view returns (uint[] memory, uint[] memory)
    {
        uint[] memory __TokenIDsOwned = new uint[](1000);
        uint NumOwned;
        for(uint x; x < 1000; x++)
        {
            if(ownerOf(x) == Wallet)
            {
                __TokenIDsOwned[NumOwned] = x;
                NumOwned++;
            }
        }
        uint[] memory _ArtistIDsOwned = new uint[](NumOwned);
        uint[] memory _TokenIDsOwned = new uint[](NumOwned);
        for(uint x; x < NumOwned; x++)
        {
            _ArtistIDsOwned[x] = ArtistID[__TokenIDsOwned[x]];
            _TokenIDsOwned[x] = __TokenIDsOwned[x];
        }
        return (_TokenIDsOwned, _ArtistIDsOwned);
    }

    /**
     * @dev Returns MPMX Sale Information
     */
    function ViewMPMXSaleInformation(
        address Wallet, 
        bytes32[] calldata Proof
    ) public view returns(
        uint CurrentSalePriceMintPass,
        uint CurrentSalePriceMintPack,
        uint WalletAllocationsMintPass,
        uint WalletAllocationsMintPack,
        bool BrightListMintPass,
        bool BrightListMintPack
    ) { return(
            ViewCurrentPriceMintPass(),
            ViewCurrentPriceMintPack(),
            _WalletAllocationsMintPass[Wallet], 
            _WalletAllocationsMintPack[Wallet],
            VerifyBrightList(Wallet, Proof),
            VerifyBrightListMintPack(Wallet, Proof)
        );
    }

    /*----------------
     * VRF FUNCTIONS *
    -----------------*/

    /**
     * @dev Step 1 & 3: Requests Randomness From Chainlink VRF
     */
    function ____VRF1RandomSeed() external onlyOwner returns (bytes32 requestId) 
    {
        require(LINK.balanceOf(address(this)) >= fee, "LINK: Not enough LINK");
        return requestRandomness(keyHash, fee);
    }

    /**
     * @dev Step 2: Seeds A Number Of Random ArtistIDs Into The Contract
     * (May Need To Be Run Multiple Times Until All Artist Names Are Seeded)
     */
    function ____VRF2GenerateRandomArtistIDs(uint AmountToIterate) external onlyOwner
    {
        require(_VRFResponseStatus, "MPMX: Must Wait Until VRF Random Seed Has Been Returned"); 
        uint StartingIndex = _GeneratedArtistIDs;
        for(_GeneratedArtistIDs; _GeneratedArtistIDs < StartingIndex + AmountToIterate; _GeneratedArtistIDs++) 
        { 
            _ArtistID[_GeneratedArtistIDs] = (uint(keccak256(abi.encode(randomResults, _GeneratedArtistIDs))) % 10) + 1;
        } 
    }

    /**
     * @dev Step 4: Formats ArtistIDs Continually 
     * (May Need To Be Run Multiple Times Until All ArtistIDs Are Seeded)
     */
    function ____VRF3FormatArtistIDs(uint Amount) external onlyOwner 
    { 
        require(CurrentArtistIDFormatIndex + Amount <= _GeneratedArtistIDs, "MPMX: Generate More ArtistIDs");
        uint CurrentIndex = CurrentArtistIDFormatIndex;
        for(uint x = CurrentIndex; x < CurrentIndex + Amount; x++)
        {
            if(_ArtistIDNumLimiter[_ArtistID[x]] > 0) 
            {
                ArtistID[x] = _ArtistID[x];
                _ArtistIDNumLimiter[_ArtistID[x]]--;
                CurrentArtistIDFormatIndex++;
            }
        }
    }

    /**
     * @dev Instantiates Artist Name Mapping
     * (May Need To Be Run Multiple Times Until All Artist Names Are Seeded)
     */
    function ____VRF4ExecuteArtistNameMapping(uint AmountToIterate) external onlyOwner
    {
        require(_VRFResponseStatus, "MPMX: Must Wait Until VRF Random Seed Has Been Returned");
        uint StartingIndex = NumbersIteratedUpon;
        for(NumbersIteratedUpon; NumbersIteratedUpon < StartingIndex + AmountToIterate; NumbersIteratedUpon++)
        {
            uint ArtistIndex = (uint(keccak256(abi.encode(randomResults, NumbersIteratedUpon))) % 10) + 1;
            if(!_ArtistNameMapped[ArtistIndex])
            {
                ArtistNames[_ArtistMapped] = _ArtistNames[ArtistIndex];
                _ArtistNameMapped[ArtistIndex] = true;
                _ArtistMapped++;
            }
        }
    }

    /*---------------------
     * INTERNAL FUNCTIONS *
    ----------------------*/

    /**
     * @dev Ends Mint Pass Sale On Sellout
     */
    function ___EndMintPassSale() internal
    {
        MintPassSale._ActiveBrightList = false;
        MintPassSale._ActivePublic = false;
    }

    /**
     * @dev Ends Mint Pack Sale On Sellout
     */
    function __EndMintPackSale() internal
    {
        MintPackSale._ActivePublic = false;
        MintPackSale._ActiveBrightList = false;
    }

    /**
     * @dev Callback function used by VRF Coordinator
     */
    function fulfillRandomness(bytes32 requestId, uint randomness) internal override 
    { 
        randomResults.push(randomness);
        _VRFResponseStatus = true;
        emit randomnessFulfilled(requestId, randomness);
    }

    /**
     * @dev Returns Base URI
     */
    function _baseURI() internal view virtual override returns (string memory) { return baseURI; }

    /*--------------------
     * LIVEMINT FUNCTION *
    ---------------------*/

    /**
     * @dev LiveMint Redeems Mint Pass If Not Already Burned & Sends Minted Work To Owner's Wallet
     */
    function _LiveMintBurn(uint TokenID) external returns(address)
    {
        require(msg.sender == CRYPTO_CITIZEN_LIVE_MINT, "MPMX: Sender Is Not Live Mint");
        address Recipient = ownerOf(TokenID);
        require(Recipient != address(0), "MPMX: Invalid Recipient");
        _burn(TokenID);
        return Recipient;
    }
}

// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "./interfaces/LinkTokenInterface.sol";

import "./VRFRequestIDBase.sol";

/** ****************************************************************************
 * @notice Interface for contracts using VRF randomness
 * *****************************************************************************
 * @dev PURPOSE
 *
 * @dev Reggie the Random Oracle (not his real job) wants to provide randomness
 * @dev to Vera the verifier in such a way that Vera can be sure he's not
 * @dev making his output up to suit himself. Reggie provides Vera a public key
 * @dev to which he knows the secret key. Each time Vera provides a seed to
 * @dev Reggie, he gives back a value which is computed completely
 * @dev deterministically from the seed and the secret key.
 *
 * @dev Reggie provides a proof by which Vera can verify that the output was
 * @dev correctly computed once Reggie tells it to her, but without that proof,
 * @dev the output is indistinguishable to her from a uniform random sample
 * @dev from the output space.
 *
 * @dev The purpose of this contract is to make it easy for unrelated contracts
 * @dev to talk to Vera the verifier about the work Reggie is doing, to provide
 * @dev simple access to a verifiable source of randomness.
 * *****************************************************************************
 * @dev USAGE
 *
 * @dev Calling contracts must inherit from VRFConsumerBase, and can
 * @dev initialize VRFConsumerBase's attributes in their constructor as
 * @dev shown:
 *
 * @dev   contract VRFConsumer {
 * @dev     constructor(<other arguments>, address _vrfCoordinator, address _link)
 * @dev       VRFConsumerBase(_vrfCoordinator, _link) public {
 * @dev         <initialization with other arguments goes here>
 * @dev       }
 * @dev   }
 *
 * @dev The oracle will have given you an ID for the VRF keypair they have
 * @dev committed to (let's call it keyHash), and have told you the minimum LINK
 * @dev price for VRF service. Make sure your contract has sufficient LINK, and
 * @dev call requestRandomness(keyHash, fee, seed), where seed is the input you
 * @dev want to generate randomness from.
 *
 * @dev Once the VRFCoordinator has received and validated the oracle's response
 * @dev to your request, it will call your contract's fulfillRandomness method.
 *
 * @dev The randomness argument to fulfillRandomness is the actual random value
 * @dev generated from your seed.
 *
 * @dev The requestId argument is generated from the keyHash and the seed by
 * @dev makeRequestId(keyHash, seed). If your contract could have concurrent
 * @dev requests open, you can use the requestId to track which seed is
 * @dev associated with which randomness. See VRFRequestIDBase.sol for more
 * @dev details. (See "SECURITY CONSIDERATIONS" for principles to keep in mind,
 * @dev if your contract could have multiple requests in flight simultaneously.)
 *
 * @dev Colliding `requestId`s are cryptographically impossible as long as seeds
 * @dev differ. (Which is critical to making unpredictable randomness! See the
 * @dev next section.)
 *
 * *****************************************************************************
 * @dev SECURITY CONSIDERATIONS
 *
 * @dev A method with the ability to call your fulfillRandomness method directly
 * @dev could spoof a VRF response with any random value, so it's critical that
 * @dev it cannot be directly called by anything other than this base contract
 * @dev (specifically, by the VRFConsumerBase.rawFulfillRandomness method).
 *
 * @dev For your users to trust that your contract's random behavior is free
 * @dev from malicious interference, it's best if you can write it so that all
 * @dev behaviors implied by a VRF response are executed *during* your
 * @dev fulfillRandomness method. If your contract must store the response (or
 * @dev anything derived from it) and use it later, you must ensure that any
 * @dev user-significant behavior which depends on that stored value cannot be
 * @dev manipulated by a subsequent VRF request.
 *
 * @dev Similarly, both miners and the VRF oracle itself have some influence
 * @dev over the order in which VRF responses appear on the blockchain, so if
 * @dev your contract could have multiple VRF requests in flight simultaneously,
 * @dev you must ensure that the order in which the VRF responses arrive cannot
 * @dev be used to manipulate your contract's user-significant behavior.
 *
 * @dev Since the ultimate input to the VRF is mixed with the block hash of the
 * @dev block in which the request is made, user-provided seeds have no impact
 * @dev on its economic security properties. They are only included for API
 * @dev compatability with previous versions of this contract.
 *
 * @dev Since the block hash of the block which contains the requestRandomness
 * @dev call is mixed into the input to the VRF *last*, a sufficiently powerful
 * @dev miner could, in principle, fork the blockchain to evict the block
 * @dev containing the request, forcing the request to be included in a
 * @dev different block with a different hash, and therefore a different input
 * @dev to the VRF. However, such an attack would incur a substantial economic
 * @dev cost. This cost scales with the number of blocks the VRF oracle waits
 * @dev until it calls responds to a request.
 */
abstract contract VRFConsumerBase is VRFRequestIDBase {
  /**
   * @notice fulfillRandomness handles the VRF response. Your contract must
   * @notice implement it. See "SECURITY CONSIDERATIONS" above for important
   * @notice principles to keep in mind when implementing your fulfillRandomness
   * @notice method.
   *
   * @dev VRFConsumerBase expects its subcontracts to have a method with this
   * @dev signature, and will call it once it has verified the proof
   * @dev associated with the randomness. (It is triggered via a call to
   * @dev rawFulfillRandomness, below.)
   *
   * @param requestId The Id initially returned by requestRandomness
   * @param randomness the VRF output
   */
  function fulfillRandomness(bytes32 requestId, uint256 randomness) internal virtual;

  /**
   * @dev In order to keep backwards compatibility we have kept the user
   * seed field around. We remove the use of it because given that the blockhash
   * enters later, it overrides whatever randomness the used seed provides.
   * Given that it adds no security, and can easily lead to misunderstandings,
   * we have removed it from usage and can now provide a simpler API.
   */
  uint256 private constant USER_SEED_PLACEHOLDER = 0;

  /**
   * @notice requestRandomness initiates a request for VRF output given _seed
   *
   * @dev The fulfillRandomness method receives the output, once it's provided
   * @dev by the Oracle, and verified by the vrfCoordinator.
   *
   * @dev The _keyHash must already be registered with the VRFCoordinator, and
   * @dev the _fee must exceed the fee specified during registration of the
   * @dev _keyHash.
   *
   * @dev The _seed parameter is vestigial, and is kept only for API
   * @dev compatibility with older versions. It can't *hurt* to mix in some of
   * @dev your own randomness, here, but it's not necessary because the VRF
   * @dev oracle will mix the hash of the block containing your request into the
   * @dev VRF seed it ultimately uses.
   *
   * @param _keyHash ID of public key against which randomness is generated
   * @param _fee The amount of LINK to send with the request
   *
   * @return requestId unique ID for this request
   *
   * @dev The returned requestId can be used to distinguish responses to
   * @dev concurrent requests. It is passed as the first argument to
   * @dev fulfillRandomness.
   */
  function requestRandomness(bytes32 _keyHash, uint256 _fee) internal returns (bytes32 requestId) {
    LINK.transferAndCall(vrfCoordinator, _fee, abi.encode(_keyHash, USER_SEED_PLACEHOLDER));
    // This is the seed passed to VRFCoordinator. The oracle will mix this with
    // the hash of the block containing this request to obtain the seed/input
    // which is finally passed to the VRF cryptographic machinery.
    uint256 vRFSeed = makeVRFInputSeed(_keyHash, USER_SEED_PLACEHOLDER, address(this), nonces[_keyHash]);
    // nonces[_keyHash] must stay in sync with
    // VRFCoordinator.nonces[_keyHash][this], which was incremented by the above
    // successful LINK.transferAndCall (in VRFCoordinator.randomnessRequest).
    // This provides protection against the user repeating their input seed,
    // which would result in a predictable/duplicate output, if multiple such
    // requests appeared in the same block.
    nonces[_keyHash] = nonces[_keyHash] + 1;
    return makeRequestId(_keyHash, vRFSeed);
  }

  LinkTokenInterface internal immutable LINK;
  address private immutable vrfCoordinator;

  // Nonces for each VRF key from which randomness has been requested.
  //
  // Must stay in sync with VRFCoordinator[_keyHash][this]
  mapping(bytes32 => uint256) /* keyHash */ /* nonce */
    private nonces;

  /**
   * @param _vrfCoordinator address of VRFCoordinator contract
   * @param _link address of LINK token contract
   *
   * @dev https://docs.chain.link/docs/link-token-contracts
   */
  constructor(address _vrfCoordinator, address _link) {
    vrfCoordinator = _vrfCoordinator;
    LINK = LinkTokenInterface(_link);
  }

  // rawFulfillRandomness is called by VRFCoordinator when it receives a valid VRF
  // proof. rawFulfillRandomness then calls fulfillRandomness, after validating
  // the origin of the call
  function rawFulfillRandomness(bytes32 requestId, uint256 randomness) external {
    require(msg.sender == vrfCoordinator, "Only VRFCoordinator can fulfill");
    fulfillRandomness(requestId, randomness);
  }
}

// SPDX-License-Identifier: MIT
/**
 * @dev: @brougkr
 */
// Interface For Mint Pass Option
pragma solidity 0.8.16;
interface IMPO 
{ 
    function _TransferOption(address Recipient, uint TokenID) external;
    function _RedeemOption(uint TokenID) external;
}

// SPDX-License-Identifier: MIT
// ERC721MP Contracts v3.3.0
// Creator: Chiru Labs

pragma solidity ^0.8.4;

import './IERC721MP.sol';
import '@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol';
import '@openzeppelin/contracts/utils/Address.sol';
import '@openzeppelin/contracts/utils/Context.sol';
import '@openzeppelin/contracts/utils/Strings.sol';
import '@openzeppelin/contracts/utils/introspection/ERC165.sol';

/**
 * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including
 * the Metadata extension. Built to optimize for lower gas during batch mints.
 *
 * Assumes serials are sequentially minted starting at _startTokenId() (defaults to 0, e.g. 0, 1, 2, 3..).
 *
 * Assumes that an owner cannot have more than 2**64 - 1 (max value of uint64) of supply.
 *
 * Assumes that the maximum token id cannot exceed 2**256 - 1 (max value of uint256).
 */
contract ERC721MP is Context, ERC165, IERC721MP {
    using Address for address;
    using Strings for uint256;

    // CryptoCitizenLiveMint Contract
    address public _Crypto_Citizen_Live_Mint;

    // Ensures Nobody Has Pending Approvals To Prevent Sniping Post-Artist-Reveal
    bool public _ArtistIDsRevealed;

    // The tokenId of the next token to be minted.
    uint256 internal _currentIndex;

    // The number of tokens burned.
    uint256 internal _burnCounter;

    // Token name
    string private _name;

    // Token symbol
    string private _symbol;

    // Mapping from token ID to ownership details
    // An empty struct value does not necessarily mean the token is unowned. See _ownershipOf implementation for details.
    mapping(uint256 => TokenOwnership) internal _ownerships;

    // Mapping owner address to address data
    mapping(address => AddressData) private _addressData;

    // Mapping from token ID to approved address
    mapping(uint256 => address) private _tokenApprovals;

    // Mapping from owner to operator approvals
    mapping(bool => mapping(address => mapping(address => bool))) private _operatorApprovals;

    constructor(string memory name_, string memory symbol_) {
        _name = name_;
        _symbol = symbol_;
        _currentIndex = _startTokenId();
    }

    /**
     * To change the starting tokenId, please override this function.
     */
    function _startTokenId() internal view virtual returns (uint256) {
        return 0;
    }

    /**
     * @dev Burned tokens are calculated here, use _totalMinted() if you want to count just minted tokens.
     */
    function totalSupply() public view override returns (uint256) {
        // Counter underflow is impossible as _burnCounter cannot be incremented
        // more than _currentIndex - _startTokenId() times
        unchecked {
            return _currentIndex - _burnCounter - _startTokenId();
        }
    }

    /**
     * Returns the total amount of tokens minted in the contract.
     */
    function _totalMinted() internal view returns (uint256) {
        // Counter underflow is impossible as _currentIndex does not decrement,
        // and it is initialized to _startTokenId()
        unchecked {
            return _currentIndex - _startTokenId();
        }
    }

    /**
     * @dev See {IERC165-supportsInterface}.
     */
    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {
        return
            interfaceId == type(IERC721).interfaceId ||
            interfaceId == type(IERC721Metadata).interfaceId ||
            super.supportsInterface(interfaceId);
    }

    /**
     * @dev See {IERC721-balanceOf}.
     */
    function balanceOf(address owner) public view override returns (uint256) {
        if (owner == address(0)) revert BalanceQueryForZeroAddress();
        return uint256(_addressData[owner].balance);
    }

    /**
     * Returns the number of tokens minted by `owner`.
     */
    function _numberMinted(address owner) internal view returns (uint256) {
        return uint256(_addressData[owner].numberMinted);
    }

    /**
     * Returns the number of tokens burned by or on behalf of `owner`.
     */
    function _numberBurned(address owner) internal view returns (uint256) {
        return uint256(_addressData[owner].numberBurned);
    }

    /**
     * Returns the auxillary data for `owner`. (e.g. number of whitelist mint slots used).
     */
    function _getAux(address owner) internal view returns (uint64) {
        return _addressData[owner].aux;
    }

    /**
     * Sets the auxillary data for `owner`. (e.g. number of whitelist mint slots used).
     * If there are multiple variables, please pack them into a uint64.
     */
    function _setAux(address owner, uint64 aux) internal {
        _addressData[owner].aux = aux;
    }

    /**
     * Gas spent here starts off proportional to the maximum mint batch size.
     * It gradually moves to O(1) as tokens get transferred around in the collection over time.
     */
    function _ownershipOf(uint256 tokenId) internal view returns (TokenOwnership memory) {
        uint256 curr = tokenId;

        unchecked {
            if (_startTokenId() <= curr) if (curr < _currentIndex) {
                TokenOwnership memory ownership = _ownerships[curr];
                if (!ownership.burned) {
                    if (ownership.addr != address(0)) {
                        return ownership;
                    }
                    // Invariant:
                    // There will always be an ownership that has an address and is not burned
                    // before an ownership that does not have an address and is not burned.
                    // Hence, curr will not underflow.
                    while (true) {
                        curr--;
                        ownership = _ownerships[curr];
                        if (ownership.addr != address(0)) {
                            return ownership;
                        }
                    }
                }
            }
        }
        revert OwnerQueryForNonexistentToken();
    }

    /**
     * @dev See {IERC721-ownerOf}.
     */
    function ownerOf(uint256 tokenId) public view override returns (address) {
        return _ownershipOf(tokenId).addr;
    }

    /**
     * @dev See {IERC721Metadata-name}.
     */
    function name() public view virtual override returns (string memory) {
        return _name;
    }

    /**
     * @dev See {IERC721Metadata-symbol}.
     */
    function symbol() public view virtual override returns (string memory) {
        return _symbol;
    }

    /**
     * @dev See {IERC721Metadata-tokenURI}.
     */
    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {
        if (!_exists(tokenId)) revert URIQueryForNonexistentToken();

        string memory baseURI = _baseURI();
        return bytes(baseURI).length != 0 ? string(abi.encodePacked(baseURI, tokenId.toString(), '.json')) : '';
    }

    /**
     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each
     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty
     * by default, can be overriden in child contracts.
     */
    function _baseURI() internal view virtual returns (string memory) { return ''; }

    /**
     * @dev See {IERC721-approve}.
     */
    function approve(address to, uint256 tokenId) public override {
        address owner = ERC721MP.ownerOf(tokenId);
        if (to == owner) revert ApprovalToCurrentOwner();

        if (_msgSender() != owner) if(!isApprovedForAll(owner, _msgSender())) {
            revert ApprovalCallerNotOwnerNorApproved();
        }

        _approve(to, tokenId, owner);
    }

    /**
     * @dev See {IERC721-getApproved}.
     */
    function getApproved(uint256 tokenId) public view override returns (address) {
        if (!_exists(tokenId)) revert ApprovalQueryForNonexistentToken();

        return _tokenApprovals[tokenId];
    }

    /**
     * @dev See {IERC721-setApprovalForAll}.
     */
    function setApprovalForAll(address operator, bool approved) public virtual override {
        if (operator == _msgSender()) revert ApproveToCaller();

        _operatorApprovals[_ArtistIDsRevealed][_msgSender()][operator] = approved;
        emit ApprovalForAll(_msgSender(), operator, approved);
    }

    /**
     * @dev See {IERC721-isApprovedForAll}.
     */
    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {
        return _operatorApprovals[_ArtistIDsRevealed][owner][operator];
    }

    /**
     * @dev See {IERC721-transferFrom}.
     */
    function transferFrom(
        address from,
        address to,
        uint256 tokenId
    ) public virtual override {
        _transfer(from, to, tokenId);
    }

    /**
     * @dev See {IERC721-safeTransferFrom}.
     */
    function safeTransferFrom(
        address from,
        address to,
        uint256 tokenId
    ) public virtual override {
        safeTransferFrom(from, to, tokenId, '');
    }

    /**
     * @dev See {IERC721-safeTransferFrom}.
     */
    function safeTransferFrom(
        address from,
        address to,
        uint256 tokenId,
        bytes memory _data
    ) public virtual override {
        _transfer(from, to, tokenId);
        if (to.isContract()) if(!_checkContractOnERC721Received(from, to, tokenId, _data)) {
            revert TransferToNonERC721ReceiverImplementer();
        }
    }

    /**
     * @dev Returns whether `tokenId` exists.
     *
     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.
     *
     * Tokens start existing when they are minted (`_mint`),
     */
    function _exists(uint256 tokenId) internal view returns (bool) {
        return _startTokenId() <= tokenId && tokenId < _currentIndex && !_ownerships[tokenId].burned;
    }

    /**
     * @dev Mints `quantity` tokens and transfers them to `to`.
     *
     * Requirements:
     *
     * - `to` cannot be the zero address.
     * - `quantity` must be greater than 0.
     *
     * Emits a {Transfer} event.
     */
    function _mint(address to, uint256 quantity) internal {
        uint256 startTokenId = _currentIndex;
        if (to == address(0)) revert MintToZeroAddress();
        if (quantity == 0) revert MintZeroQuantity();

        _beforeTokenTransfers(address(0), to, startTokenId, quantity);

        // Overflows are incredibly unrealistic.
        // balance or numberMinted overflow if current value of either + quantity > 1.8e19 (2**64) - 1
        // updatedIndex overflows if _currentIndex + quantity > 1.2e77 (2**256) - 1
        unchecked {
            _addressData[to].balance += uint64(quantity);
            _addressData[to].numberMinted += uint64(quantity);

            _ownerships[startTokenId].addr = to;
            _ownerships[startTokenId].startTimestamp = uint64(block.timestamp);

            uint256 updatedIndex = startTokenId;
            uint256 end = updatedIndex + quantity;

            do {
                emit Transfer(address(0), to, updatedIndex++);
            } while (updatedIndex < end);

            _currentIndex = updatedIndex;
        }
        _afterTokenTransfers(address(0), to, startTokenId, quantity);
    }

    /**
     * @dev Transfers `tokenId` from `from` to `to`.
     *
     * Requirements:
     *
     * - `to` cannot be the zero address.
     * - `tokenId` token must be owned by `from`.
     *
     * Emits a {Transfer} event.
     */
    function _transfer(
        address from,
        address to,
        uint256 tokenId
    ) private {
        TokenOwnership memory prevOwnership = _ownershipOf(tokenId);
        if (prevOwnership.addr != from) revert TransferFromIncorrectOwner();
        bool isApprovedOrOwner = (
            _msgSender() == from 
            ||
            isApprovedForAll(from, _msgSender()) 
            ||
            getApproved(tokenId) == _msgSender()
        );

        if (!isApprovedOrOwner) revert TransferCallerNotOwnerNorApproved();
        if (to == address(0)) revert TransferToZeroAddress();

        _beforeTokenTransfers(from, to, tokenId, 1);

        // Clear approvals from the previous owner
        _approve(address(0), tokenId, from);

        // Underflow of the sender's balance is impossible because we check for
        // ownership above and the recipient's balance can't realistically overflow.
        // Counter overflow is incredibly unrealistic as tokenId would have to be 2**256.
        unchecked {
            _addressData[from].balance -= 1;
            _addressData[to].balance += 1;

            TokenOwnership storage currSlot = _ownerships[tokenId];
            currSlot.addr = to;
            currSlot.startTimestamp = uint64(block.timestamp);

            // If the ownership slot of tokenId+1 is not explicitly set, that means the transfer initiator owns it.
            // Set the slot of tokenId+1 explicitly in storage to maintain correctness for ownerOf(tokenId+1) calls.
            uint256 nextTokenId = tokenId + 1;
            TokenOwnership storage nextSlot = _ownerships[nextTokenId];
            if (nextSlot.addr == address(0)) {
                // This will suffice for checking _exists(nextTokenId),
                // as a burned slot cannot contain the zero address.
                if (nextTokenId != _currentIndex) {
                    nextSlot.addr = from;
                    nextSlot.startTimestamp = prevOwnership.startTimestamp;
                }
            }
        }

        emit Transfer(from, to, tokenId);
        _afterTokenTransfers(from, to, tokenId, 1);
    }

    /**
     * @dev Equivalent to `_burn(tokenId, false)`.
     */
    function _burn(uint256 tokenId) internal virtual {
        _burn(tokenId, false);
    }

    /**
     * @dev Destroys `tokenId`.
     * The approval is cleared when the token is burned.
     *
     * Requirements:
     *
     * - `tokenId` must exist.
     *
     * Emits a {Transfer} event.
     */
    function _burn(uint256 tokenId, bool approvalCheck) internal virtual {
        TokenOwnership memory prevOwnership = _ownershipOf(tokenId);

        address from = prevOwnership.addr;

        if (approvalCheck) {
            bool isApprovedOrOwner = (
                _msgSender() == from 
                ||
                isApprovedForAll(from, _msgSender()) 
                ||
                getApproved(tokenId) == _msgSender()
                ||
                _msgSender() == _Crypto_Citizen_Live_Mint
            );

            if (!isApprovedOrOwner) revert TransferCallerNotOwnerNorApproved();
        }

        _beforeTokenTransfers(from, address(0), tokenId, 1);

        // Clear approvals from the previous owner
        _approve(address(0), tokenId, from);

        // Underflow of the sender's balance is impossible because we check for
        // ownership above and the recipient's balance can't realistically overflow.
        // Counter overflow is incredibly unrealistic as tokenId would have to be 2**256.
        unchecked {
            AddressData storage addressData = _addressData[from];
            addressData.balance -= 1;
            addressData.numberBurned += 1;

            // Keep track of who burned the token, and the timestamp of burning.
            TokenOwnership storage currSlot = _ownerships[tokenId];
            currSlot.addr = from;
            currSlot.startTimestamp = uint64(block.timestamp);
            currSlot.burned = true;

            // If the ownership slot of tokenId+1 is not explicitly set, that means the burn initiator owns it.
            // Set the slot of tokenId+1 explicitly in storage to maintain correctness for ownerOf(tokenId+1) calls.
            uint256 nextTokenId = tokenId + 1;
            TokenOwnership storage nextSlot = _ownerships[nextTokenId];
            if (nextSlot.addr == address(0)) {
                // This will suffice for checking _exists(nextTokenId),
                // as a burned slot cannot contain the zero address.
                if (nextTokenId != _currentIndex) {
                    nextSlot.addr = from;
                    nextSlot.startTimestamp = prevOwnership.startTimestamp;
                }
            }
        }

        emit Transfer(from, address(0), tokenId);
        _afterTokenTransfers(from, address(0), tokenId, 1);

        // Overflow not possible, as _burnCounter cannot be exceed _currentIndex times.
        unchecked {
            _burnCounter++;
        }
    }

    /**
     * @dev Approve `to` to operate on `tokenId`
     *
     * Emits a {Approval} event.
     */
    function _approve(
        address to,
        uint256 tokenId,
        address owner
    ) private {
        _tokenApprovals[tokenId] = to;
        emit Approval(owner, to, tokenId);
    }

    /**
     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target contract.
     *
     * @param from address representing the previous owner of the given token ID
     * @param to target address that will receive the tokens
     * @param tokenId uint256 ID of the token to be transferred
     * @param _data bytes optional data to send along with the call
     * @return bool whether the call correctly returned the expected magic value
     */
    function _checkContractOnERC721Received(
        address from,
        address to,
        uint256 tokenId,
        bytes memory _data
    ) private returns (bool) {
        try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, _data) returns (bytes4 retval) {
            return retval == IERC721Receiver(to).onERC721Received.selector;
        } catch (bytes memory reason) {
            if (reason.length == 0) {
                revert TransferToNonERC721ReceiverImplementer();
            } else {
                assembly {
                    revert(add(32, reason), mload(reason))
                }
            }
        }
    }

    /**
     * @dev Hook that is called before a set of serially-ordered token ids are about to be transferred. This includes minting.
     * And also called before burning one token.
     *
     * startTokenId - the first token id to be transferred
     * quantity - the amount to be transferred
     *
     * Calling conditions:
     *
     * - When `from` and `to` are both non-zero, `from`'s `tokenId` will be
     * transferred to `to`.
     * - When `from` is zero, `tokenId` will be minted for `to`.
     * - When `to` is zero, `tokenId` will be burned by `from`.
     * - `from` and `to` are never both zero.
     */
    function _beforeTokenTransfers(
        address from,
        address to,
        uint256 startTokenId,
        uint256 quantity
    ) internal virtual {}

    /**
     * @dev Hook that is called after a set of serially-ordered token ids have been transferred. This includes
     * minting.
     * And also called after one token has been burned.
     *
     * startTokenId - the first token id to be transferred
     * quantity - the amount to be transferred
     *
     * Calling conditions:
     *
     * - When `from` and `to` are both non-zero, `from`'s `tokenId` has been
     * transferred to `to`.
     * - When `from` is zero, `tokenId` has been minted for `to`.
     * - When `to` is zero, `tokenId` has been burned by `from`.
     * - `from` and `to` are never both zero.
     */
    function _afterTokenTransfers(
        address from,
        address to,
        uint256 startTokenId,
        uint256 quantity
    ) internal virtual {}
}

// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

interface LinkTokenInterface {
  function allowance(address owner, address spender) external view returns (uint256 remaining);

  function approve(address spender, uint256 value) external returns (bool success);

  function balanceOf(address owner) external view returns (uint256 balance);

  function decimals() external view returns (uint8 decimalPlaces);

  function decreaseApproval(address spender, uint256 addedValue) external returns (bool success);

  function increaseApproval(address spender, uint256 subtractedValue) external;

  function name() external view returns (string memory tokenName);

  function symbol() external view returns (string memory tokenSymbol);

  function totalSupply() external view returns (uint256 totalTokensIssued);

  function transfer(address to, uint256 value) external returns (bool success);

  function transferAndCall(
    address to,
    uint256 value,
    bytes calldata data
  ) external returns (bool success);

  function transferFrom(
    address from,
    address to,
    uint256 value
  ) external returns (bool success);
}

// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract VRFRequestIDBase {
  /**
   * @notice returns the seed which is actually input to the VRF coordinator
   *
   * @dev To prevent repetition of VRF output due to repetition of the
   * @dev user-supplied seed, that seed is combined in a hash with the
   * @dev user-specific nonce, and the address of the consuming contract. The
   * @dev risk of repetition is mostly mitigated by inclusion of a blockhash in
   * @dev the final seed, but the nonce does protect against repetition in
   * @dev requests which are included in a single block.
   *
   * @param _userSeed VRF seed input provided by user
   * @param _requester Address of the requesting contract
   * @param _nonce User-specific nonce at the time of the request
   */
  function makeVRFInputSeed(
    bytes32 _keyHash,
    uint256 _userSeed,
    address _requester,
    uint256 _nonce
  ) internal pure returns (uint256) {
    return uint256(keccak256(abi.encode(_keyHash, _userSeed, _requester, _nonce)));
  }

  /**
   * @notice Returns the id for this request
   * @param _keyHash The serviceAgreement ID to be used for this request
   * @param _vRFInputSeed The seed to be passed directly to the VRF
   * @return The id for this request
   *
   * @dev Note that _vRFInputSeed is not the seed passed by the consuming
   * @dev contract, but the one generated by makeVRFInputSeed
   */
  function makeRequestId(bytes32 _keyHash, uint256 _vRFInputSeed) internal pure returns (bytes32) {
    return keccak256(abi.encodePacked(_keyHash, _vRFInputSeed));
  }
}

// SPDX-License-Identifier: MIT
// ERC721MP Contracts v3.3.0
// Creator: Chiru Labs

pragma solidity ^0.8.4;

import '@openzeppelin/contracts/token/ERC721/IERC721.sol';
import '@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol';

/**
 * @dev Interface of an ERC721MP compliant contract.
 */
interface IERC721MP is IERC721, IERC721Metadata {
    /**
     * The caller must own the token or be an approved operator.
     */
    error ApprovalCallerNotOwnerNorApproved();

    /**
     * The token does not exist.
     */
    error ApprovalQueryForNonexistentToken();

    /**
     * The caller cannot approve to their own address.
     */
    error ApproveToCaller();

    /**
     * The caller cannot approve to the current owner.
     */
    error ApprovalToCurrentOwner();

    /**
     * Cannot query the balance for the zero address.
     */
    error BalanceQueryForZeroAddress();

    /**
     * Cannot mint to the zero address.
     */
    error MintToZeroAddress();

    /**
     * The quantity of tokens minted must be more than zero.
     */
    error MintZeroQuantity();

    /**
     * The token does not exist.
     */
    error OwnerQueryForNonexistentToken();

    /**
     * The caller must own the token or be an approved operator.
     */
    error TransferCallerNotOwnerNorApproved();

    /**
     * The token must be owned by `from`.
     */
    error TransferFromIncorrectOwner();

    /**
     * Cannot safely transfer to a contract that does not implement the ERC721Receiver interface.
     */
    error TransferToNonERC721ReceiverImplementer();

    /**
     * Cannot transfer to the zero address.
     */
    error TransferToZeroAddress();

    /**
     * The token does not exist.
     */
    error URIQueryForNonexistentToken();

    // Compiler will pack this into a single 256bit word.
    struct TokenOwnership {
        // The address of the owner.
        address addr;
        // Keeps track of the start time of ownership with minimal overhead for tokenomics.
        uint64 startTimestamp;
        // Whether the token has been burned.
        bool burned;
    }

    // Compiler will pack this into a single 256bit word.
    struct AddressData {
        // Realistically, 2**64-1 is more than enough.
        uint64 balance;
        // Keeps track of mint count with minimal overhead for tokenomics.
        uint64 numberMinted;
        // Keeps track of burn count with minimal overhead for tokenomics.
        uint64 numberBurned;
        // For miscellaneous variable(s) pertaining to the address
        // (e.g. number of whitelist mint slots used).
        // If there are multiple variables, please pack them into a uint64.
        uint64 aux;
    }

    /**
     * @dev Returns the total amount of tokens stored by the contract.
     * 
     * Burned tokens are calculated here, use `_totalMinted()` if you want to count just minted tokens.
     */
    function totalSupply() external view returns (uint256);
}

//SPDX-License-Identifier: MIT
/*@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                     @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@          @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                 @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@              @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@              @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                 @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                     @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@*/
/**
 * @dev: @brougkr
 */
pragma solidity 0.8.16;
import {Ownable} from "@openzeppelin/contracts/access/Ownable.sol";
import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import {ReentrancyGuard} from "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import {ERC721MP} from "./ERC721MP.sol";

contract mintpass is ERC721MP, Ownable, ReentrancyGuard
{
    string baseURI = 'ipfs://BING_BONG/';

    /**
     * @dev Constructor 
     */
    constructor() ERC721MP("mintpass", "mintpass") { _mint(msg.sender, 10); }
    
    /****************** 
    *    OnlyMinter   *
    *******************/

    /**
     * @dev Mints test NFTs
     */
    function Mint(address Recipient, uint Amount) public { _mint(Recipient, Amount); }

    /****************** 
    *    OnlyOwner    *
    *******************/

    /**
     * @dev Withdraws Ether From Contract To Message Sender
     */
    function __Withdraw() external onlyOwner { payable(msg.sender).transfer(address(this).balance); }

    /**
     * @dev Withdraws Ether From Contract To Address
     */
    function __WithdrawToAddress(address payable recipient) external onlyOwner 
    {
        uint balance = address(this).balance;
        (bool success, ) = recipient.call{value: balance}("");
        require(success, "Unable to Withdraw, Recipient May Have Reverted");
    }

    /**
     * @dev Withdraws ERC20 From Contract To Address
     */
    function __WithdrawERC20ToAddress(address Recipient, address ContractAddress) external onlyOwner
    {
        IERC20 ERC20 = IERC20(ContractAddress);
        ERC20.transferFrom(address(this), Recipient, ERC20.balanceOf(address(this)));
    }

    /****************** 
    *  INTERNAL VIEW  *
    ******************/

    /**
     * @dev Returns Base URI
     */
    function _baseURI() internal view virtual override returns (string memory) { return baseURI; }
}

//SPDX-License-Identifier: MIT
/*@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                     @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@          @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                 @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@              @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@              @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                 @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                     @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@*/
/**
 * @dev: @brougkr
 */
pragma solidity 0.8.16;
import {Ownable} from "@openzeppelin/contracts/access/Ownable.sol";
import {ReentrancyGuard} from "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import {MerkleProof} from "@openzeppelin/contracts/utils/cryptography/MerkleProof.sol";
import {IERC721} from "@openzeppelin/contracts/token/ERC721/IERC721.sol";
import {IERC1155} from "@openzeppelin/contracts/token/ERC1155/IERC1155.sol";
import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import {CTZNPlugin, ICTZN} from "./CTZNPlugin.sol";

contract Marketplace is Ownable, ReentrancyGuard, CTZNPlugin
{
    /***************************/
    /********** STRUCT *********/
    /***************************/
    
    struct Sale
    {
        string Name;
        uint PriceBrightList;
        uint PricePublic;
        uint StartingIndex;
        uint EndingIndex;
        uint PurchaseableAmountBrightList;
        uint PurchaseableAmountPublic;
        uint ERC_TYPE;
        address ContractAddress;
        address Operator;
        bytes32 Root;
        bool ActivePublic;
        bool ActiveBrightList;
        bool AllowMultiplePurchases;
    }

    /***************************/
    /********* MAPPINGS ********/
    /***************************/

    mapping(uint => Sale) private Sales;
    mapping(uint => uint) public SaleProceeds;
    mapping(address => bytes32) public BRTOperators;
    mapping(uint => mapping(address => bool)) public MarketplacePurchased;
    mapping(uint => mapping(address => uint)) public PurchasedAmountBrightList;
    mapping(uint => mapping(address => uint)) public PurchasedAmountPublic;

    /***************************/
    /********** EVENTS *********/
    /***************************/

    /**
     * @dev Emitted When A BrightList Purchase Occurs
     */
    event MarketplacePurchaseEventBrightList(address indexed recipientAddress, uint indexed SaleIndex, uint amount);

    /**
     * @dev Emitted When A Public Purchase Occurs
     */
    event MarketplacePurchaseEvent(address indexed recipientAddress, uint indexed SaleIndex, uint amount);

    /**
     * @dev Emitted When A Sale Has Started
     */
    event SaleStarted(
        string Name,
        address ContractAddress, 
        bytes32 RootHash, 
        address Operator, 
        bool ActivePublic,
        bool ActiveBrightList,
        bool AllowMultiplePurchases
    );

    /**
     * @dev Emitted When A Batch Of Sales Have Been Initialized
     */
    event SalesStarted(uint StartingSaleIndex, uint EndingSaleIndex);

    /**
     * @dev Emitted When Various State Variables Are Modified
     */
    event SaleEnded(uint SaleIndex);
    event SaleChangedName(uint indexed SaleIndex, string OldName, string NewName);
    event SaleChangedStartingIndex(uint indexed SaleIndex, uint OldStartingIndex, uint NewStartingIndex);
    event SaleChangedEndingIndex(uint indexed SaleIndex, uint OldEndingIndex, uint NewEndingIndex);
    event SaleChangedAllocationPublic(uint indexed SaleIndex, uint OldAllocation, uint NewAllocation);
    event SaleChangedAllocationBrightList(uint indexed SaleIndex, uint OldAllocation, uint NewAllocation);
    event SaleChangedPriceBrightList(uint indexed SaleIndex, uint OldPrice, uint NewPrice);
    event SaleChangedPricePublic(uint indexed SaleIndex, uint OldPrice, uint NewPrice);
    event SaleChangedERC_TYPE(uint indexed SaleIndex, uint OLD_ERC_TYPE, uint NEW_ERC_TYPE);
    event SaleChangedContract(uint indexed SaleIndex, address OldContract, address NewContract);
    event SaleChangedRoot(uint indexed SaleIndex, bytes32 OldRoot, bytes32 NewRoot);
    event SaleChangedOperator(uint indexed SaleIndex, address OldOperator, address NewOperator);
    event SaleChangedActiveState(uint indexed SaleIndex, bool OldState, bool NewState);
    event SaleChangedActiveStateBrightList(uint indexed SaleIndex, bool OldState, bool NewState);
    event SaleChangedActiveStatesPublic(uint[] SaleIndexes, bool[] States);
    event SaleChangedActiveStatesBrightList(uint[] SaleIndexes, bool[] States);

    /**
     * @dev Emitted When BRT Multisig Adds Or Removes An Operator
     */
    event OperatorAdded(address Operator);
    event OperatorRemoved(address Operator);

    /**
     * @dev Amount Of Unique Marketplace Sales
     */
    uint public UniqueSaleIndex;

    /**
     * @dev BRT Operator Roles
     */
    bytes32 private immutable _OPERATOR = keccak256("OPERATOR");
    bytes32 private immutable _DEACTIVATED = 0x0;

    /**
     * @dev Constructor
     */
    constructor() 
    { 
        BRTOperators[0x5778B0B140Fa7a62B96c193cC8621e6E96c088A5] = _OPERATOR; //brougkr
        BRTOperators[0x18B7511938FBe2EE08ADf3d4A24edB00A5C9B783] = _OPERATOR; //phil.brightmoments.eth
        BRTOperators[0xbf001FF749b7E793bbb1A612d09124470b9179A7] = _OPERATOR; //future
    } 

    /***************************/
    /***** PUBLIC FUNCTIONS ****/
    /***************************/

    /**
     * @dev Marketplace Purchase Public Sale
     */
    function MarketplacePurchase(uint SaleIndex, uint Amount) public payable nonReentrant
    { 
        require(Sales[SaleIndex].ActivePublic, "Requested Sale Is Not Available For Public Purchases");
        require(Sales[SaleIndex].StartingIndex <= Sales[SaleIndex].EndingIndex, "Sold Out");
        require(
            PurchasedAmountPublic[SaleIndex][msg.sender] + Amount <= Sales[SaleIndex].PurchaseableAmountPublic,
            "User Has Used Up All Of Public Allocation For This Sale Index"
        );
        if(!Sales[SaleIndex].AllowMultiplePurchases) { require(!MarketplacePurchased[SaleIndex][msg.sender], "User Has Already Purchased This Sale Index"); }
        require(msg.value == Sales[SaleIndex].PricePublic * Amount && Amount > 0, "Incorrect Ether Amount Or Token Amount Sent For Purchase");
        if(!MarketplacePurchased[SaleIndex][msg.sender]) { MarketplacePurchased[SaleIndex][msg.sender] = true; }
        PurchasedAmountPublic[SaleIndex][msg.sender] += Amount;
        for(uint i; i < Amount; i++)
        {
            if(Sales[SaleIndex].ERC_TYPE == 721)
            {
                IERC721(Sales[SaleIndex].ContractAddress).transferFrom(
                    Sales[SaleIndex].Operator, 
                    msg.sender, 
                    Sales[SaleIndex].StartingIndex
                );
            }
            else if(Sales[SaleIndex].ERC_TYPE == 1155)
            {
                IERC1155(Sales[SaleIndex].ContractAddress).safeTransferFrom(
                    Sales[SaleIndex].Operator, 
                    msg.sender, 
                    Sales[SaleIndex].StartingIndex, 
                    1, 
                    "BRT"
                );
            }
            Sales[SaleIndex].StartingIndex++;
        }
        SaleProceeds[SaleIndex] += msg.value;
        ICTZN(CTZN).IncrementCTZN(msg.sender, _RewardRates[0]); // Increments $CTZN rewards
        emit MarketplacePurchaseEvent(msg.sender, SaleIndex, Amount);
    }

    /**
     * @dev Marketplace Purchase BrightList Sale
     */
    function MarketplacePurchaseBrightList(uint SaleIndex, uint Amount, bytes32[] calldata Proof) public payable nonReentrant
    {
        require(Sales[SaleIndex].ActiveBrightList, "Requested Sale Is Not Available For BrightList Purchases");
        require(Sales[SaleIndex].StartingIndex <= Sales[SaleIndex].EndingIndex, "Sold Out");
        require(msg.value == Sales[SaleIndex].PriceBrightList * Amount && Amount > 0, "Incorrect Ether Amount Or Token Amount Sent For Purchase");
        require(viewBrightListAllocation(msg.sender, SaleIndex, Proof), "User Is Not On BrightList");
        require(
            PurchasedAmountBrightList[SaleIndex][msg.sender] + Amount <= Sales[SaleIndex].PurchaseableAmountBrightList,
            "User Has Used Up All BrightList Allocation For This Sale Index"
        );
        if(!Sales[SaleIndex].AllowMultiplePurchases) { require(!MarketplacePurchased[SaleIndex][msg.sender], "User Has Already Purchased This Sale Index"); }
        if(!MarketplacePurchased[SaleIndex][msg.sender]) { MarketplacePurchased[SaleIndex][msg.sender] = true; }
        PurchasedAmountBrightList[SaleIndex][msg.sender] += Amount;    
        for(uint i; i < Amount; i++)
        {
            if(Sales[SaleIndex].ERC_TYPE == 721)
            {
                IERC721(Sales[SaleIndex].ContractAddress).transferFrom(
                    Sales[SaleIndex].Operator,
                    msg.sender, 
                    Sales[SaleIndex].StartingIndex
                );
            }
            else if(Sales[SaleIndex].ERC_TYPE == 1155)
            {
                IERC1155(Sales[SaleIndex].ContractAddress).safeTransferFrom(
                    Sales[SaleIndex].Operator,
                    msg.sender, 
                    Sales[SaleIndex].StartingIndex, 
                    1, 
                    "BRT"
                );
            }
            Sales[SaleIndex].StartingIndex++;
        }
        SaleProceeds[SaleIndex] += msg.value;
        ICTZN(CTZN).IncrementCTZN(msg.sender, _RewardRates[1]); // Increments $CTZN rewards For BrightList Purchase
        emit MarketplacePurchaseEventBrightList(msg.sender, SaleIndex, Amount);
    }

    /***************************/
    /**** OPERATOR COMMANDS ****/
    /***************************/

    /**
     * @dev Sets Up A New Sale
     * note: `Price` Is Input In WEI Due To Ethereum EVM. For Example, 1 ETH = 1000000000000000000 WEI
     * note: `ERC_TYPE` Is (`721` for ERC721) || (`1155` for ERC1155)
     * note: `ContractAddress` Is The NFT Contract Address
     * note: `RootHash` Is Merkle Root Hash
     * note: `Operator` Is The Wallet Providing The NFTs For Sale. They Will Have To setApprovalForAll() On This Contract
     * note: `Public` & `AllowMultiplePurchases` Are Either `true` or `false`
     */
    function _StartSale(Sale memory NewSaleInstance) external onlyBRTOperator
    {
        //Checks Passed Variables
        require(
            NewSaleInstance.ERC_TYPE == 721 || NewSaleInstance.ERC_TYPE == 1155,
            "Incorrect ERC Type. (721 for ERC721) or (1155 for ERC1155)"
        );

        //Auto-Increments The Unique Sale Index
        UniqueSaleIndex++; 
        
        //Assigns State Variables To The New Sale Instance
        Sales[UniqueSaleIndex].Name = NewSaleInstance.Name;
        Sales[UniqueSaleIndex].PriceBrightList = NewSaleInstance.PriceBrightList;
        Sales[UniqueSaleIndex].PricePublic = NewSaleInstance.PricePublic;
        Sales[UniqueSaleIndex].StartingIndex = NewSaleInstance.StartingIndex;
        Sales[UniqueSaleIndex].EndingIndex = NewSaleInstance.EndingIndex;
        Sales[UniqueSaleIndex].PurchaseableAmountBrightList = NewSaleInstance.PurchaseableAmountBrightList;
        Sales[UniqueSaleIndex].PurchaseableAmountPublic = NewSaleInstance.PurchaseableAmountPublic;
        Sales[UniqueSaleIndex].ERC_TYPE = NewSaleInstance.ERC_TYPE;
        Sales[UniqueSaleIndex].ContractAddress = NewSaleInstance.ContractAddress;
        Sales[UniqueSaleIndex].Operator = NewSaleInstance.Operator;
        Sales[UniqueSaleIndex].Root = NewSaleInstance.Root;
        Sales[UniqueSaleIndex].ActivePublic = NewSaleInstance.ActivePublic;
        Sales[UniqueSaleIndex].ActiveBrightList = NewSaleInstance.ActiveBrightList;
        Sales[UniqueSaleIndex].AllowMultiplePurchases = NewSaleInstance.AllowMultiplePurchases;
        
        //Emits Base Data Of The New Sale Instance
        emit SaleStarted(
            Sales[UniqueSaleIndex].Name,
            Sales[UniqueSaleIndex].ContractAddress, 
            Sales[UniqueSaleIndex].Root, 
            Sales[UniqueSaleIndex].Operator, 
            Sales[UniqueSaleIndex].ActivePublic,
            Sales[UniqueSaleIndex].ActiveBrightList,
            Sales[UniqueSaleIndex].AllowMultiplePurchases
        );
    }

    /**
     * @dev Batch Startes Multiple Sales
     */
    function _StartSales(Sale[] memory NewSaleInstance) external onlyBRTOperator   
    {
        uint StartingSaleIndex = UniqueSaleIndex;
        for(uint i; i < NewSaleInstance.length; i++)
        {
            //Checks Passed Variables
            require(
                NewSaleInstance[i].ERC_TYPE == 721 || NewSaleInstance[i].ERC_TYPE == 1155,
                "Please Enter Valid ERC-TYPE, (721 for ERC-721), (1155 for ERC-1155)"
            );        

            //Auto Increments Index    
            UniqueSaleIndex++; 

            //Assigns State Variables To The New Sale Instance
            Sales[UniqueSaleIndex].Name = NewSaleInstance[i].Name;
            Sales[UniqueSaleIndex].PriceBrightList = NewSaleInstance[i].PriceBrightList;
            Sales[UniqueSaleIndex].PricePublic = NewSaleInstance[i].PricePublic;
            Sales[UniqueSaleIndex].StartingIndex = NewSaleInstance[i].StartingIndex;
            Sales[UniqueSaleIndex].EndingIndex = NewSaleInstance[i].EndingIndex;
            Sales[UniqueSaleIndex].PurchaseableAmountBrightList = NewSaleInstance[i].PurchaseableAmountBrightList;
            Sales[UniqueSaleIndex].PurchaseableAmountPublic = NewSaleInstance[i].PurchaseableAmountPublic;
            Sales[UniqueSaleIndex].ERC_TYPE = NewSaleInstance[i].ERC_TYPE;
            Sales[UniqueSaleIndex].ContractAddress = NewSaleInstance[i].ContractAddress;
            Sales[UniqueSaleIndex].Operator = NewSaleInstance[i].Operator;
            Sales[UniqueSaleIndex].Root = NewSaleInstance[i].Root;
            Sales[UniqueSaleIndex].ActivePublic = NewSaleInstance[i].ActivePublic;
            Sales[UniqueSaleIndex].ActiveBrightList = NewSaleInstance[i].ActiveBrightList;
            Sales[UniqueSaleIndex].AllowMultiplePurchases = NewSaleInstance[i].AllowMultiplePurchases;
        }
        emit SalesStarted(StartingSaleIndex, UniqueSaleIndex);
    }

    /**
     * @dev Changes BrightList Sale Name `Name` At Index `SaleIndex`
     * note: This Is The Name Of The Sale
     */
    function _ChangeSaleName(uint SaleIndex, string memory Name) external onlyBRTOperator 
    { 
        string memory OldName = Sales[SaleIndex].Name;
        Sales[SaleIndex].Name = Name; 
        emit SaleChangedName(SaleIndex, OldName, Name);
    }
    
    /**
     * @dev Changes BrightList StartingIndex `Index` At Index `SaleIndex`
     * note: This Is The Starting Token ID
     */
    function _ChangeSaleStartingIndex(uint SaleIndex, uint Index) external onlyBRTOperator 
    { 
        uint OldStartingIndex = Sales[SaleIndex].StartingIndex;
        Sales[SaleIndex].StartingIndex = Index; 
        emit SaleChangedStartingIndex(SaleIndex, OldStartingIndex, Index);
    }

    /**
     * @dev Changes BrightList EndingIndex `Index` At Index `SaleIndex`
     * note: This Is The Ending Token ID
     */
    function _ChangeSaleEndingIndex(uint SaleIndex, uint Index) external onlyBRTOperator 
    { 
        uint OldEndingIndex = Sales[SaleIndex].EndingIndex;
        Sales[SaleIndex].EndingIndex = Index; 
        emit SaleChangedEndingIndex(SaleIndex, OldEndingIndex, Index);
    }

    /**
     * @dev Changes Brightlist Public Purchasable Amount `Amount` At Index `SaleIndex`
     * note: This Is The Public Allocation
     */
    function _ChangeSaleAllocationPublic(uint SaleIndex, uint Amount) external onlyBRTOperator 
    {
        uint OldAllocation = Sales[SaleIndex].PurchaseableAmountBrightList; 
        Sales[SaleIndex].PurchaseableAmountPublic = Amount; 
        emit SaleChangedAllocationPublic(SaleIndex, OldAllocation, Amount);
    }
    
    /**
     * @dev Changes Brightlist Purchasable Amount `Amount` At Index `SaleIndex`
     * note: This Is The BrightList Allocation
     */
    function _ChangeSaleAllocationBrightList(uint SaleIndex, uint Amount) external onlyBRTOperator 
    {
        uint OldAllocation = Sales[SaleIndex].PurchaseableAmountBrightList; 
        Sales[SaleIndex].PurchaseableAmountBrightList = Amount; 
        emit SaleChangedAllocationBrightList(SaleIndex, OldAllocation, Amount);
    }

    /**
     * @dev Changes Sale Price Public Amount `Price` At Index `SaleIndex`
     * note: This Is Input In WEI Not In Ether. 1 ETH = 1000000000000000000 WEI
     */
    function _ChangeSalePricePublic(uint SaleIndex, uint Price) external onlyBRTOperator 
    { 
        uint OldPrice = Sales[SaleIndex].PriceBrightList; 
        Sales[SaleIndex].PricePublic = Price;
        emit SaleChangedPricePublic(SaleIndex, OldPrice, Price);
    }

    /**
     * @dev Changes Sale Price BrightList Amount `Price` At Index `SaleIndex`
     * note: This Is Input In WEI Not In Ether. 1 ETH = 1000000000000000000 WEI
     */
    function _ChangeSalePriceBrightList(uint SaleIndex, uint Price) external onlyBRTOperator 
    {
        uint OldPrice = Sales[SaleIndex].PriceBrightList; 
        Sales[SaleIndex].PriceBrightList = Price; 
        emit SaleChangedPriceBrightList(SaleIndex, OldPrice, Price);
    }
    
    /**
     * @dev Changes BrightList ERC Type `ERC_TYPE` At Index `SaleIndex`
     * note: Possible Inputs Are:
     * `721` - ERC721
     * `1155` - ERC1155
     */
    function _ChangeSaleERC_TYPE(uint SaleIndex, uint ERC_TYPE) external onlyBRTOperator 
    {
        require(ERC_TYPE == 721 || ERC_TYPE == 1155, "Incorrect ERC_TYPE"); 
        uint Old_ERC_TYPE = Sales[SaleIndex].ERC_TYPE;
        Sales[SaleIndex].ERC_TYPE = ERC_TYPE; 
        emit SaleChangedERC_TYPE(SaleIndex, Old_ERC_TYPE, ERC_TYPE);
    }

    /**
     * @dev Changes BrightList Contract Address `Contract` At Index `SaleIndex`
     * note: This Is The NFT Address That Is Being Claimed
     */
    function _ChangeSaleContract(uint SaleIndex, address Contract) external onlyBRTOperator 
    { 
        address OldContract = Sales[SaleIndex].ContractAddress;
        Sales[SaleIndex].ContractAddress = Contract; 
        emit SaleChangedContract(SaleIndex, OldContract, Contract);
    }

    /**
     * @dev Changes BrightList Operator `operator` At Index `SaleIndex`
     * note: This Is The Wallet / Address / EOA That The NFTs Are Pulling From
     */
    function _ChangeSaleOperator(uint SaleIndex, address Operator) external onlyBRTOperator 
    { 
        address OldOperator = Sales[SaleIndex].Operator;
        Sales[SaleIndex].Operator = Operator; 
        emit SaleChangedOperator(SaleIndex, OldOperator, Operator);
    }

    /**
     * @dev Changes BrightList Root `RootHash` At Index `SaleIndex`
     * note: This Is The Merkle Root
     */
    function _ChangeSaleRoot(uint SaleIndex, bytes32 RootHash) external onlyBRTOperator 
    { 
        bytes32 OldRoot = Sales[SaleIndex].Root;
        Sales[SaleIndex].Root = RootHash; 
        emit SaleChangedRoot(SaleIndex, OldRoot, RootHash);
    }

    /**
     * @dev Changes Public Sale State `State` At Index `SaleIndex`
     * note: Possible Inputs are `true` or `false`
     */
    function _ChangeSaleActiveStatePublic(uint SaleIndex, bool State) external onlyBRTOperator 
    { 
        bool OldState = Sales[SaleIndex].ActivePublic;
        Sales[SaleIndex].ActivePublic = State; 
        emit SaleChangedActiveState(SaleIndex, OldState, State);
    }

    /**
     * @dev Changes BrightList Sale State `State` At Index `SaleIndex`
     * note: Possible Inputs are `true` or `false`
     */
    function _ChangeSaleActiveStateBrightList(uint SaleIndex, bool State) external onlyBRTOperator 
    { 
        bool OldState = Sales[SaleIndex].ActiveBrightList;
        Sales[SaleIndex].ActiveBrightList = State; 
        emit SaleChangedActiveStateBrightList(SaleIndex, OldState, State);
    }

    /**
     * @dev Changes BrightList Sale States `States` At Index `SaleIndex`
     * note: Possible Inputs are array of `true` or `false`
     */
    function _ChangeSaleActiveStatesBrightList(uint[] calldata SaleIndexes, bool[] calldata States) external onlyBRTOperator 
    { 
        for(uint i; i < SaleIndexes.length; i++)
        {
            Sales[SaleIndexes[i]].ActiveBrightList = States[i];
        }
        emit SaleChangedActiveStatesBrightList(SaleIndexes, States);
    }

    /**
     * @dev Changes Public Sale State `State` At Index `SaleIndex`
     * note: Possible Inputs are array of `true` or `false`
     */
    function _ChangeSaleActiveStatesPublic(uint[] calldata SaleIndexes, bool[] calldata States) external onlyBRTOperator 
    { 
        for(uint i; i < SaleIndexes.length; i++)
        {
            Sales[SaleIndexes[i]].ActiveBrightList = States[i];
        }
        emit SaleChangedActiveStatesPublic(SaleIndexes, States);
    }

    /**
     * @dev Ends Sale At Index `SaleIndex`
     */
    function _EndSale(uint SaleIndex) external onlyBRTOperator 
    { 
        Sales[SaleIndex].ActivePublic = false; 
        emit SaleEnded(SaleIndex);
    }

    /***************************/
    /****** ADMIN COMMANDS *****/
    /***************************/

    /**
     * @dev Adds Bright Moments Operator
     * note: OnlyOwner
     */
    function __OperatorAdd(address Operator) external onlyOwner 
    { 
        BRTOperators[Operator] = _OPERATOR; 
        emit OperatorAdded(Operator);
    }

    /**
     * @dev Removes Bright Moments Operator
     * note: OnlyOwner
     */
    function __OperatorRemove(address Operator) external onlyOwner 
    { 
        BRTOperators[Operator] = _DEACTIVATED; 
        emit OperatorRemoved(Operator);    
    }

    /**
     * @dev Withdraws All Ether From Contract To Owner
     * note: OnlyOwner
     */
    function __Withdraw() external onlyOwner 
    {
        uint balance = address(this).balance;
        require(balance > 0, "Insufficient Balance"); 
        payable(owner()).transfer(balance); 
    }

    /**
     * @dev Withdraws Ether From Contract To Address
     * note: OnlyOwner
     */
    function __WithdrawToAddress(address payable Recipient) external onlyOwner 
    {
        uint balance = address(this).balance;
        require(balance > 0, "Insufficient Ether To Withdraw");
        (bool Success, ) = Recipient.call{value: balance}("");
        require(Success, "Unable to Withdraw, Recipient May Have Reverted");
    }

    /**
     * @dev Withdraws Ether From Contract To Address With An Amount
     * note: OnlyOwner
     * note: `Amount` is Denoted In WEI ()
     */
    function __WithdrawAmountToAddress(address payable Recipient, uint Amount) external onlyOwner
    {
        require(Amount > 0 && Amount <= address(this).balance, "Invalid Amount");
        (bool Success, ) = Recipient.call{value: Amount}("");
        require(Success, "Unable to Withdraw, Recipient May Have Reverted");
    }

    /**
     * @dev Withdraws Ether From Sale Instance To Owner
     * note: OnlyOwner
     */
    function __WithdrawSaleProceeds(uint SaleIndex) external onlyOwner
    {
        uint Amount = SaleProceeds[SaleIndex];
        require(Amount > 0 && Amount <= address(this).balance, "Insufficient Balance");
        SaleProceeds[SaleIndex] = 0;
        (bool Success, ) = owner().call{value: Amount}("");
        require(Success, "Unable to Withdraw, Recipient May Have Reverted");
    }

    /**
     * @dev Withdraws Ether From Sale Instance To Address
     * note: OnlyOwner
     */
    function __WithdrawSaleProceedsToAddress(address payable Recipient, uint SaleIndex) external onlyOwner
    {
        uint Amount = SaleProceeds[SaleIndex];
        require(Amount > 0 && Amount <= address(this).balance, "Insufficient Balance");
        SaleProceeds[SaleIndex] = 0;
        (bool Success, ) = Recipient.call{value: Amount}("");
        require(Success, "Unable to Withdraw, Recipient May Have Reverted");
    }
    
    /**
     * @dev Withdraws ERC20 From Contract To Address
     * note: OnlyOwner
     */
    function __WithdrawERC20ToAddress(address Recipient, address ContractAddress) external onlyOwner
    {
        IERC20 ERC20 = IERC20(ContractAddress);
        ERC20.transferFrom(address(this), Recipient, ERC20.balanceOf(address(this)));
    }

    /***************************/
    /******* PUBLIC VIEW *******/
    /***************************/
    
    /**
     * @dev Checks BrightList Allocation
     */
    function viewBrightListAllocation(address Recipient, uint SaleIndex, bytes32[] memory Proof) public view returns(bool)
    { 
        bytes32 Leaf = keccak256(abi.encodePacked(Recipient));
        return MerkleProof.verify(Proof, Sales[SaleIndex].Root, Leaf);
    }

    /**
     * @dev Returns State Variables Of `SaleIndex`
     * note: `0. Name`
     * note: `1. Price BrightList`
     * note: `2. Price Public`
     * note: `3. StartingIndex`
     * note: `4. EndingIndex`
     * note: `5. Purchaseable Amount BrightList`
     * note: `6. Purchaseable Amount Public`
     * note: `7. ERC_TYPE (721 for ERC721) || (1155 for ERC1155)`
     * note: `8. ContractAddress` Of NFT
     * note: `9. Operator`
     * note: `10. Merkle Root` 
     * note: `11. Is Sale Public Active`
     * note: `12. Is Sale BrightList Active`
     * note: `13. Allow Multiple Purchases`
     */
    function viewSaleState(uint SaleIndex) public view returns(Sale memory) { return Sales[SaleIndex]; }

    /**
     * @dev Returns Multiple Sale Instances Of `SaleIndex`
     * note: `0. Name`
     * note: `1. Price BrightList`
     * note: `2. Price Public`
     * note: `3. StartingIndex`
     * note: `4. EndingIndex`
     * note: `5. Purchaseable Amount BrightList`
     * note: `6. Purchaseable Amount Public`
     * note: `7. ERC_TYPE (721 for ERC721) || (1155 for ERC1155)`
     * note: `8. ContractAddress` Of NFT
     * note: `9. Operator`
     * note: `10. Merkle Root` 
     * note: `11. Is Sale Public Active`
     * note: `12. Is Sale BrightList Active`
     * note: `13. Allow Multiple Purchases`
     */
    function viewSaleStates(uint[] calldata SaleIndexes) public view returns(Sale[] memory) 
    {
        Sale[] memory SaleStates = new Sale[](SaleIndexes.length);
        for (uint i; i < SaleIndexes.length; i++) 
        {
            Sale storage saleInstance = Sales[SaleIndexes[i]];
            SaleStates[i] = saleInstance;
        }
        return SaleStates;
    }

    /***************************/
    /******** MODIFIER *********/
    /***************************/

    /**
     * @dev Restricts Certain Functions To Bright Moments Operators Only
     */
    modifier onlyBRTOperator
    {
        require(BRTOperators[msg.sender] == _OPERATOR, "User Is Not A Valid BRT Operator");
        _;
    }
}

// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC1155/IERC1155.sol)

pragma solidity ^0.8.0;

import "../../utils/introspection/IERC165.sol";

/**
 * @dev Required interface of an ERC1155 compliant contract, as defined in the
 * https://eips.ethereum.org/EIPS/eip-1155[EIP].
 *
 * _Available since v3.1._
 */
interface IERC1155 is IERC165 {
    /**
     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.
     */
    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);

    /**
     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all
     * transfers.
     */
    event TransferBatch(
        address indexed operator,
        address indexed from,
        address indexed to,
        uint256[] ids,
        uint256[] values
    );

    /**
     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to
     * `approved`.
     */
    event ApprovalForAll(address indexed account, address indexed operator, bool approved);

    /**
     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.
     *
     * If an {URI} event was emitted for `id`, the standard
     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value
     * returned by {IERC1155MetadataURI-uri}.
     */
    event URI(string value, uint256 indexed id);

    /**
     * @dev Returns the amount of tokens of token type `id` owned by `account`.
     *
     * Requirements:
     *
     * - `account` cannot be the zero address.
     */
    function balanceOf(address account, uint256 id) external view returns (uint256);

    /**
     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.
     *
     * Requirements:
     *
     * - `accounts` and `ids` must have the same length.
     */
    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)
        external
        view
        returns (uint256[] memory);

    /**
     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,
     *
     * Emits an {ApprovalForAll} event.
     *
     * Requirements:
     *
     * - `operator` cannot be the caller.
     */
    function setApprovalForAll(address operator, bool approved) external;

    /**
     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.
     *
     * See {setApprovalForAll}.
     */
    function isApprovedForAll(address account, address operator) external view returns (bool);

    /**
     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.
     *
     * Emits a {TransferSingle} event.
     *
     * Requirements:
     *
     * - `to` cannot be the zero address.
     * - If the caller is not `from`, it must have been approved to spend ``from``'s tokens via {setApprovalForAll}.
     * - `from` must have a balance of tokens of type `id` of at least `amount`.
     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the
     * acceptance magic value.
     */
    function safeTransferFrom(
        address from,
        address to,
        uint256 id,
        uint256 amount,
        bytes calldata data
    ) external;

    /**
     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.
     *
     * Emits a {TransferBatch} event.
     *
     * Requirements:
     *
     * - `ids` and `amounts` must have the same length.
     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the
     * acceptance magic value.
     */
    function safeBatchTransferFrom(
        address from,
        address to,
        uint256[] calldata ids,
        uint256[] calldata amounts,
        bytes calldata data
    ) external;
}

//SPDX-License-Identifier: MIT
/*@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                     @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@          @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                 @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@              @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@              @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                 @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                     @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@*/
/**
 * @dev: @brougkr
 */
pragma solidity 0.8.16;
import {Ownable} from "@openzeppelin/contracts/access/Ownable.sol";
import {ReentrancyGuard} from "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import {MerkleProof} from "@openzeppelin/contracts/utils/cryptography/MerkleProof.sol";
import {IERC721} from "@openzeppelin/contracts/token/ERC721/IERC721.sol";
import {IERC1155} from "@openzeppelin/contracts/token/ERC1155/IERC1155.sol";
import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import {CTZNPlugin, ICTZN} from "./CTZNPlugin.sol";

contract BrightBundles is Ownable, ReentrancyGuard, CTZNPlugin
{
    /***************************/
    /********** STRUCT *********/
    /***************************/

    struct Bundle
    {
        string Name; 
        uint PriceBrightList; 
        uint PricePublic; 
        uint[] StartingIndexes; 
        uint[] EndingIndexes; 
        uint PurchaseableAmount; 
        uint PurchaseableAmountBrightList; 
        uint PurchaseableAmountPublic; 
        address[] ContractAddresses; 
        address Operator; 
        bytes32 Root; 
        bool ActivePublic; 
        bool ActiveBrightList; 
        bool AllowMultiplePurchases; 
    }

    /***************************/
    /********* MAPPINGS ********/
    /***************************/

    mapping(uint => Bundle) public Bundles;
    mapping(uint => uint) public BundleProceeds;
    mapping(address => bytes32) public BRTOperators;
    mapping(uint => mapping(address => bool)) public BundlePurchased;
    mapping(uint => mapping(address => uint)) public PurchasedAmountBrightList;
    mapping(uint => mapping(address => uint)) public PurchasedAmountPublic;

    /***************************/
    /********** EVENTS *********/
    /***************************/

    /**
     * @dev Emitted When A BrightList Purchase Occurs
     */
    event BundlePurchaseEventBrightList(
        address indexed recipientAddress, 
        uint indexed BundleIndex, 
        uint amount
    );

    /**
     * @dev Emitted When A Public Purchase Occurs
     */
    event BundlePurchaseEvent(
        address indexed recipientAddress, 
        uint indexed BundleIndex, 
        uint amount
    );

    /**
     * @dev Emitted When A Bundle Has Started
     */
    event BundleStarted(
        string Name,
        address[] ContractAddresses, 
        bytes32 RootHash, 
        address Operator, 
        bool ActivePublic,
        bool ActiveBrightList,
        bool AllowMultiplePurchases
    );

    /**
     * @dev Emitted When A Batch Of Bundles Have Been Initialized
     */
    event BundlesStarted(Bundle BundleInstance);

    /**
     * @dev Emitted When Various State Variables Are Modified
     */
    event BundlesEnded(uint[] BundleIndexes);
    event BundleChangedNames(uint[] BundleIndexes, string[] NewNames);
    event BundleChangedStartingIndexes(uint indexed BundleIndex, uint[] OldStartingIndexes, uint[] NewStartingIndexes);
    event BundleChangedEndingIndexes(uint indexed BundleIndex, uint[] OldEndingIndexes, uint[] NewEndingIndexes);
    event BundleChangedAllocationsPublic(uint[] BundleIndexes, uint[] NewAllocations);
    event BundleChangedAllocationsBrightList(uint[] BundleIndexes, uint[] NewAllocations);
    event BundleChangedPricesBrightList(uint[] BundleIndexes, uint[] NewPrices);
    event BundleChangedPricesPublic(uint[] BundleIndexes, uint[] NewPrices); 
    event BundleChangedERC_TYPE(uint indexed BundleIndex, uint OLD_ERC_TYPE, uint NEW_ERC_TYPE);
    event BundleChangedContracts(uint indexed BundleIndex, address[] OldContracts, address[] NewContracts);
    event BundleChangedRoots(uint[] BundleIndexes, bytes32[] NewRoots);
    event BundleChangedOperators(uint[] indexed BundleIndexes, address[] NewOperators);
    event BundleChangedActiveStatesPublic(uint[] BundleIndexes, bool[] States);
    event BundleChangedActiveStatesBrightList(uint[] BundleIndexes, bool[] States);
    event BundleChangedPurchaseableAmounts(uint[] BundleIndexes, uint[] Amounts);
    event BundleChangedAllowMultiplePurchases(uint[] BundleIndexes, bool[] States);

    /**
     * @dev Emitted When BRT Multisig Adds Or Removes An Operator
     */
    event OperatorAdded(address Operator);
    event OperatorRemoved(address Operator);

    /**
     * @dev Amount Of Unique Bundle Bundles
     */
    uint public UniqueBundleIndex;

    /**
     * @dev BRT Operator Roles
     */
    bytes32 private immutable _OPERATOR = keccak256("OPERATOR");
    bytes32 private immutable _DEACTIVATED = 0x0;
    address public immutable _BRTMULTISIG = 0xB96E81f80b3AEEf65CB6d0E280b15FD5DBE71937;

    /**
     * @dev Constructor
     */
    constructor() 
    { 
        BRTOperators[0x5778B0B140Fa7a62B96c193cC8621e6E96c088A5] = _OPERATOR; //brougkr
        BRTOperators[0x18B7511938FBe2EE08ADf3d4A24edB00A5C9B783] = _OPERATOR; //phil.brightmoments.eth
        BRTOperators[0xbf001FF749b7E793bbb1A612d09124470b9179A7] = _OPERATOR; //future
        _transferOwnership(_BRTMULTISIG);
    } 

    /***************************/
    /***** PUBLIC FUNCTIONS ****/
    /***************************/

    /**
     * @dev Public Bundle Purchase 
     */
    function BundlePurchase(uint BundleIndex, uint Amount) public payable nonReentrant
    { 
        require(Bundles[BundleIndex].ActivePublic, "BrightBundles: Requested Bundle Is Not Available For Public Purchases");
        require(
            PurchasedAmountPublic[BundleIndex][msg.sender] + Amount <= Bundles[BundleIndex].PurchaseableAmountPublic,
            "BrightBundles: User Has Used Up All Of Public Allocation For This Bundle Index"
        );
        if(!Bundles[BundleIndex].AllowMultiplePurchases) { require(!BundlePurchased[BundleIndex][msg.sender], "BrightBundles: User Has Already Purchased This Bundle Index"); }
        require(msg.value == Bundles[BundleIndex].PricePublic * Amount && Amount > 0, "BrightBundles: Incorrect Ether Amount Or Token Amount Sent For Purchase");
        if(!BundlePurchased[BundleIndex][msg.sender]) { BundlePurchased[BundleIndex][msg.sender] = true; }
        PurchasedAmountPublic[BundleIndex][msg.sender] += Amount;
        for(uint x; x < Amount; x++)
        {
            for(uint y; y < Bundles[BundleIndex].ContractAddresses.length; y++)
            {
                IERC721(Bundles[BundleIndex].ContractAddresses[y]).transferFrom(
                    Bundles[BundleIndex].Operator, 
                    msg.sender, 
                    Bundles[BundleIndex].StartingIndexes[y]
                );
                Bundles[BundleIndex].StartingIndexes[y]++;
            }
        }
        BundleProceeds[BundleIndex] += msg.value;
        ICTZN(CTZN).IncrementCTZN(msg.sender, _RewardRates[0]);
        emit BundlePurchaseEvent(msg.sender, BundleIndex, Amount);
    }

    /**
     * @dev Bundle Purchase BrightList Bundle
     */
    function BundlePurchaseBrightList(uint BundleIndex, uint Amount, bytes32[] calldata Proof) public payable nonReentrant
    {
        require(Bundles[BundleIndex].ActiveBrightList, "BrightBundles: Requested Bundle Is Not Available For BrightList Purchases");
        require(msg.value == Bundles[BundleIndex].PriceBrightList * Amount && Amount > 0, "BrightBundles: Incorrect Ether Amount Or Token Amount Sent For Purchase");
        require(viewBrightListAllocation(msg.sender, BundleIndex, Proof), "BrightBundles: User Is Not On BrightList");
        require(
            PurchasedAmountBrightList[BundleIndex][msg.sender] + Amount <= Bundles[BundleIndex].PurchaseableAmountBrightList,
            "BrightBundles: User Has Used Up All BrightList Allocation For This Bundle Index"
        );
        if(!Bundles[BundleIndex].AllowMultiplePurchases) { require(!BundlePurchased[BundleIndex][msg.sender], "BrightBundles: User Has Already Purchased This Bundle Index"); }
        if(!BundlePurchased[BundleIndex][msg.sender]) { BundlePurchased[BundleIndex][msg.sender] = true; }
        PurchasedAmountBrightList[BundleIndex][msg.sender] += Amount;    
        for(uint x; x < Amount; x++)
        {
            for(uint y; y < Bundles[BundleIndex].ContractAddresses.length; y++)
            {
                IERC721(Bundles[BundleIndex].ContractAddresses[y]).transferFrom(
                    Bundles[BundleIndex].Operator, 
                    msg.sender, 
                    Bundles[BundleIndex].StartingIndexes[y]
                );
                Bundles[BundleIndex].StartingIndexes[y]++;
            }
        }
        BundleProceeds[BundleIndex] += msg.value;
        ICTZN(CTZN).IncrementCTZN(msg.sender, _RewardRates[1]);
        emit BundlePurchaseEventBrightList(msg.sender, BundleIndex, _RewardRates[1]);
    }

    /***************************/
    /**** OPERATOR COMMANDS ****/
    /***************************/

    /**
     * @dev Sets Up A New Bundle
     * note: `Price` Is Input In WEI Due To Ethereum EVM. For Example, 1 ETH = 1000000000000000000 WEI
     * note: `ERC_TYPE` Is (`721` for ERC721) || (`1155` for ERC1155)
     * note: `ContractAddress` Is The NFT Contract Address
     * note: `RootHash` Is Merkle Root Hash
     * note: `Operator` Is The Wallet Providing The NFTs For Bundle. They Will Have To setApprovalForAll() On This Contract
     * note: `Public` & `AllowMultiplePurchases` Are Either `true` or `false`
     */
    function _StartBundle(Bundle memory NewBundleInstance) external onlyBRTOperator
    {
        //Auto-Increments The Unique Bundle Index
        UniqueBundleIndex++; 

        //Assigns State Variables To The New Bundle Instance
        Bundles[UniqueBundleIndex].Name = NewBundleInstance.Name;
        Bundles[UniqueBundleIndex].PriceBrightList = NewBundleInstance.PriceBrightList;
        Bundles[UniqueBundleIndex].PricePublic = NewBundleInstance.PricePublic;
        Bundles[UniqueBundleIndex].StartingIndexes = NewBundleInstance.StartingIndexes;
        Bundles[UniqueBundleIndex].EndingIndexes = NewBundleInstance.EndingIndexes;
        Bundles[UniqueBundleIndex].PurchaseableAmount = NewBundleInstance.PurchaseableAmount;
        Bundles[UniqueBundleIndex].PurchaseableAmountBrightList = NewBundleInstance.PurchaseableAmountBrightList;
        Bundles[UniqueBundleIndex].PurchaseableAmountPublic = NewBundleInstance.PurchaseableAmountPublic;
        Bundles[UniqueBundleIndex].ContractAddresses = NewBundleInstance.ContractAddresses;
        Bundles[UniqueBundleIndex].Operator = NewBundleInstance.Operator;
        Bundles[UniqueBundleIndex].Root = NewBundleInstance.Root;
        Bundles[UniqueBundleIndex].ActivePublic = NewBundleInstance.ActivePublic;
        Bundles[UniqueBundleIndex].ActiveBrightList = NewBundleInstance.ActiveBrightList;
        Bundles[UniqueBundleIndex].AllowMultiplePurchases = NewBundleInstance.AllowMultiplePurchases;
        
        //Emits Base Data Of The New Bundle Instance
        emit BundleStarted(
            Bundles[UniqueBundleIndex].Name,
            Bundles[UniqueBundleIndex].ContractAddresses, 
            Bundles[UniqueBundleIndex].Root, 
            Bundles[UniqueBundleIndex].Operator, 
            Bundles[UniqueBundleIndex].ActivePublic,
            Bundles[UniqueBundleIndex].ActiveBrightList,
            Bundles[UniqueBundleIndex].AllowMultiplePurchases
        );
    }

    /**
     * @dev Batch Startes Multiple Bundles
     * note: INDEX
     * [0] = Name
     * [1] = PriceBrightList
     * [2] = PricePublic
     * [3] = StartingIndexes
     * [4] = EndingIndexes
     * [5] = PurchaseableAmount
     * [6] = PurchaseableAmountBrightList
     * [7] = PurchaseableAmountPublic
     * [8] = ContractAddresses
     * [9] = Operator
     * [10] = Root
     * [11] = ActivePublic
     * [12] = ActiveBrightList
     * [13] = AllowMultiplePurchases
     */
    function _StartBundles(Bundle[] memory NewBundleInstances) external onlyBRTOperator   
    {
        for(uint BundleIndex; BundleIndex < NewBundleInstances.length; BundleIndex++)
        {  
            //Auto Increments Index    
            UniqueBundleIndex++; 

            //Assigns State Variables To The New Bundle Instance
            Bundles[UniqueBundleIndex].Name = NewBundleInstances[BundleIndex].Name;
            Bundles[UniqueBundleIndex].PriceBrightList = NewBundleInstances[BundleIndex].PriceBrightList;
            Bundles[UniqueBundleIndex].PricePublic = NewBundleInstances[BundleIndex].PricePublic;
            Bundles[UniqueBundleIndex].PurchaseableAmount = NewBundleInstances[BundleIndex].PurchaseableAmount;
            Bundles[UniqueBundleIndex].PurchaseableAmountBrightList = NewBundleInstances[BundleIndex].PurchaseableAmountBrightList;
            Bundles[UniqueBundleIndex].PurchaseableAmountPublic = NewBundleInstances[BundleIndex].PurchaseableAmountPublic;
            Bundles[UniqueBundleIndex].ContractAddresses = NewBundleInstances[BundleIndex].ContractAddresses;
            Bundles[UniqueBundleIndex].Operator = NewBundleInstances[BundleIndex].Operator;
            Bundles[UniqueBundleIndex].Root = NewBundleInstances[BundleIndex].Root;
            Bundles[UniqueBundleIndex].StartingIndexes = NewBundleInstances[BundleIndex].StartingIndexes;
            Bundles[UniqueBundleIndex].EndingIndexes = NewBundleInstances[BundleIndex].EndingIndexes;
            Bundles[UniqueBundleIndex].ActivePublic = NewBundleInstances[BundleIndex].ActivePublic;
            Bundles[UniqueBundleIndex].ActiveBrightList = NewBundleInstances[BundleIndex].ActiveBrightList;
            Bundles[UniqueBundleIndex].AllowMultiplePurchases = NewBundleInstances[BundleIndex].AllowMultiplePurchases;
        }
        emit BundlesStarted(Bundles[UniqueBundleIndex]);
    }

    /**
     * @dev Changes BrightList Bundle Name `Name` At Index `BundleIndex`
     * note: This Is The Name Of The Bundle
     */
    function _ChangeBundleNames(uint[] calldata BundleIndexes, string[] memory Names) external onlyBRTOperator 
    { 
        for(uint i; i < BundleIndexes.length; i++)
        {
            Bundles[BundleIndexes[i]].Name = Names[i];  
        }
        emit BundleChangedNames(BundleIndexes, Names);
    }
    
    /**
     * @dev Changes BrightList StartingIndexes `Index` At Index `BundleIndex`
     * note: This Is The Starting Token ID
     */
    function _ChangeBundleStartingIndexes(uint BundleIndex, uint[] calldata Indexes) external onlyBRTOperator 
    { 
        uint[] memory OldStartingIndexes = Bundles[BundleIndex].StartingIndexes;
        Bundles[BundleIndex].StartingIndexes = Indexes; 
        emit BundleChangedStartingIndexes(BundleIndex, OldStartingIndexes, Indexes);
    }

    /**
     * @dev Changes BrightList EndingIndexes `Index` At Index `BundleIndex`
     * note: This Is The Ending Token ID
     */
    function _ChangeBundleEndingIndexes(uint BundleIndex, uint[] calldata Indexes) external onlyBRTOperator 
    { 
        uint[] memory OldEndingIndexes = Bundles[BundleIndex].EndingIndexes;
        Bundles[BundleIndex].EndingIndexes = Indexes; 
        emit BundleChangedEndingIndexes(BundleIndex, OldEndingIndexes, Indexes);
    }

    /**
     * @dev Changes Brightlist Public Purchasable Amount `Amount` At Index `BundleIndex`
     * note: This Is The Public Allocation
     */
    function _ChangeBundleAllocationsPublic(uint[] calldata BundleIndexes, uint[] calldata Amounts) external onlyBRTOperator 
    {
        for(uint i; i < BundleIndexes.length; i++)
        {
            Bundles[BundleIndexes[i]].PurchaseableAmountPublic = Amounts[i]; 
        }
        emit BundleChangedAllocationsPublic(BundleIndexes, Amounts);
    }
    
    /**
     * @dev Changes Brightlist Purchasable Amount `Amount` At Index `BundleIndex`
     * note: This Is The BrightList Allocation
     */
    function _ChangeBundleAllocationsBrightList(uint[] calldata BundleIndexes, uint[] calldata Amounts) external onlyBRTOperator 
    {
        for(uint i; i < BundleIndexes.length; i++)
        {
            Bundles[BundleIndexes[i]].PurchaseableAmountBrightList = Amounts[i]; 
        }
        emit BundleChangedAllocationsBrightList(BundleIndexes, Amounts);
    }

    /**
     * @dev Changes Bundle Price Public Amount `Price` At Index `BundleIndex`
     * note: This Is Input In WEI Not In Ether. 1 ETH = 1000000000000000000 WEI
     */
    function _ChangeBundlePricesPublic(uint[] calldata BundleIndexes, uint[] calldata Prices) external onlyBRTOperator 
    { 
        for(uint i; i < BundleIndexes.length; i++)
        {
            Bundles[BundleIndexes[i]].PricePublic = Prices[i];
        }
        emit BundleChangedPricesPublic(BundleIndexes, Prices);
    }

    /**
     * @dev Changes Bundle Price BrightList Amount `Price` At Index `BundleIndex`
     * note: This Is Input In WEI Not In Ether. 1 ETH = 1000000000000000000 WEI
     */
    function _ChangeBundlePricesBrightList(uint[] calldata BundleIndexes, uint[] calldata Prices) external onlyBRTOperator 
    {
        for(uint i; i < BundleIndexes.length; i++)
        {
            Bundles[BundleIndexes[i]].PriceBrightList = Prices[i]; 
        }
        emit BundleChangedPricesBrightList(BundleIndexes, Prices);
    }

    /**
     * @dev Changes Bundle Price BrightList Amount `Price` At Index `BundleIndex`
     * note: This Is Input In WEI Not In Ether. 1 ETH = 1000000000000000000 WEI
     */
    function _ChangeBundlePurchaseableAmounts(uint[] calldata BundleIndexes, uint[] calldata Amounts) external onlyBRTOperator 
    {
        for(uint i; i < BundleIndexes.length; i++)
        {
            Bundles[BundleIndexes[i]].PurchaseableAmount = Amounts[i]; 
        }
        emit BundleChangedPurchaseableAmounts(BundleIndexes, Amounts);
    }

    /**
     * @dev Changes BrightList Contract Address `Contract` At Index `BundleIndex`
     * note: Contracts Are The NFT Addresses That Is Being Claimed
     */
    function _ChangeBundleContracts(uint BundleIndex, address[] calldata Contracts) external onlyBRTOperator 
    { 
        address[] memory OldContracts = Bundles[BundleIndex].ContractAddresses;
        Bundles[BundleIndex].ContractAddresses = Contracts; 
        emit BundleChangedContracts(BundleIndex, OldContracts, Contracts);
    }

    /**
     * @dev Changes BrightList Operator `operator` At Index `BundleIndex`
     * note: This Is The Wallet / Address / EOA That The NFTs Are Pulling From
     */
    function _ChangeBundleOperators(uint[] calldata BundleIndexes, address[] calldata Operators) external onlyBRTOperator 
    { 
        for(uint i; i < BundleIndexes.length; i++)
        {
            Bundles[BundleIndexes[i]].Operator = Operators[i]; 
            emit BundleChangedOperators(BundleIndexes, Operators);
        }
    }

    /**
     * @dev Changes BrightList Root `RootHash` At Index `BundleIndex`
     * note: This Is The Merkle Root
     */
    function _ChangeBundleRoots(uint[] calldata BundleIndexes, bytes32[] calldata RootHashes) external onlyBRTOperator 
    { 
        for(uint i; i < BundleIndexes.length; i++)
        {
            Bundles[BundleIndexes[i]].Root = RootHashes[i]; 
        }
        emit BundleChangedRoots(BundleIndexes, RootHashes);
    }

    /**
     * @dev Changes BrightList Bundle States `States` At Index `BundleIndex`
     * note: Possible Inputs are array of `true` or `false`
     */
    function _ChangeBundleActiveStatesBrightList(uint[] calldata BundleIndexes, bool[] calldata States) external onlyBRTOperator 
    { 
        require(BundleIndexes.length == States.length, "Arrays Must Be Equal Length");
        for(uint i; i < BundleIndexes.length; i++)
        {
            Bundles[BundleIndexes[i]].ActiveBrightList = States[i];
        }
        emit BundleChangedActiveStatesBrightList(BundleIndexes, States);
    }

    /**
     * @dev Changes Public Bundle State `State` At Index `BundleIndex`
     * note: Possible Inputs are array of `true` or `false`
     */
    function _ChangeBundleActiveStatesPublic(uint[] calldata BundleIndexes, bool[] calldata States) external onlyBRTOperator 
    { 
        require(BundleIndexes.length == States.length, "Arrays Must Be Equal Length");
        for(uint i; i < BundleIndexes.length; i++)
        {
            Bundles[BundleIndexes[i]].ActivePublic = States[i];
        }
        emit BundleChangedActiveStatesPublic(BundleIndexes, States);
    }

    /**
     * @dev Changes Public Bundle State `State` At Index `BundleIndex`
     * note: Possible Inputs are array of `true` or `false`
     */
    function _ChangeBundleAllowMultiplePurchases(uint[] calldata BundleIndexes, bool[] calldata States) external onlyBRTOperator 
    { 
        require(BundleIndexes.length == States.length, "Arrays Must Be Equal Length");
        for(uint i; i < BundleIndexes.length; i++)
        {
            Bundles[BundleIndexes[i]].AllowMultiplePurchases = States[i];
        }
        emit BundleChangedAllowMultiplePurchases(BundleIndexes, States);
    }

    /**
     * @dev Ends Bundles
     */
    function _EndBundles(uint[] calldata BundleIndexes) external onlyBRTOperator 
    {
        for(uint i; i < BundleIndexes.length; i++)
        {
            Bundles[BundleIndexes[i]].ActivePublic = false; 
            Bundles[BundleIndexes[i]].ActiveBrightList = false;
        }
        emit BundlesEnded(BundleIndexes);
    }

    /***************************/
    /****** ADMIN COMMANDS *****/
    /***************************/

    /**
     * @dev Adds Bright Moments Operator
     * note: OnlyOwner
     */
    function __OperatorAdd(address Operator) external onlyOwner 
    { 
        BRTOperators[Operator] = _OPERATOR; 
        emit OperatorAdded(Operator);
    }

    /**
     * @dev Removes Bright Moments Operator
     * note: OnlyOwner
     */
    function __OperatorRemove(address Operator) external onlyOwner 
    { 
        BRTOperators[Operator] = _DEACTIVATED; 
        emit OperatorRemoved(Operator);    
    }

    /**
     * @dev Withdraws All Ether From Contract To Owner
     * note: OnlyOwner
     */
    function __Withdraw() external onlyOwner 
    {
        uint balance = address(this).balance;
        require(balance > 0, "Insufficient Balance"); 
        payable(owner()).transfer(balance); 
    }

    /**
     * @dev Withdraws Ether From Contract To Address
     * note: OnlyOwner
     */
    function __WithdrawToAddress(address payable Recipient) external onlyOwner 
    {
        uint balance = address(this).balance;
        require(balance > 0, "Insufficient Ether To Withdraw");
        (bool Success, ) = Recipient.call{value: balance}("");
        require(Success, "Unable to Withdraw, Recipient May Have Reverted");
    }

    /**
     * @dev Withdraws Ether From Contract To Address With An Amount
     * note: OnlyOwner
     * note: `Amount` is Denoted In WEI ()
     */
    function __WithdrawAmountToAddress(address payable Recipient, uint Amount) external onlyOwner
    {
        require(Amount > 0 && Amount <= address(this).balance, "Invalid Amount");
        (bool Success, ) = Recipient.call{value: Amount}("");
        require(Success, "Unable to Withdraw, Recipient May Have Reverted");
    }

    /**
     * @dev Withdraws Ether From Bundle Instance To Owner
     * note: OnlyOwner
     */
    function __WithdrawBundleProceeds(uint BundleIndex) external onlyOwner
    {
        uint Amount = BundleProceeds[BundleIndex];
        require(Amount > 0 && Amount <= address(this).balance, "Insufficient Balance");
        BundleProceeds[BundleIndex] = 0;
        (bool Success, ) = owner().call{value: Amount}("");
        require(Success, "Unable to Withdraw, Recipient May Have Reverted");
    }

    /**
     * @dev Withdraws Ether From Bundle Instance To Address
     * note: OnlyOwner
     */
    function __WithdrawBundleProceedsToAddress(address payable Recipient, uint BundleIndex) external onlyOwner
    {
        uint Amount = BundleProceeds[BundleIndex];
        require(Amount > 0 && Amount <= address(this).balance, "Insufficient Balance");
        BundleProceeds[BundleIndex] = 0;
        (bool Success, ) = Recipient.call{value: Amount}("");
        require(Success, "Unable to Withdraw, Recipient May Have Reverted");
    }
    
    /**
     * @dev Withdraws ERC20 From Contract To Address
     * note: OnlyOwner
     */
    function __WithdrawERC20ToAddress(address Recipient, address ContractAddress) external onlyOwner
    {
        IERC20 ERC20 = IERC20(ContractAddress);
        ERC20.transferFrom(address(this), Recipient, ERC20.balanceOf(address(this)));
    }

    /***************************/
    /******* PUBLIC VIEW *******/
    /***************************/
    
    /**
     * @dev Checks BrightList Allocation
     */
    function viewBrightListAllocation(address Recipient, uint BundleIndex, bytes32[] memory Proof) public view returns(bool)
    { 
        bytes32 Leaf = keccak256(abi.encodePacked(Recipient));
        return MerkleProof.verify(Proof, Bundles[BundleIndex].Root, Leaf);
    }

    /**
     * @dev Returns State Variables Of `BundleIndex`
     * note: `0. Name`
     * note: `1. Price BrightList`
     * note: `2. Price Public`
     * note: `3. StartingIndexes`
     * note: `4. EndingIndexes`
     * note: `5. PurchaseableAmount`
     * note: `6. Purchaseable Amount BrightList`
     * note: `7. Purchaseable Amount Public`
     * note: `8. ContractAddresses` Of NFT
     * note: `9. Operators`
     * note: `10. Merkle Root` 
     * note: `11. Is Bundle Public Active`
     * note: `12. Is Bundle BrightList Active`
     * note: `13. Allow Multiple Purchases`
     */
    function viewBundleState(uint BundleIndex) public view returns(Bundle memory) { return Bundles[BundleIndex]; }

    /**
     * @dev Returns State Variables Of `BundleIndex`
     * note: `0. Name`
     * note: `1. Price BrightList`
     * note: `2. Price Public`
     * note: `3. StartingIndexes`
     * note: `4. EndingIndexes`
     * note: `5. PurchaseableAmount`
     * note: `6. Purchaseable Amount BrightList`
     * note: `7. Purchaseable Amount Public`
     * note: `8. ContractAddresses` Of NFT
     * note: `9. Operators`
     * note: `10. Merkle Root` 
     * note: `11. Is Bundle Public Active`
     * note: `12. Is Bundle BrightList Active`
     * note: `13. Allow Multiple Purchases`
     */
    function viewBundleStates(uint[] calldata BundleIndexes) public view returns(Bundle[] memory) 
    {
        Bundle[] memory BundleStates = new Bundle[](BundleIndexes.length);
        for (uint i; i < BundleIndexes.length; i++) 
        {
            Bundle storage saleInstance = Bundles[BundleIndexes[i]];
            BundleStates[i] = saleInstance;
        }
        return BundleStates;
    }

    /***************************/
    /******** MODIFIER *********/
    /***************************/

    /**
     * @dev Restricts Certain Functions To Bright Moments Operators Only
     */
    modifier onlyBRTOperator
    {
        require(BRTOperators[msg.sender] == _OPERATOR, "User Is Not A Valid BRT Operator");
        _;
    }
}

// SPDX-License-Identifier: MIT
// ERC721A Contracts v3.3.0
// Creator: Chiru Labs

pragma solidity ^0.8.4;

import './IERC721A.sol';
import '@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol';
import '@openzeppelin/contracts/utils/Address.sol';
import '@openzeppelin/contracts/utils/Context.sol';
import '@openzeppelin/contracts/utils/Strings.sol';
import '@openzeppelin/contracts/utils/introspection/ERC165.sol';

/**
 * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including
 * the Metadata extension. Built to optimize for lower gas during batch mints.
 *
 * Assumes serials are sequentially minted starting at _startTokenId() (defaults to 0, e.g. 0, 1, 2, 3..).
 *
 * Assumes that an owner cannot have more than 2**64 - 1 (max value of uint64) of supply.
 *
 * Assumes that the maximum token id cannot exceed 2**256 - 1 (max value of uint256).
 */
contract ERC721A is Context, ERC165, IERC721A {
    using Address for address;
    using Strings for uint256;

    // The tokenId of the next token to be minted.
    uint256 internal _currentIndex;

    // The number of tokens burned.
    uint256 internal _burnCounter;

    // Token name
    string private _name;

    // Token symbol
    string private _symbol;

    // Mapping from token ID to ownership details
    // An empty struct value does not necessarily mean the token is unowned. See _ownershipOf implementation for details.
    mapping(uint256 => TokenOwnership) internal _ownerships;

    // Mapping owner address to address data
    mapping(address => AddressData) private _addressData;

    // Mapping from token ID to approved address
    mapping(uint256 => address) private _tokenApprovals;

    // Mapping from owner to operator approvals
    mapping(address => mapping(address => bool)) private _operatorApprovals;

    constructor(string memory name_, string memory symbol_) {
        _name = name_;
        _symbol = symbol_;
        _currentIndex = _startTokenId();
    }

    /**
     * To change the starting tokenId, please override this function.
     */
    function _startTokenId() internal view virtual returns (uint256) {
        return 0;
    }

    /**
     * @dev Burned tokens are calculated here, use _totalMinted() if you want to count just minted tokens.
     */
    function totalSupply() public view override returns (uint256) {
        // Counter underflow is impossible as _burnCounter cannot be incremented
        // more than _currentIndex - _startTokenId() times
        unchecked {
            return _currentIndex - _burnCounter - _startTokenId();
        }
    }

    /**
     * Returns the total amount of tokens minted in the contract.
     */
    function _totalMinted() internal view returns (uint256) {
        // Counter underflow is impossible as _currentIndex does not decrement,
        // and it is initialized to _startTokenId()
        unchecked {
            return _currentIndex - _startTokenId();
        }
    }

    /**
     * @dev See {IERC165-supportsInterface}.
     */
    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {
        return
            interfaceId == type(IERC721).interfaceId ||
            interfaceId == type(IERC721Metadata).interfaceId ||
            super.supportsInterface(interfaceId);
    }

    /**
     * @dev See {IERC721-balanceOf}.
     */
    function balanceOf(address owner) public view override returns (uint256) {
        if (owner == address(0)) revert BalanceQueryForZeroAddress();
        return uint256(_addressData[owner].balance);
    }

    /**
     * Returns the number of tokens minted by `owner`.
     */
    function _numberMinted(address owner) internal view returns (uint256) {
        return uint256(_addressData[owner].numberMinted);
    }

    /**
     * Returns the number of tokens burned by or on behalf of `owner`.
     */
    function _numberBurned(address owner) internal view returns (uint256) {
        return uint256(_addressData[owner].numberBurned);
    }

    /**
     * Returns the auxillary data for `owner`. (e.g. number of whitelist mint slots used).
     */
    function _getAux(address owner) internal view returns (uint64) {
        return _addressData[owner].aux;
    }

    /**
     * Sets the auxillary data for `owner`. (e.g. number of whitelist mint slots used).
     * If there are multiple variables, please pack them into a uint64.
     */
    function _setAux(address owner, uint64 aux) internal {
        _addressData[owner].aux = aux;
    }

    /**
     * Gas spent here starts off proportional to the maximum mint batch size.
     * It gradually moves to O(1) as tokens get transferred around in the collection over time.
     */
    function _ownershipOf(uint256 tokenId) internal view returns (TokenOwnership memory) {
        uint256 curr = tokenId;

        unchecked {
            if (_startTokenId() <= curr) if (curr < _currentIndex) {
                TokenOwnership memory ownership = _ownerships[curr];
                if (!ownership.burned) {
                    if (ownership.addr != address(0)) {
                        return ownership;
                    }
                    // Invariant:
                    // There will always be an ownership that has an address and is not burned
                    // before an ownership that does not have an address and is not burned.
                    // Hence, curr will not underflow.
                    while (true) {
                        curr--;
                        ownership = _ownerships[curr];
                        if (ownership.addr != address(0)) {
                            return ownership;
                        }
                    }
                }
            }
        }
        revert OwnerQueryForNonexistentToken();
    }

    /**
     * @dev See {IERC721-ownerOf}.
     */
    function ownerOf(uint256 tokenId) public view override returns (address) {
        return _ownershipOf(tokenId).addr;
    }

    /**
     * @dev See {IERC721Metadata-name}.
     */
    function name() public view virtual override returns (string memory) {
        return _name;
    }

    /**
     * @dev See {IERC721Metadata-symbol}.
     */
    function symbol() public view virtual override returns (string memory) {
        return _symbol;
    }

    /**
     * @dev See {IERC721Metadata-tokenURI}.
     */
    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {
        if (!_exists(tokenId)) revert URIQueryForNonexistentToken();

        string memory baseURI = _baseURI();
        return bytes(baseURI).length != 0 ? string(abi.encodePacked(baseURI, tokenId.toString(), '.json')) : '';
    }

    /**
     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each
     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty
     * by default, can be overriden in child contracts.
     */
    function _baseURI() internal view virtual returns (string memory) {
        return '';
    }

    /**
     * @dev See {IERC721-approve}.
     */
    function approve(address to, uint256 tokenId) public override {
        address owner = ERC721A.ownerOf(tokenId);
        if (to == owner) revert ApprovalToCurrentOwner();

        if (_msgSender() != owner) if(!isApprovedForAll(owner, _msgSender())) {
            revert ApprovalCallerNotOwnerNorApproved();
        }

        _approve(to, tokenId, owner);
    }

    /**
     * @dev See {IERC721-getApproved}.
     */
    function getApproved(uint256 tokenId) public view override returns (address) {
        if (!_exists(tokenId)) revert ApprovalQueryForNonexistentToken();

        return _tokenApprovals[tokenId];
    }

    /**
     * @dev See {IERC721-setApprovalForAll}.
     */
    function setApprovalForAll(address operator, bool approved) public virtual override {
        if (operator == _msgSender()) revert ApproveToCaller();

        _operatorApprovals[_msgSender()][operator] = approved;
        emit ApprovalForAll(_msgSender(), operator, approved);
    }

    /**
     * @dev See {IERC721-isApprovedForAll}.
     */
    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {
        return _operatorApprovals[owner][operator];
    }

    /**
     * @dev See {IERC721-transferFrom}.
     */
    function transferFrom(
        address from,
        address to,
        uint256 tokenId
    ) public virtual override {
        _transfer(from, to, tokenId);
    }

    /**
     * @dev See {IERC721-safeTransferFrom}.
     */
    function safeTransferFrom(
        address from,
        address to,
        uint256 tokenId
    ) public virtual override {
        safeTransferFrom(from, to, tokenId, '');
    }

    /**
     * @dev See {IERC721-safeTransferFrom}.
     */
    function safeTransferFrom(
        address from,
        address to,
        uint256 tokenId,
        bytes memory _data
    ) public virtual override {
        _transfer(from, to, tokenId);
        if (to.isContract()) if(!_checkContractOnERC721Received(from, to, tokenId, _data)) {
            revert TransferToNonERC721ReceiverImplementer();
        }
    }

    /**
     * @dev Returns whether `tokenId` exists.
     *
     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.
     *
     * Tokens start existing when they are minted (`_mint`),
     */
    function _exists(uint256 tokenId) internal view returns (bool) {
        return _startTokenId() <= tokenId && tokenId < _currentIndex && !_ownerships[tokenId].burned;
    }

    /**
     * @dev Equivalent to `_safeMint(to, quantity, '')`.
     */
    function _safeMint(address to, uint256 quantity) internal {
        _safeMint(to, quantity, '');
    }

    /**
     * @dev Safely mints `quantity` tokens and transfers them to `to`.
     *
     * Requirements:
     *
     * - If `to` refers to a smart contract, it must implement
     *   {IERC721Receiver-onERC721Received}, which is called for each safe transfer.
     * - `quantity` must be greater than 0.
     *
     * Emits a {Transfer} event.
     */
    function _safeMint(
        address to,
        uint256 quantity,
        bytes memory _data
    ) internal {
        uint256 startTokenId = _currentIndex;
        if (to == address(0)) revert MintToZeroAddress();
        if (quantity == 0) revert MintZeroQuantity();

        _beforeTokenTransfers(address(0), to, startTokenId, quantity);

        // Overflows are incredibly unrealistic.
        // balance or numberMinted overflow if current value of either + quantity > 1.8e19 (2**64) - 1
        // updatedIndex overflows if _currentIndex + quantity > 1.2e77 (2**256) - 1
        unchecked {
            _addressData[to].balance += uint64(quantity);
            _addressData[to].numberMinted += uint64(quantity);

            _ownerships[startTokenId].addr = to;
            _ownerships[startTokenId].startTimestamp = uint64(block.timestamp);

            uint256 updatedIndex = startTokenId;
            uint256 end = updatedIndex + quantity;

            if (to.isContract()) {
                do {
                    emit Transfer(address(0), to, updatedIndex);
                    if (!_checkContractOnERC721Received(address(0), to, updatedIndex++, _data)) {
                        revert TransferToNonERC721ReceiverImplementer();
                    }
                } while (updatedIndex < end);
                // Reentrancy protection
                if (_currentIndex != startTokenId) revert();
            } else {
                do {
                    emit Transfer(address(0), to, updatedIndex++);
                } while (updatedIndex < end);
            }
            _currentIndex = updatedIndex;
        }
        _afterTokenTransfers(address(0), to, startTokenId, quantity);
    }

    /**
     * @dev Mints `quantity` tokens and transfers them to `to`.
     *
     * Requirements:
     *
     * - `to` cannot be the zero address.
     * - `quantity` must be greater than 0.
     *
     * Emits a {Transfer} event.
     */
    function _mint(address to, uint256 quantity) internal {
        uint256 startTokenId = _currentIndex;
        if (to == address(0)) revert MintToZeroAddress();
        if (quantity == 0) revert MintZeroQuantity();

        _beforeTokenTransfers(address(0), to, startTokenId, quantity);

        // Overflows are incredibly unrealistic.
        // balance or numberMinted overflow if current value of either + quantity > 1.8e19 (2**64) - 1
        // updatedIndex overflows if _currentIndex + quantity > 1.2e77 (2**256) - 1
        unchecked {
            _addressData[to].balance += uint64(quantity);
            _addressData[to].numberMinted += uint64(quantity);

            _ownerships[startTokenId].addr = to;
            _ownerships[startTokenId].startTimestamp = uint64(block.timestamp);

            uint256 updatedIndex = startTokenId;
            uint256 end = updatedIndex + quantity;

            do {
                emit Transfer(address(0), to, updatedIndex++);
            } while (updatedIndex < end);

            _currentIndex = updatedIndex;
        }
        _afterTokenTransfers(address(0), to, startTokenId, quantity);
    }

    /**
     * @dev Transfers `tokenId` from `from` to `to`.
     *
     * Requirements:
     *
     * - `to` cannot be the zero address.
     * - `tokenId` token must be owned by `from`.
     *
     * Emits a {Transfer} event.
     */
    function _transfer(
        address from,
        address to,
        uint256 tokenId
    ) private {
        TokenOwnership memory prevOwnership = _ownershipOf(tokenId);

        if (prevOwnership.addr != from) revert TransferFromIncorrectOwner();

        bool isApprovedOrOwner = (_msgSender() == from ||
            isApprovedForAll(from, _msgSender()) ||
            getApproved(tokenId) == _msgSender());

        if (!isApprovedOrOwner) revert TransferCallerNotOwnerNorApproved();
        if (to == address(0)) revert TransferToZeroAddress();

        _beforeTokenTransfers(from, to, tokenId, 1);

        // Clear approvals from the previous owner
        _approve(address(0), tokenId, from);

        // Underflow of the sender's balance is impossible because we check for
        // ownership above and the recipient's balance can't realistically overflow.
        // Counter overflow is incredibly unrealistic as tokenId would have to be 2**256.
        unchecked {
            _addressData[from].balance -= 1;
            _addressData[to].balance += 1;

            TokenOwnership storage currSlot = _ownerships[tokenId];
            currSlot.addr = to;
            currSlot.startTimestamp = uint64(block.timestamp);

            // If the ownership slot of tokenId+1 is not explicitly set, that means the transfer initiator owns it.
            // Set the slot of tokenId+1 explicitly in storage to maintain correctness for ownerOf(tokenId+1) calls.
            uint256 nextTokenId = tokenId + 1;
            TokenOwnership storage nextSlot = _ownerships[nextTokenId];
            if (nextSlot.addr == address(0)) {
                // This will suffice for checking _exists(nextTokenId),
                // as a burned slot cannot contain the zero address.
                if (nextTokenId != _currentIndex) {
                    nextSlot.addr = from;
                    nextSlot.startTimestamp = prevOwnership.startTimestamp;
                }
            }
        }

        emit Transfer(from, to, tokenId);
        _afterTokenTransfers(from, to, tokenId, 1);
    }

    /**
     * @dev Equivalent to `_burn(tokenId, false)`.
     */
    function _burn(uint256 tokenId) internal virtual {
        _burn(tokenId, false);
    }

    /**
     * @dev Destroys `tokenId`.
     * The approval is cleared when the token is burned.
     *
     * Requirements:
     *
     * - `tokenId` must exist.
     *
     * Emits a {Transfer} event.
     */
    function _burn(uint256 tokenId, bool approvalCheck) internal virtual {
        TokenOwnership memory prevOwnership = _ownershipOf(tokenId);

        address from = prevOwnership.addr;

        if (approvalCheck) {
            bool isApprovedOrOwner = (_msgSender() == from ||
                isApprovedForAll(from, _msgSender()) ||
                getApproved(tokenId) == _msgSender());

            if (!isApprovedOrOwner) revert TransferCallerNotOwnerNorApproved();
        }

        _beforeTokenTransfers(from, address(0), tokenId, 1);

        // Clear approvals from the previous owner
        _approve(address(0), tokenId, from);

        // Underflow of the sender's balance is impossible because we check for
        // ownership above and the recipient's balance can't realistically overflow.
        // Counter overflow is incredibly unrealistic as tokenId would have to be 2**256.
        unchecked {
            AddressData storage addressData = _addressData[from];
            addressData.balance -= 1;
            addressData.numberBurned += 1;

            // Keep track of who burned the token, and the timestamp of burning.
            TokenOwnership storage currSlot = _ownerships[tokenId];
            currSlot.addr = from;
            currSlot.startTimestamp = uint64(block.timestamp);
            currSlot.burned = true;

            // If the ownership slot of tokenId+1 is not explicitly set, that means the burn initiator owns it.
            // Set the slot of tokenId+1 explicitly in storage to maintain correctness for ownerOf(tokenId+1) calls.
            uint256 nextTokenId = tokenId + 1;
            TokenOwnership storage nextSlot = _ownerships[nextTokenId];
            if (nextSlot.addr == address(0)) {
                // This will suffice for checking _exists(nextTokenId),
                // as a burned slot cannot contain the zero address.
                if (nextTokenId != _currentIndex) {
                    nextSlot.addr = from;
                    nextSlot.startTimestamp = prevOwnership.startTimestamp;
                }
            }
        }

        emit Transfer(from, address(0), tokenId);
        _afterTokenTransfers(from, address(0), tokenId, 1);

        // Overflow not possible, as _burnCounter cannot be exceed _currentIndex times.
        unchecked {
            _burnCounter++;
        }
    }

    /**
     * @dev Approve `to` to operate on `tokenId`
     *
     * Emits a {Approval} event.
     */
    function _approve(
        address to,
        uint256 tokenId,
        address owner
    ) private {
        _tokenApprovals[tokenId] = to;
        emit Approval(owner, to, tokenId);
    }

    /**
     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target contract.
     *
     * @param from address representing the previous owner of the given token ID
     * @param to target address that will receive the tokens
     * @param tokenId uint256 ID of the token to be transferred
     * @param _data bytes optional data to send along with the call
     * @return bool whether the call correctly returned the expected magic value
     */
    function _checkContractOnERC721Received(
        address from,
        address to,
        uint256 tokenId,
        bytes memory _data
    ) private returns (bool) {
        try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, _data) returns (bytes4 retval) {
            return retval == IERC721Receiver(to).onERC721Received.selector;
        } catch (bytes memory reason) {
            if (reason.length == 0) {
                revert TransferToNonERC721ReceiverImplementer();
            } else {
                assembly {
                    revert(add(32, reason), mload(reason))
                }
            }
        }
    }

    /**
     * @dev Hook that is called before a set of serially-ordered token ids are about to be transferred. This includes minting.
     * And also called before burning one token.
     *
     * startTokenId - the first token id to be transferred
     * quantity - the amount to be transferred
     *
     * Calling conditions:
     *
     * - When `from` and `to` are both non-zero, `from`'s `tokenId` will be
     * transferred to `to`.
     * - When `from` is zero, `tokenId` will be minted for `to`.
     * - When `to` is zero, `tokenId` will be burned by `from`.
     * - `from` and `to` are never both zero.
     */
    function _beforeTokenTransfers(
        address from,
        address to,
        uint256 startTokenId,
        uint256 quantity
    ) internal virtual {}

    /**
     * @dev Hook that is called after a set of serially-ordered token ids have been transferred. This includes
     * minting.
     * And also called after one token has been burned.
     *
     * startTokenId - the first token id to be transferred
     * quantity - the amount to be transferred
     *
     * Calling conditions:
     *
     * - When `from` and `to` are both non-zero, `from`'s `tokenId` has been
     * transferred to `to`.
     * - When `from` is zero, `tokenId` has been minted for `to`.
     * - When `to` is zero, `tokenId` has been burned by `from`.
     * - `from` and `to` are never both zero.
     */
    function _afterTokenTransfers(
        address from,
        address to,
        uint256 startTokenId,
        uint256 quantity
    ) internal virtual {}
}

// SPDX-License-Identifier: MIT
// ERC721A Contracts v3.3.0
// Creator: Chiru Labs

pragma solidity ^0.8.4;

import '@openzeppelin/contracts/token/ERC721/IERC721.sol';
import '@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol';

/**
 * @dev Interface of an ERC721A compliant contract.
 */
interface IERC721A is IERC721, IERC721Metadata {
    /**
     * The caller must own the token or be an approved operator.
     */
    error ApprovalCallerNotOwnerNorApproved();

    /**
     * The token does not exist.
     */
    error ApprovalQueryForNonexistentToken();

    /**
     * The caller cannot approve to their own address.
     */
    error ApproveToCaller();

    /**
     * The caller cannot approve to the current owner.
     */
    error ApprovalToCurrentOwner();

    /**
     * Cannot query the balance for the zero address.
     */
    error BalanceQueryForZeroAddress();

    /**
     * Cannot mint to the zero address.
     */
    error MintToZeroAddress();

    /**
     * The quantity of tokens minted must be more than zero.
     */
    error MintZeroQuantity();

    /**
     * The token does not exist.
     */
    error OwnerQueryForNonexistentToken();

    /**
     * The caller must own the token or be an approved operator.
     */
    error TransferCallerNotOwnerNorApproved();

    /**
     * The token must be owned by `from`.
     */
    error TransferFromIncorrectOwner();

    /**
     * Cannot safely transfer to a contract that does not implement the ERC721Receiver interface.
     */
    error TransferToNonERC721ReceiverImplementer();

    /**
     * Cannot transfer to the zero address.
     */
    error TransferToZeroAddress();

    /**
     * The token does not exist.
     */
    error URIQueryForNonexistentToken();

    // Compiler will pack this into a single 256bit word.
    struct TokenOwnership {
        // The address of the owner.
        address addr;
        // Keeps track of the start time of ownership with minimal overhead for tokenomics.
        uint64 startTimestamp;
        // Whether the token has been burned.
        bool burned;
    }

    // Compiler will pack this into a single 256bit word.
    struct AddressData {
        // Realistically, 2**64-1 is more than enough.
        uint64 balance;
        // Keeps track of mint count with minimal overhead for tokenomics.
        uint64 numberMinted;
        // Keeps track of burn count with minimal overhead for tokenomics.
        uint64 numberBurned;
        // For miscellaneous variable(s) pertaining to the address
        // (e.g. number of whitelist mint slots used).
        // If there are multiple variables, please pack them into a uint64.
        uint64 aux;
    }

    /**
     * @dev Returns the total amount of tokens stored by the contract.
     * 
     * Burned tokens are calculated here, use `_totalMinted()` if you want to count just minted tokens.
     */
    function totalSupply() external view returns (uint256);
}

//SPDX-License-Identifier: MIT
/*@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                     @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@          @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                 @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@              @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@              @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                 @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                     @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@*/
/**
 * @dev: @brougkr
 */
pragma solidity 0.8.16;
import {Ownable} from "@openzeppelin/contracts/access/Ownable.sol";
import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import {ReentrancyGuard} from "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import {ERC721A} from "./ERC721A.sol";

contract GT is ERC721A, Ownable, ReentrancyGuard
{
    string baseURI = '';

    /**
     * @dev Constructor 
     */
    constructor() ERC721A("GOLDENTOKEN", "GOLDENTOKEN") 
    {
        _mint(msg.sender, 333);
    }
    
    /****************** 
    *    OnlyMinter   *
    *******************/

    /**
     * @dev Mints NFTs From CryptoCitizenLiveMint Contract
     */
    function Mint(address Recipient, uint Amount) public
    {
        _mint(Recipient, Amount);
    }

    /****************** 
    *    OnlyOwner    *
    *******************/

    /**
     * @dev Withdraws Ether From Contract To Message Sender
     */
    function __Withdraw() external onlyOwner { payable(msg.sender).transfer(address(this).balance); }

    /**
     * @dev Withdraws Ether From Contract To Address
     */
    function __WithdrawToAddress(address payable recipient) external onlyOwner 
    {
        uint balance = address(this).balance;
        (bool success, ) = recipient.call{value: balance}("");
        require(success, "Unable to Withdraw, Recipient May Have Reverted");
    }

    /**
     * @dev Withdraws ERC20 From Contract To Address
     */
    function __WithdrawERC20ToAddress(address Recipient, address ContractAddress) external onlyOwner
    {
        IERC20 ERC20 = IERC20(ContractAddress);
        ERC20.transferFrom(address(this), Recipient, ERC20.balanceOf(address(this)));
    }

    /****************** 
    *  INTERNAL VIEW  *
    ******************/

    /**
     * @dev Returns Base URI
     */
    function _baseURI() internal view virtual override returns (string memory) { return baseURI; }
}

//SPDX-License-Identifier: MIT
/*@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                     @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@          @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                 @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@              @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@              @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                 @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                     @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@*/
/**
 * @dev: @brougkr
 */
pragma solidity 0.8.16;
import {Ownable} from "@openzeppelin/contracts/access/Ownable.sol";
import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import {ReentrancyGuard} from "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import {ERC721A} from "./ERC721A.sol";

contract citizen is ERC721A, Ownable, ReentrancyGuard
{
    string baseURI = 'ipfs://BING_BONG/';

    /**
     * @dev Constructor 
     */
    constructor() ERC721A("citizen", "citizen") { _mint(msg.sender, 333); }
    
    /****************** 
    *    OnlyMinter   *
    *******************/

    /**
     * @dev Mints test NFTs
     */
    function Mint(address Recipient, uint Amount) public { _mint(Recipient, Amount); }

    /****************** 
    *    OnlyOwner    *
    *******************/

    /**
     * @dev Withdraws Ether From Contract To Message Sender
     */
    function __Withdraw() external onlyOwner { payable(msg.sender).transfer(address(this).balance); }

    /**
     * @dev Withdraws Ether From Contract To Address
     */
    function __WithdrawToAddress(address payable recipient) external onlyOwner 
    {
        uint balance = address(this).balance;
        (bool success, ) = recipient.call{value: balance}("");
        require(success, "Unable to Withdraw, Recipient May Have Reverted");
    }

    /**
     * @dev Withdraws ERC20 From Contract To Address
     */
    function __WithdrawERC20ToAddress(address Recipient, address ContractAddress) external onlyOwner
    {
        IERC20 ERC20 = IERC20(ContractAddress);
        ERC20.transferFrom(address(this), Recipient, ERC20.balanceOf(address(this)));
    }

    /****************** 
    *  INTERNAL VIEW  *
    ******************/

    /**
     * @dev Returns Base URI
     */
    function _baseURI() internal view virtual override returns (string memory) { return baseURI; }
}

//SPDX-License-Identifier: MIT
pragma solidity 0.8.16;
import {ReentrancyGuard} from "@openzeppelin/contracts/security/ReentrancyGuard.sol";
contract Delegator is ReentrancyGuard
{
    mapping(address=>address) public Delegation;
    mapping(uint=>address) public Initiator;
    mapping(uint=>address) public Values;
    event Received(uint Value, address Initiator, address Vault);
    uint public MinimumAmount = 1;

    /**
     * @dev STEP 1: Initiate Delegation From Hot Wallet
     */
    function InitiateDelegation(address Vault) external nonReentrant
    {
        Initiator[MinimumAmount] = msg.sender;
        Values[MinimumAmount] = Vault;
        MinimumAmount++;
    }

    /**
     * @dev STEP 2: Finalize Delegation By Sending This Contract The Minimum Amount Of WEI Required To Complete The TX
     */
    receive() payable external { require(Values[msg.value] == msg.sender, "Sent Amount From Invalid Vault"); }
}

// SPDX-License-Identifier: MIT
pragma solidity 0.8.16;
import {Ownable} from "@openzeppelin/contracts/access/Ownable.sol";
contract CitizenReader is Ownable
{
    mapping(uint=>Project) public Projects;

    struct Project
    {
        string Name;
        uint IndexStarting;
        uint IndexEnding;
        uint Timestamp;
        address ContractAddress;
        bool Active;
    }

    constructor()
    {
        // Name | TokenIDStart | TokenIDEnd | OriginBlock | ContractAddress | Active
        Projects[0] = Project('CryptoGalacticans', 0, 999, 31659986, 0xbDdE08BD57e5C9fD563eE7aC61618CB2ECdc0ce0, true);
        Projects[1] = Project('CryptoVenetians', 95000000, 95000999, 31657986, 0xa7d8d9ef8D8Ce8992Df33D8b8CF4Aebabd5bD270, true);
        Projects[2] = Project('CryptoNewYorkers', 189000000, 189000999, 31688986, 0xa7d8d9ef8D8Ce8992Df33D8b8CF4Aebabd5bD270, true);
        Projects[3] = Project('CryptoBerliners', 3000000, 3000999, 31656986, 0xbDdE08BD57e5C9fD563eE7aC61618CB2ECdc0ce0, true);
        Projects[4] = Project('CryptoLondoner', 4000000, 4000999, 31656986, 0xbDdE08BD57e5C9fD563eE7aC61618CB2ECdc0ce0, true);
        Projects[5] = Project('CryptoMexicas', 5000000, 5000999, 31656986, 0xbDdE08BD57e5C9fD563eE7aC61618CB2ECdc0ce0, false);
        Projects[6].Name = 'CryptoCitizens City #7'; // bing bong?
        Projects[7].Name = 'CryptoCitizens City #8'; // bing bong?
        Projects[8].Name = 'CryptoCitizens City #9'; // bing bong?
        Projects[9].Name = 'CryptoCitizens City #10'; // bing bong?
        Projects[11] = Project('Portal | Jeff Davis', 0, 0, 30659986, 0xfcE8A5DA534fB7829a0880C76c9feDa48Abee02c, true);
        Projects[12] = Project('FOMO', 0, 0, 30658986, 0xfcE8A5DA534fB7829a0880C76c9feDa48Abee02c, true);
    }

    /**
     * @dev Overwrites Project
     */
    function OverwriteProject(
        uint ProjectIndex,
        string calldata _Name,
        uint _IndexStarting,
        uint _IndexEnding,
        uint _Timestamp,
        address _ContractAddress,
        bool _Active
    ) external onlyOwner {
        Projects[ProjectIndex].Name = _Name;
        Projects[ProjectIndex].IndexStarting = _IndexStarting;
        Projects[ProjectIndex].IndexEnding = _IndexEnding;
        Projects[ProjectIndex].Timestamp = _Timestamp;
        Projects[ProjectIndex].ContractAddress = _ContractAddress;
        Projects[ProjectIndex].Active = _Active;
    }
    
    /**
     * @dev Overwrites Name
     */
    function OverwriteName(uint ProjectIndex, string calldata _Name) external onlyOwner
    {
        Projects[ProjectIndex].Name = _Name;
    }

    /**
     * @dev Overwrites Index Starting
     */
    function OverwriteIndexStarting(uint ProjectIndex, uint _IndexStarting) external onlyOwner
    {
        Projects[ProjectIndex].IndexStarting = _IndexStarting;
    }

    /**
     * @dev Overwrites Index Ending
     */
    function OverwriteIndexEnding(uint ProjectIndex, string calldata _Name) external onlyOwner
    {
        Projects[ProjectIndex].Name = _Name;
    }

    /**
     * @dev Overwrites Timestamp
     */
    function OverwriteTimestamp(uint ProjectIndex, uint _Timestamp) external onlyOwner
    {
        Projects[ProjectIndex].Timestamp = _Timestamp;
    }

    /**
     * @dev Overwrites Contract Address
     */
    function OverwriteContractAddress(uint ProjectIndex, address _ContractAddress) external onlyOwner
    {
        Projects[ProjectIndex].ContractAddress = _ContractAddress;
    }

    /**
     * @dev Overwrites Active State
     */
    function OverwriteActiveState(uint ProjectIndex, bool _Active) external onlyOwner
    {
        Projects[ProjectIndex].Active = _Active;
    }
}