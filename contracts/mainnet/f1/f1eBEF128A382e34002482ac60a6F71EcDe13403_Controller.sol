// SPDX-License-Identifier: MIT
pragma solidity 0.8.4;

/// @notice List of all errors generated by the application
///         Each error should have unique code TC-XXX and descriptive comment
library AppErrors {
  /// @notice Provided address should be not zero
  string public constant ZERO_ADDRESS = "TC-1 zero address";
  /// @notice Pool adapter for the given set {converter, user, collateral, borrowToken} not found and cannot be created
  string public constant POOL_ADAPTER_NOT_FOUND = "TC-2 adapter not found";
  /// @notice Health factor is not set or it's less then min allowed value
  string public constant WRONG_HEALTH_FACTOR = "TC-3 wrong health factor";
  /// @notice Received price is zero
  string public constant ZERO_PRICE = "TC-4 zero price";
  /// @notice Given platform adapter is not found in Borrow Manager
  string public constant PLATFORM_ADAPTER_NOT_FOUND = "TC-6 platform adapter not found";
  /// @notice Only pool adapters are allowed to make such operation
  string public constant POOL_ADAPTER_ONLY = "TC-7 pool adapter not found";
  /// @notice Only TetuConverter is allowed to make such operation
  string public constant TETU_CONVERTER_ONLY = "TC-8 tetu converter only";
  /// @notice Only Governance is allowed to make such operation
  string public constant GOVERNANCE_ONLY = "TC-9 governance only";
  /// @notice Cannot close borrow position if the position has not zero collateral or borrow balance
  string public constant ATTEMPT_TO_CLOSE_NOT_EMPTY_BORROW_POSITION = "TC-10 position not empty";
  /// @notice Borrow position is not registered in DebtMonitor
  string public constant BORROW_POSITION_IS_NOT_REGISTERED = "TC-11 position not registered";
  /// @notice Passed arrays should have same length
  string public constant WRONG_LENGTHS = "TC-12 wrong lengths";
  /// @notice Pool adapter expects some amount of collateral on its balance
  string public constant WRONG_COLLATERAL_BALANCE="TC-13 wrong collateral balance";
  /// @notice Pool adapter expects some amount of derivative tokens on its balance after borrowing
  string public constant WRONG_DERIVATIVE_TOKENS_BALANCE="TC-14 wrong ctokens balance";
  /// @notice Pool adapter expects some amount of borrowed tokens on its balance
  string public constant WRONG_BORROWED_BALANCE = "TC-15 wrong borrow balance";
  /// @notice cToken is not found for provided underlying
  string public constant C_TOKEN_NOT_FOUND = "TC-16 ctoken not found";
  /// @notice cToken.mint failed
  string public constant MINT_FAILED = "TC-17 mint failed";
  string public constant COMPTROLLER_GET_ACCOUNT_LIQUIDITY_FAILED = "TC-18 get account liquidity failed";
  string public constant COMPTROLLER_GET_ACCOUNT_LIQUIDITY_UNDERWATER = "TC-19 get account liquidity underwater";
  /// @notice borrow failed
  string public constant BORROW_FAILED = "TC-20 borrow failed";
  string public constant CTOKEN_GET_ACCOUNT_SNAPSHOT_FAILED = "TC-21 snapshot failed";
  string public constant CTOKEN_GET_ACCOUNT_LIQUIDITY_FAILED = "TC-22 liquidity failed";
  string public constant INCORRECT_RESULT_LIQUIDITY = "TC-23 incorrect liquidity";
  string public constant CLOSE_POSITION_FAILED = "TC-24 close position failed";
  string public constant CONVERTER_NOT_FOUND = "TC-25 converter not found";
  string public constant REDEEM_FAILED = "TC-26 redeem failed";
  string public constant REPAY_FAILED = "TC-27 repay failed";
  /// @notice Balance shouldn't be zero
  string public constant ZERO_BALANCE = "TC-28 zero balance";
  string public constant INCORRECT_VALUE = "TC-29 incorrect value";
  /// @notice Only user can make this action
  string public constant USER_ONLY = "TC-30 user only";
  /// @notice It's not allowed to close position with a pool adapter and make re-conversion using the same adapter
  string public constant RECONVERSION_WITH_SAME_CONVERTER_FORBIDDEN = "TC-31 reconversion forbidden";

  /// @notice Platform adapter cannot be unregistered because there is active pool adapter (open borrow on the platform)
  string public constant PLATFORM_ADAPTER_IS_IN_USE = "TC-33 platform adapter is in use";

  string public constant DIVISION_BY_ZERO = "TC-34 division by zero";

  string public constant UNSUPPORTED_CONVERSION_KIND = "TC-35: UNKNOWN CONVERSION";
  string public constant SLIPPAGE_TOO_BIG = "TC-36: SLIPPAGE TOO BIG";

  /// @notice The relation "platform adapter - converter" is invariant.
  ///         It's not allowed to assign new platform adapter to the converter
  string public constant ONLY_SINGLE_PLATFORM_ADAPTER_CAN_USE_CONVERTER = "TC-37 one platform adapter per conv";

  /// @notice Provided health factor value is not applicable for other health factors
  ///         Invariant: min health factor < target health factor < max health factor
  string public constant WRONG_HEALTH_FACTOR_CONFIG = "TC-38: wrong health factor config";

  /// @notice Health factor is not good after rebalancing
  string public constant WRONG_REBALANCING = "TC-39: wrong rebalancing";

  /// @notice It's not allowed to pay debt completely using repayToRebalance
  ///         Please use ordinal repay for this purpose (it allows to receive the collateral)
  string public constant REPAY_TO_REBALANCE_NOT_ALLOWED = "TC-40 repay to rebalance not allowed";

  /// @notice Received amount is different from expected one
  string public constant WRONG_AMOUNT_RECEIVED = "TC-41 wrong amount received";
  /// @notice Only one of the keepers is allowed to make such operation
  string public constant KEEPER_ONLY = "TC-42 keeper only";

  /// @notice The amount cannot be zero
  string public constant ZERO_AMOUNT = "TC-43 zero amount";

  /// @notice Value of "converter" passed to TetuConverter.borrow is incorrect ( != SwapManager address)
  string public constant INCORRECT_CONVERTER_TO_SWAP = "TC-44 incorrect converter";

  string public constant BORROW_MANAGER_ONLY = "TC-45 borrow manager only";

  /// @notice Attempt to make a borrow using unhealthy pool adapter
  ///         This is not normal situation.
  ///         Health factor is greater 1 but it's less then minimum allowed value.
  ///         Keeper doesn't work?
  string public constant REBALANCING_IS_REQUIRED = "TC-46 rebalancing is required";

  /// @notice Position can be closed as "liquidated" only if there is no collateral on it
  string public constant CANNOT_CLOSE_LIVE_POSITION = "TC-47 cannot close live pos";

  string public constant ACCESS_DENIED = "TC-48 access denied";

  /// @notice Value A is less then B, so we will have overflow on A - B, but it's weird situation
  ///         If balance is decreased after a supply or increased after a deposit
  string public constant WEIRD_OVERFLOW = "TC-49 weird overflow";

  string public constant AMOUNT_TOO_BIG = "TC-50 amount too big";

  string public constant NOT_PENDING_GOVERNANCE = "TC-51 not pending gov";

  string public constant INCORRECT_OPERATION = "TC-52 incorrect op";

  string public constant ONLY_SWAP_MANAGER = "TC-53 swap manager only";
}

// SPDX-License-Identifier: MIT
pragma solidity 0.8.4;

import "../interfaces/IController.sol";
import "./AppErrors.sol";
import "../openzeppelin/Initializable.sol";

/// @notice Keep and provide addresses of all application contracts
contract Controller is IController, Initializable {
  uint16 constant MIN_ALLOWED_MIN_HEALTH_FACTOR = 100;

  // We cannot use immutable variables, because each contract should get address of the controller in the constructor

  /// @notice Main application contract, strategy works only with it
  address public override tetuConverter;

  /// @notice Contains list of lending pools. Allow to select most efficient pool for the given collateral/borrow pair
  address public override borrowManager;

  /// @notice Contains list of opened borrows, check healths of the borrows
  address public override debtMonitor;

  /// @notice A keeper to control health of the borrows
  address public override keeper;

  /// @notice Allow to swap assets
  address public override tetuLiquidator;

  /// @notice Wrapper around tetu-liquidator
  address public override swapManager;

  /// @notice Price oracle, required by SwapManager
  address public override priceOracle;

  /// @notice Current governance. It can be changed by offer/accept scheme
  address public override governance;
  /// @notice New governance suggested by exist governance
  address public pendingGovernance;

  /// @notice Min allowed health factor = collateral / min allowed collateral, decimals 2
  ///         If a health factor is below given value, we need to repay a part of borrow back
  /// @dev Health factor < 1 produces liquidation immediately
  uint16 public override minHealthFactor2;

  /// @notice target health factor with decimals 2
  /// @dev If the health factor is below/above min/max threshold, we need to make repay
  ///      or additional borrow and restore the health factor to the given target value
  uint16 public override targetHealthFactor2;

  /// @notice max allowed health factor with decimals 2
  /// @dev If a health factor is above given value, we CAN make additional borrow
  ///      using exist collateral
  uint16 public override maxHealthFactor2;

  /// @notice Count of blocks per day, updatable
  uint public override blocksPerDay;

  /// @notice When blocksPerDay was updated last time
  ///         0 - auto-update is disabled
  uint public lastBlockNumber;
  uint public lastBlockTimestamp;

  ///////////////////////////////////////////////////////
  ///               Events
  ///////////////////////////////////////////////////////
  event OnSetBlocksPerDay(uint blocksPerDay, bool enableAutoUpdate);
  event OnAutoUpdateBlocksPerDay(uint blocksPerDay);
  event OnSetMinHealthFactor2(uint16 value);
  event OnSetTargetHealthFactor2(uint16 value);
  event OnSetMaxHealthFactor2(uint16 value);
  event OnSetGovernance(address newGovernance);
  event OnAcceptGovernance(address pendingGovernance);

  ///////////////////////////////////////////////////////
  ///        Constructor and Initialization
  ///////////////////////////////////////////////////////

  function initialize(
    address governance_,
    uint blocksPerDay_,
    uint16 minHealthFactor_,
    uint16 targetHealthFactor_,
    uint16 maxHealthFactor_,
    address tetuConverter_,
    address borrowManager_,
    address debtMonitor_,
    address keeper_,
    address tetuLiquidator_,
    address swapManager_,
    address priceOracle_
  ) external initializer {
    require(blocksPerDay_ != 0, AppErrors.INCORRECT_VALUE);
    require(minHealthFactor_ > MIN_ALLOWED_MIN_HEALTH_FACTOR, AppErrors.WRONG_HEALTH_FACTOR);
    require(minHealthFactor_ < targetHealthFactor_, AppErrors.WRONG_HEALTH_FACTOR_CONFIG);
    require(targetHealthFactor_ < maxHealthFactor_, AppErrors.WRONG_HEALTH_FACTOR_CONFIG);
    require(
      governance_ != address(0)
      && tetuConverter_ != address(0)
      && borrowManager_ != address(0)
      && debtMonitor_ != address(0)
      && keeper_ != address(0)
      && tetuLiquidator_ != address(0)
      && swapManager_ != address(0)
      && priceOracle_ != address(0),
      AppErrors.ZERO_ADDRESS
    );
    governance = governance_;
    tetuConverter = tetuConverter_;
    borrowManager = borrowManager_;
    debtMonitor = debtMonitor_;
    keeper = keeper_;
    tetuLiquidator = tetuLiquidator_;
    swapManager = swapManager_;
    priceOracle = priceOracle_;

    blocksPerDay = blocksPerDay_;
    // by default auto-update of blocksPerDay is disabled
    // it's necessary to call setBlocksPerDay to enable it

    minHealthFactor2 = minHealthFactor_;
    maxHealthFactor2 = maxHealthFactor_;
    targetHealthFactor2 = targetHealthFactor_;
  }

  function _onlyGovernance() internal view {
    require (msg.sender == governance, AppErrors.GOVERNANCE_ONLY);
  }

  ///////////////////////////////////////////////////////
  ///               Blocks per day
  ///////////////////////////////////////////////////////

  /// @notice Manually set value of blocksPerDay and enable/disable its auto-update
  ///         If the update is enabled, the first update will happen in BLOCKS_PER_DAY_AUTO_UPDATE_PERIOD_SECS seconds
  function setBlocksPerDay(uint blocksPerDay_, bool enableAutoUpdate_) external override {
    require(blocksPerDay_ != 0, AppErrors.INCORRECT_VALUE);
    _onlyGovernance();
    blocksPerDay = blocksPerDay_;
    if (enableAutoUpdate_) {
      lastBlockNumber = block.number;
      lastBlockTimestamp = block.timestamp;
    } else {
      lastBlockNumber = 0;
      lastBlockTimestamp = 0;
    }
    emit OnSetBlocksPerDay(blocksPerDay_, enableAutoUpdate_);
  }

  /// @notice Check if blocksPerDay should be updated. The keeper should do it periodically
  function isBlocksPerDayAutoUpdateRequired(uint periodInSeconds_) external view override returns (bool) {
    return lastBlockNumber != 0 && block.timestamp - lastBlockTimestamp > periodInSeconds_;
  }

  /// @notice Calculate new value of blocksPerDay as COUNT PASSED BLOCKS / COUNT PASSED DAYS (since prev auto-update)
  function updateBlocksPerDay(uint periodInSeconds_) external override {
    require(msg.sender == keeper, AppErrors.KEEPER_ONLY);
    require(lastBlockNumber != 0,
      // && lastBlockNumber != block.number       // this check is unnecessary
      AppErrors.INCORRECT_OPERATION               // setBlocksPerDay is called by governance
    );                                            // but updateBlocksPerDay is called by keeper
                                                  // so, they cannot be called in the same block
    require(
      periodInSeconds_ != 0
      && lastBlockTimestamp + periodInSeconds_ <= block.timestamp,
      AppErrors.INCORRECT_VALUE
    );
    // blocks-per-day = count passed blocks / count passed days
    // count passed days = count passed seconds / count seconds per day
    blocksPerDay = (block.number - lastBlockNumber) * (24 * 60 * 60) / (block.timestamp - lastBlockTimestamp);

    lastBlockNumber = block.number;
    lastBlockTimestamp = block.timestamp;

    emit OnAutoUpdateBlocksPerDay(blocksPerDay);
  }

  ///////////////////////////////////////////////////////
  ///             Set up health factors
  ///  min/max thresholds and a target value for reconversion
  ///////////////////////////////////////////////////////

  /// @notice min allowed health factor with decimals 2
  function setMinHealthFactor2(uint16 value_) external override {
    require(value_ > MIN_ALLOWED_MIN_HEALTH_FACTOR, AppErrors.WRONG_HEALTH_FACTOR);
    require(value_ < targetHealthFactor2, AppErrors.WRONG_HEALTH_FACTOR_CONFIG);
    _onlyGovernance();
    minHealthFactor2 = value_;
    emit OnSetMinHealthFactor2(value_);
  }

  /// @notice target health factor with decimals 2
  /// @dev If the health factor is below/above min/max threshold, we need to make repay
  ///      or additional borrow and restore the health factor to the given target value
  function setTargetHealthFactor2(uint16 value_) external override {
    require(value_ > minHealthFactor2, AppErrors.WRONG_HEALTH_FACTOR_CONFIG);
    require(value_ < maxHealthFactor2, AppErrors.WRONG_HEALTH_FACTOR_CONFIG);
    _onlyGovernance();
    targetHealthFactor2 = value_;
    emit OnSetTargetHealthFactor2(value_);
  }

  /// @notice max allowed health factor with decimals 2
  function setMaxHealthFactor2(uint16 value_) external override {
    require(value_ > targetHealthFactor2, AppErrors.WRONG_HEALTH_FACTOR_CONFIG);
    _onlyGovernance();
    maxHealthFactor2 = value_;
    emit OnSetMaxHealthFactor2(value_);
  }

  ///////////////////////////////////////////////////////
  ///               Governance
  ///////////////////////////////////////////////////////

  /// @notice Suggest to change governance
  function setGovernance(address newGovernance_) external {
    _onlyGovernance();
    require(newGovernance_ != address(0), AppErrors.ZERO_ADDRESS);

    pendingGovernance = newGovernance_;
    emit OnSetGovernance(newGovernance_);
  }

  /// @notice Old governance has suggested to change governance.
  ///         Newly suggested governance must accept the change to actually change the governance.
  function acceptGovernance() external {
    require(pendingGovernance == msg.sender, AppErrors.NOT_PENDING_GOVERNANCE);

    governance = pendingGovernance;
    emit OnAcceptGovernance(pendingGovernance);
  }
}

// SPDX-License-Identifier: MIT

pragma solidity 0.8.4;

/// @notice Keep and provide addresses of all application contracts
interface IController {
  function governance() external view returns (address);

  /// @notice min allowed health factor with decimals 2
  function minHealthFactor2() external view returns (uint16);
  function setMinHealthFactor2(uint16 value_) external;

  /// @notice max allowed health factor with decimals 2
  function maxHealthFactor2() external view returns (uint16);
  function setMaxHealthFactor2(uint16 value_) external;

  /// @notice target health factor with decimals 2
  /// @dev If the health factor is below/above min/max threshold, we need to make repay
  ///      or additional borrow and restore the health factor to the given target value
  function targetHealthFactor2() external view returns (uint16);
  function setTargetHealthFactor2(uint16 value_) external;

  /// @notice get current value of blocks per day. The value is set manually at first and can be auto-updated later
  function blocksPerDay() external view returns (uint);
  /// @notice set value of blocks per day manually and enable/disable auto update of this value
  function setBlocksPerDay(uint blocksPerDay_, bool enableAutoUpdate_) external;
  /// @notice Check if it's time to call updateBlocksPerDay()
  /// @param periodInSeconds_ Period of auto-update in seconds
  function isBlocksPerDayAutoUpdateRequired(uint periodInSeconds_) external view returns (bool);
  /// @notice Recalculate blocksPerDay value
  /// @param periodInSeconds_ Period of auto-update in seconds
  function updateBlocksPerDay(uint periodInSeconds_) external;


  ///////////////////////////////////////////////////////
  ///        Core application contracts
  ///////////////////////////////////////////////////////

  function tetuConverter() external view returns (address);
  function borrowManager() external view returns (address);
  function debtMonitor() external view returns (address);
  function tetuLiquidator() external view returns (address);
  function swapManager() external view returns (address);
  function priceOracle() external view returns (address);

  ///////////////////////////////////////////////////////
  ///        External contracts
  ///////////////////////////////////////////////////////
  /// @notice A keeper to control health and efficiency of the borrows
  function keeper() external view returns (address);

}

// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

/**
 * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed
 * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an
 * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer
 * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.
 *
 * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as
 * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.
 *
 * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure
 * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.
 */
abstract contract Initializable {
  /// @notice Initializable: contract is already initialized
  error ErrorAlreadyInitialized();

  /**
   * @dev Indicates that the contract has been initialized.
   */
  bool private _initialized;

  /**
   * @dev Indicates that the contract is in the process of being initialized.
   */
  bool private _initializing;

  /**
   * @dev Modifier to protect an initializer function from being invoked twice.
   */
  modifier initializer() {
    if (!_initializing && _initialized) {
      revert ErrorAlreadyInitialized();
    }

    bool isTopLevelCall = !_initializing;
    if (isTopLevelCall) {
      _initializing = true;
      _initialized = true;
    }

    _;

    if (isTopLevelCall) {
      _initializing = false;
    }
  }
}