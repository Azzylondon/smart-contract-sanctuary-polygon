// SPDX-License-Identifier: MIT
pragma solidity 0.8.12;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import "@openzeppelin/contracts/token/ERC721/IERC721.sol";
import "@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol";
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import "./DubiexLib.sol";

contract Dubiex is ReentrancyGuard, ERC721Holder {
    using SafeERC20 for IERC20;

    // This is a empty order to workaround:
    // "This variable is of storage pointer type and can be accessed without prior assignment, which would lead to undefined behaviour"
    // In places where we need to return a zero-initialized storage order.
    DubiexLib.PackedOrderBookItem private _emptyOrder;

    address private immutable _prps;
    address private immutable _dubi;

    // Security mechanism which anyone can enable if the total supply of PRPS or DUBI should ever go >= 1 billion
    bool private _killSwitchOn;

    function activateKillSwitch() public {
        require(!_killSwitchOn, "Dubiex: kill switch already on");

        uint256 oneBillion = 1000000000 * 1 ether;

        uint256 totalPrpsSupply = IERC20(_prps).totalSupply();
        uint256 totalDubiSupply = IERC20(_dubi).totalSupply();

        require(
            totalPrpsSupply >= oneBillion || totalDubiSupply >= oneBillion,
            "Dubiex: total supply too low"
        );
        _killSwitchOn = true;
    }

    constructor(address prps, address dubi) ReentrancyGuard() {
        _prps = prps;
        _dubi = dubi;
    }

    event MadeOrder(
        uint32 id,
        address maker,
        DubiexLib.OrderPair orderPair,
        // uint96 makerValue, uint96 takerValue, uint32 orderPairAlias, uint32 padding
        uint256 packedData
    );

    event TookOrder(
        uint32 id,
        address maker,
        address taker,
        // uint96 makerValue, uint96 takerValue, uint32 orderPairAlias, uint32 padding
        uint256 packedData
    );
    event CanceledOrder(address maker, uint32 id);

    event UpdatedOrder(address maker, uint32 id, uint256 updatedRatioWei);

    /**
     * @dev Order pair aliases are generated by incrementing a number. Although the counter
     * is using 32 bits, we do not support more than 2**28 = 268_435_456 pairs for technical reasons.
     */
    uint32 private _orderPairAliasCounter;

    /**
     * @dev A mapping of order pair alias to a packed order pair.
     */
    mapping(uint32 => DubiexLib.PackedOrderPair) private _orderPairsByAlias;
    /**
     * @dev A reverse mapping of order pair hash to an order pair alias. Required to check if
     * a given pair already exists when creating an order where the full pair information are
     * provided instead of an alias. I.e.
     * MakeOrder {
     *    ...
     *    makerCurrencyType: ...,
     *    takerCurrencyType: ...,
     *    makerContractAddress: ...,
     *    takerContractAddress: ...,
     * }
     *
     * The hash of these four fields is used as the key of the mapping.
     */
    mapping(bytes32 => uint32) private _orderPairAliasesByHash;

    /**
     * @dev Mapping of address to a counter for order ids.
     */
    mapping(address => uint32) private _counters;

    /**
     * @dev Mapping of orderKey (keccak256(abi.encode(maker, orderId))) to packed order book items.
     */
    mapping(bytes32 => DubiexLib.PackedOrderBookItem) private _packedOrders;

    /**
     * @dev Get an order by id. If the id doesn't exist (e.g. got cancelled / filled), a default order is returned.
     * The caller should therefore check the id of the returned item. Any non-zero value means the order exists.
     */
    function getOrder(address maker, uint32 id)
        public
        view
        returns (DubiexLib.PrettyOrderBookItem memory)
    {
        bytes32 key = DubiexLib.getOrderKey(maker, id);
        DubiexLib.PackedOrderBookItem storage _packed = _packedOrders[key];
        if (_packed.packedData == 0) {
            DubiexLib.PrettyOrderBookItem memory empty;
            return empty;
        }

        DubiexLib.UnpackedOrderBookItem memory _unpacked = DubiexLib
            .unpackOrderBookItem(_packed.packedData);

        DubiexLib.PrettyOrderBookItem memory pretty;
        pretty.id = _unpacked.id;
        pretty.makerValue = _unpacked.makerValue;
        pretty.takerValue = _unpacked.takerValue;

        pretty.orderPairAlias = _unpacked.orderPairAlias;
        pretty.pair = getOrderPairByAlias(_unpacked.orderPairAlias);

        pretty.flags = _unpacked.flags;

        return pretty;
    }

    /**
     * @dev Get an order pair by alias.
     */
    function getOrderPairByAlias(uint32 orderPairAlias)
        public
        view
        returns (DubiexLib.OrderPair memory)
    {
        DubiexLib.OrderPair memory orderPair;

        DubiexLib.PackedOrderPair storage packedOrderPair = _orderPairsByAlias[
            orderPairAlias
        ];

        (
            address makerContractAddress,
            DubiexLib.CurrencyType makerCurrencyType
        ) = DubiexLib.unpackOrderPairAddressType(packedOrderPair.makerPair);

        (
            address takerContractAddress,
            DubiexLib.CurrencyType takerCurrencyType
        ) = DubiexLib.unpackOrderPairAddressType(packedOrderPair.takerPair);

        orderPair.makerContractAddress = makerContractAddress;
        orderPair.makerCurrencyType = makerCurrencyType;
        orderPair.takerContractAddress = takerContractAddress;
        orderPair.takerCurrencyType = takerCurrencyType;

        return orderPair;
    }

    /**
     * @dev Get an order pair by it's hash.
     */
    function getOrderPairByHash(bytes32 orderPairHash)
        public
        view
        returns (DubiexLib.OrderPair memory)
    {
        uint32 orderPairAlias = _orderPairAliasesByHash[orderPairHash];
        return getOrderPairByAlias(orderPairAlias);
    }

    /**
     * @dev Get an order pair alias by it's hash.
     */
    function getOrderPairAliasByHash(bytes32 orderPairHash)
        public
        view
        returns (uint32)
    {
        return _orderPairAliasesByHash[orderPairHash];
    }

    /**
     * @dev Make a single order. Reverts on failure.
     *
     * If an `orderId` is provided, an already existing order will be updated
     * according to `updatedWeiRatio`. For efficiency reasons, the id of the updated order
     * remains the same. Taker orders provide a minimum ratio to protect themselves against
     * front-running by the maker.
     *
     * Returns the assigned order id.
     */
    function makeOrder(DubiexLib.MakeOrderInput memory input)
        external
        payable
        nonReentrant
        returns (uint32)
    {
        require(!_killSwitchOn, "Dubiex: kill switch on");

        uint256 excessEth = msg.value;
        uint32 orderId;

        (orderId, excessEth) = _makeOrderInternal({
            input: input,
            maker: payable(msg.sender),
            excessEth: excessEth,
            revertOnUpdateError: true
        });

        _refundExcessEth(excessEth);

        return orderId;
    }

    /**
     * @dev Create multiple orders at once. The transaction won't revert if any make order fails, but
     * silently ignore it. Returns an array of order ids where each item corresponds to an input
     * at the same index and non-zero values indicate success.
     */
    function makeOrders(DubiexLib.MakeOrderInput[] memory inputs)
        external
        payable
        nonReentrant
        returns (uint32[] memory)
    {
        require(!_killSwitchOn, "Dubiex: kill switch on");
        require(inputs.length > 0, "Dubiex: empty inputs");

        uint32[] memory orderIds = new uint32[](inputs.length);

        uint256 excessEth = msg.value;

        for (uint256 i = 0; i < inputs.length; i++) {
            uint32 orderId;

            (orderId, excessEth) = _makeOrderInternal({
                input: inputs[i],
                maker: payable(msg.sender),
                excessEth: excessEth,
                revertOnUpdateError: false
            });

            orderIds[i] = orderId;
        }

        _refundExcessEth(excessEth);

        return orderIds;
    }

    /**
     * @dev Take a single order. Reverts on failure.
     */
    function takeOrder(DubiexLib.TakeOrderInput calldata input)
        external
        payable
        nonReentrant
    {
        require(!_killSwitchOn, "Dubiex: kill switch on");

        uint256 excessEth = msg.value;

        (, excessEth, ) = _takeOrderInternal({
            input: input,
            taker: payable(msg.sender),
            excessEth: excessEth,
            revertOnError: true
        });

        _refundExcessEth(excessEth);
    }

    /**
     * @dev Take multiple orders at once. The transaction won't revert if any take order fails, but
     * silently ignore it. Check the logs in the receipt to see if any failed.
     *
     * See `takeOrder` for more information about the opt-in.
     *
     * @param inputs the take order inputs
     */
    function takeOrders(DubiexLib.TakeOrderInput[] calldata inputs)
        external
        payable
        nonReentrant
        returns (bool[] memory)
    {
        require(!_killSwitchOn, "Dubiex: kill switch on");
        require(inputs.length > 0, "Dubiex: empty inputs");

        bool[] memory result = new bool[](inputs.length);

        uint256 excessEth = msg.value;

        for (uint256 i = 0; i < inputs.length; i++) {
            bool success;
            (success, excessEth, ) = _takeOrderInternal({
                input: inputs[i],
                taker: payable(msg.sender),
                excessEth: excessEth,
                revertOnError: false
            });

            result[i] = success;
        }

        _refundExcessEth(excessEth);

        return result;
    }

    /**
     * @dev Cancel a single order.
     */
    function cancelOrder(DubiexLib.CancelOrderInput memory input)
        external
        nonReentrant
    {
        _cancelOrderInternal({
            maker: input.maker,
            id: input.id,
            revertOnError: true,
            isKillSwitchOn: _killSwitchOn
        });
    }

    /**
     * @dev Cancel multiple orders at once. It will not revert on error, but ignore failed
     * orders silently. Check the logs in the receipt to see if any failed.
     *
     * @return Array of booleans with `ids.length` items where each item corresponds to an id
     * at the same index and `true` indicate success.
     */
    function cancelOrders(DubiexLib.CancelOrderInput[] calldata inputs)
        external
        nonReentrant
        returns (bool[] memory)
    {
        require(inputs.length > 0, "Dubiex: empty inputs");

        bool[] memory result = new bool[](inputs.length);

        bool isKillSwitchOn = _killSwitchOn;

        for (uint256 i = 0; i < inputs.length; i++) {
            result[i] = _cancelOrderInternal({
                maker: inputs[i].maker,
                id: inputs[i].id,
                revertOnError: false,
                isKillSwitchOn: isKillSwitchOn
            });
        }

        return result;
    }

    /**
     * @dev Create a new single order.
     *
     * @return the assigned order id
     */
    function _makeOrderInternal(
        DubiexLib.MakeOrderInput memory input,
        address payable maker,
        uint256 excessEth,
        bool revertOnUpdateError
    ) private returns (uint32, uint256) {
        require(
            maker != address(this) && maker != address(0),
            "Dubiex: unexpected maker"
        );

        // An explicit id means an existing order should be updated.
        if (input.orderId > 0) {
            return (
                _updateOrder(
                    maker,
                    input.orderId,
                    input.updatedRatioWei,
                    revertOnUpdateError
                ),
                // Update order never uses eth, so we refund everything in case something was mistakenly sent
                excessEth
            );
        }

        // Reverts if the input is invalid
        require(input.makerValue > 0, "Dubiex: zero makerValue");
        require(input.takerValue > 0, "Dubiex: zero takerValue");

        // Reverts if the order pair is incompatible
        uint32 orderPairAlias = _getOrCreateOrderPairAlias(input.pair);

        // Deposit the makerValue, which will fail if no approval has been given
        // or the maker hasn't enough funds.
        // NOTE(reentrancy): safe, because we are using `nonReentrant` for makeOrder(s).
        bool deposited;

        (deposited, excessEth) = _transfer({
            from: maker,
            to: payable(address(this)),
            value: input.makerValue,
            valueContractAddress: input.pair.makerContractAddress,
            valueCurrencyType: input.pair.makerCurrencyType,
            excessEth: excessEth
        });

        require(deposited, "Dubiex: failed to deposit");

        // Create the orderbook item
        DubiexLib.PackedOrderBookItem memory _packed;

        DubiexLib.UnpackedOrderBookItem memory _unpacked;
        _unpacked.id = _getNextOrderId(maker);
        _unpacked.makerValue = input.makerValue;
        _unpacked.takerValue = input.takerValue;
        _unpacked.orderPairAlias = orderPairAlias;
        _unpacked.flags.isMakerERC721 =
            input.pair.makerCurrencyType == DubiexLib.CurrencyType.ERC721;
        _unpacked.flags.isTakerERC721 =
            input.pair.takerCurrencyType == DubiexLib.CurrencyType.ERC721;

        // Pack unpacked data and write to storage
        _packed.packedData = DubiexLib.packOrderBookItem(_unpacked);

        bytes32 key = DubiexLib.getOrderKey(maker, _unpacked.id);
        _packedOrders[key] = _packed;

        // Emit event and done

        uint256 packedData;
        packedData |= input.makerValue;
        packedData |= uint256(input.takerValue) << 96;
        packedData |= uint256(orderPairAlias) << (96 + 96);

        emit MadeOrder(_unpacked.id, maker, input.pair, packedData);

        return (_unpacked.id, excessEth);
    }

    /**
     * @dev Take a make order.
     * @param input the take order input.
     * @param taker address of the taker
     * @param revertOnError whether to revert on errors or not. True, when taking a single order.
     *
     */
    function _takeOrderInternal(
        address payable taker,
        DubiexLib.TakeOrderInput memory input,
        uint256 excessEth,
        bool revertOnError
    )
        private
        returns (
            bool,
            uint256,
            DubiexLib.CurrencyType
        )
    {
        (
            bytes32 _orderKey,
            DubiexLib.PackedOrderBookItem storage _packed,
            DubiexLib.UnpackedOrderBookItem memory _unpacked
        ) = _assertTakeOrderInput(input, revertOnError);

        // Order doesn't exist or input is invalid.
        if (_unpacked.id == 0) {
            // Only gets here if 'revertOnError' is false
            return (false, excessEth, DubiexLib.CurrencyType.NULL);
        }

        // Get the actual makerValue, which might just be a fraction of the total
        // `takerValue` of the `_makeOrder`.
        //
        // makerValue = how much of the order will be filled
        // takerValue = how much the user is going to pay for it
        (uint96 _makerValue, uint96 _takerValue) = _calculateMakerAndTakerValue(
            _unpacked,
            input.takerValue,
            input.maxTakerMakerRatio
        );
        if (_makerValue == 0 || _takerValue == 0) {
            if (revertOnError) {
                revert("Dubiex: invalid takerValue");
            }

            return (false, excessEth, DubiexLib.CurrencyType.NULL);
        }

        // Transfer from taker to maker
        excessEth = _transferFromTakerToMaker(
            taker,
            input.maker,
            _takerValue,
            _unpacked.pair,
            excessEth
        );

        // Transfer from maker to taker
        if (
            !_transferFromContractToTaker(taker, _makerValue, _unpacked.pair, 0)
        ) {
            if (revertOnError) {
                revert("Dubiex: bad transfer to taker");
            }

            return (false, excessEth, DubiexLib.CurrencyType.NULL);
        }

        // If filled, the order can be deleted (without having to update the maker/taker value)
        if (_unpacked.makerValue - _makerValue == 0) {
            // Delete the filled order
            delete _packedOrders[_orderKey];
        } else {
            // Not filled yet, so update original make order
            _unpacked.makerValue -= _makerValue;
            _unpacked.takerValue -= _takerValue;

            // Write updated item to storage
            _packed.packedData = DubiexLib.packOrderBookItem(_unpacked);
        }

        // NOTE: We write the new taker/maker value to the in-memory struct
        // and pass it to a function that emits 'TookOrder' to avoid the 'Stack too deep' error
        _unpacked.makerValue = _makerValue;
        _unpacked.takerValue = _takerValue;

        return _emitTookOrder(input.maker, taker, _unpacked, excessEth);
    }

    /**
     * @dev Emit 'TookOrder' in a separate function to avoid the 'Stack too deep' error
     */
    function _emitTookOrder(
        address maker,
        address taker,
        DubiexLib.UnpackedOrderBookItem memory unpacked,
        uint256 excessEth
    )
        private
        returns (
            bool,
            uint256,
            DubiexLib.CurrencyType
        )
    {
        uint256 packedData;
        packedData |= unpacked.makerValue;
        packedData |= uint256(unpacked.takerValue) << 96;
        packedData |= uint256(unpacked.orderPairAlias) << (96 + 96);

        emit TookOrder(unpacked.id, maker, taker, packedData);

        return (true, excessEth, unpacked.pair.takerCurrencyType);
    }

    function _cancelOrderInternal(
        address payable maker,
        uint32 id,
        bool revertOnError,
        bool isKillSwitchOn
    ) private returns (bool) {
        // Anyone can cancel any order if the kill switch is on, otherwise `msg.sender` must be the maker.
        if (!isKillSwitchOn) {
            require(maker == msg.sender, "Dubiex: msg.sender must be maker");
        }

        if (!revertOnError && !_orderExists(maker, id)) {
            return false;
        }

        // Get the make order (reverts if order doesn't exist)
        (
            bytes32 _orderKey,
            ,
            DubiexLib.UnpackedOrderBookItem memory unpacked
        ) = _safeGetOrder(maker, id, DubiexLib.OrderPairReadStrategy.MAKER);

        // Transfer remaining `makerValue` back to maker, by assuming the taker role with the maker.

        if (
            !_transferFromContractToTaker({
                taker: maker,
                makerValue: unpacked.makerValue,
                pair: unpacked.pair,
                excessEth: 0
            })
        ) {
            return false;
        }

        // Delete the cancelled order
        delete _packedOrders[_orderKey];

        emit CanceledOrder(maker, id);

        return true;
    }

    /**
     * @dev Update the `takerValue` of an order using the given `updatedRatioWei`
     * @param maker the maker of the order to update
     * @param orderId the id of the existing order
     * @param updatedRatioWei the new ratio in wei
     */
    function _updateOrder(
        address maker,
        uint32 orderId,
        uint128 updatedRatioWei,
        bool revertOnUpdateError
    ) private returns (uint32) {
        (
            ,
            DubiexLib.PackedOrderBookItem storage _packed,
            DubiexLib.UnpackedOrderBookItem memory _unpacked
        ) = _getOrder(maker, orderId, DubiexLib.OrderPairReadStrategy.SKIP);

        // Order doesn't exist
        if (_unpacked.id == 0) {
            if (revertOnUpdateError) {
                revert("Dubiex: order does not exist");
            }

            return 0;
        }

        // We don't prevent reverts here, even if `revertOnUpdateError` is false since
        // they are user errors unlike a non-existing order which a user has no control over.

        require(updatedRatioWei > 0, "Dubiex: ratio is 0");

        require(
            !_unpacked.flags.isMakerERC721 && !_unpacked.flags.isTakerERC721,
            "Dubiex: cannot update ERC721"
        );

        // Update the existing order with the new ratio to the takerValue.
        // The makerValue stays untouched.

        uint256 updatedTakerValue = (uint256(_unpacked.makerValue) *
            uint256(updatedRatioWei)) / 1 ether;

        require(updatedTakerValue < 2**96, "Dubiex: takerValue overflow");

        _unpacked.takerValue = uint96(updatedTakerValue);
        _packed.packedData = DubiexLib.packOrderBookItem(_unpacked);

        emit UpdatedOrder(maker, orderId, updatedRatioWei);

        return orderId;
    }

    // If both returned values are > 0, then the provided `takerValue` and `maxTakerMakerRatio` are valid.
    function _calculateMakerAndTakerValue(
        DubiexLib.UnpackedOrderBookItem memory _unpacked, // storage item
        uint96 takerValue, // input.takerValue,
        uint256 maxTakerMakerRatio // input.maxTakerMakerRatio
    ) private pure returns (uint96, uint96) {
        uint256 calculatedMakerValue = _unpacked.makerValue;
        uint256 calculatedTakerValue = takerValue;

        // ERC721 cannot be bought/sold partially, therefore the `takerValue` must match the requested
        // value exactly.
        if (
            _unpacked.pair.makerCurrencyType == DubiexLib.CurrencyType.ERC721 ||
            _unpacked.pair.takerCurrencyType == DubiexLib.CurrencyType.ERC721
        ) {
            if (takerValue != _unpacked.takerValue) {
                return (0, 0);
            }

            // The order gets filled completely, so we use the values as is.
        } else {
            // Calculate the current takerMakerValue ratio and compare it to `maxTakerMakerRatio`.
            // If it is higher then the order will not be taken.
            uint256 takerMakerRatio = (uint256(_unpacked.takerValue) *
                1 ether) / _unpacked.makerValue;

            if (takerMakerRatio > maxTakerMakerRatio) {
                return (0, 0);
            }

            // don't pay more than needed
            // input.takerValue = min(input.takerValue, _unpacked.takerValue)
            //
            if (calculatedTakerValue > _unpacked.takerValue) {
                calculatedTakerValue = _unpacked.takerValue;
            }

            // Calculate actual makerValue for ETH/ERC20 trades which might only get partially filled by the
            // takerValue. Since we don't have decimals, we need to multiply by 10^18 and divide by it again at the end
            // to not lose any information.
            calculatedMakerValue *= 1 ether;
            calculatedMakerValue *= calculatedTakerValue;
            calculatedMakerValue /= _unpacked.takerValue;
            calculatedMakerValue /= 1 ether;

            // EXAMPLE
            //
            // seller 10 prps for 5 dubi
            // buyer  8 prps for 4 dubi
            //
            // order:
            //   maker=10 (prps)
            //   taker=5  (dubi)
            //
            // input:
            //   taker=4
            //   maxTakerMakerRatio=2
            //
            // takeRatio = 5 / 4  (we're going to buy 80% of the order)
            // makerV = 10 * takeRatio
        }

        // Sanity checks
        assert(
            calculatedMakerValue < 2**96 &&
                calculatedMakerValue <= _unpacked.makerValue
        );
        assert(
            calculatedTakerValue < 2**96 &&
                calculatedTakerValue <= _unpacked.takerValue
        );

        return (uint96(calculatedMakerValue), uint96(calculatedTakerValue));
    }

    /**
     * @dev Assert a take order input and return the order. If a zero-order is returned,
     * then it does not exist and it is up to the caller how to handle it.
     */
    function _assertTakeOrderInput(
        DubiexLib.TakeOrderInput memory input,
        bool revertOnError
    )
        private
        view
        returns (
            bytes32,
            DubiexLib.PackedOrderBookItem storage,
            DubiexLib.UnpackedOrderBookItem memory
        )
    {
        (
            bytes32 key,
            DubiexLib.PackedOrderBookItem storage packed,
            DubiexLib.UnpackedOrderBookItem memory unpacked
        ) = _getOrder(
                input.maker,
                input.id,
                DubiexLib.OrderPairReadStrategy.FULL
            );

        bool validTakerValue = input.takerValue > 0;
        bool orderExists = unpacked.id > 0;
        if (revertOnError) {
            require(validTakerValue, "Dubiex: zero takerValue");

            require(orderExists, "Dubiex: order does not exist");
        } else {
            if (!validTakerValue || !orderExists) {
                DubiexLib.UnpackedOrderBookItem memory emptyUnpacked;
                return (bytes32(0), _emptyOrder, emptyUnpacked);
            }
        }

        return (key, packed, unpacked);
    }

    function _orderExists(address maker, uint32 id)
        private
        view
        returns (bool)
    {
        bytes32 key = DubiexLib.getOrderKey(maker, id);

        DubiexLib.PackedOrderBookItem storage _packed = _packedOrders[key];
        if (_packed.packedData == 0) {
            return false;
        }

        return true;
    }

    function _refundExcessEth(uint256 excessEth) private {
        // Sanity check
        assert(msg.value >= excessEth);

        if (excessEth > 0) {
            payable(msg.sender).transfer(excessEth);
        }
    }

    // Transfer `takerValue` to `maker`.
    function _transferFromTakerToMaker(
        address payable taker,
        address payable maker,
        uint96 takerValue,
        DubiexLib.OrderPair memory pair,
        uint256 excessEth
    ) private returns (uint256) {
        bool success;
        (success, excessEth) = _transfer(
            taker,
            maker,
            takerValue,
            pair.takerContractAddress,
            pair.takerCurrencyType,
            excessEth
        );

        require(success, "Dubiex: bad transfer to maker");

        return excessEth;
    }

    // Transfer `makerValue` to `taker`
    function _transferFromContractToTaker(
        address payable taker,
        uint96 makerValue,
        DubiexLib.OrderPair memory pair,
        uint256 excessEth
    ) private returns (bool) {
        (bool success, ) = _transfer(
            payable(address(this)),
            taker,
            makerValue,
            pair.makerContractAddress,
            pair.makerCurrencyType,
            excessEth
        );

        return success;
    }

    function _transfer(
        address payable from,
        address payable to,
        uint256 value,
        address valueContractAddress,
        DubiexLib.CurrencyType valueCurrencyType,
        uint256 excessEth
    ) private returns (bool, uint256) {
        if (valueCurrencyType == DubiexLib.CurrencyType.ETH) {
            // Eth is a bit special, because it's not a token. Therefore we need to ensure
            // that the taker/maker sent enough eth (`excessEth` >= `value`) and also that
            // he is refunded at the end of the transaction properly.
            if (from != address(this)) {
                if (excessEth < value) {
                    return (false, excessEth);
                }

                // Got enough eth, but maybe too much, so we subtract the value from the excessEth. This is important
                // to refund the sender correctly e.g. he mistakenly sent too much or the order
                // was partially filled while his transaction was pending.
                excessEth -= value;
            }

            // Not a deposit, so transfer eth owned by this contract to maker or taker
            if (to != address(this)) {
                // https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/
                // https://ethereum.stackexchange.com/questions/78124/is-transfer-still-safe-after-the-istanbul-update
                // solhint-disable-next-line avoid-low-level-calls
                (bool success, ) = to.call{value: value}("");
                return (success, excessEth);
            }

            return (true, excessEth);
        }

        if (valueCurrencyType == DubiexLib.CurrencyType.ERC20) {
            IERC20 erc20 = IERC20(valueContractAddress);

            if (from == address(this)) {
                // If sending own tokens, use `safeTransfer` because Dubiex doesn't have any allowance
                // for itself which would cause `safeTransferFrom` to fail.
                erc20.safeTransfer(to, value);
            } else {
                erc20.safeTransferFrom(from, to, value);
            }

            return (true, excessEth);
        }

        if (valueCurrencyType == DubiexLib.CurrencyType.ERC721) {
            IERC721 erc721 = IERC721(valueContractAddress);
            erc721.safeTransferFrom(from, to, value, "");
            return (true, excessEth);
        }

        revert("Dubiex: unexpected currency type");
    }

    /**
     * @dev Validates that the given contract address and currency type are compatible.
     * @param currencyType type of the currency
     * @param contractAddress the contract address associated with currency
     */
    function _validateCurrencyType(
        DubiexLib.CurrencyType currencyType,
        address contractAddress
    ) private returns (bool) {
        if (currencyType == DubiexLib.CurrencyType.ETH) {
            require(
                contractAddress == address(0),
                "Dubiex: expected zero address"
            );
            return true;
        }

        if (currencyType == DubiexLib.CurrencyType.ERC721) {
            // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md
            //
            // `contractAddress` must implement the ERC721 standard. According to the ERC721 standard
            // every compliant token is also expected to use ERC165 for that.
            require(
                IERC165(contractAddress).supportsInterface(
                    type(IERC721).interfaceId
                ),
                "Dubiex: not ERC721 compliant"
            );
            return true;
        }

        if (currencyType == DubiexLib.CurrencyType.ERC20) {
            // Using `call` is our last-resort to check if the given contract implements
            // ERC721, since we can't just call `supportsInterface` directly without reverting
            // if `contractAddress` doesn't implement it. Unlike above, where we want an ERC721,
            // so reverting is fine for non-ERC721 contracts.
            //
            // solhint-disable-next-line avoid-low-level-calls
            (bool success, bytes memory result) = contractAddress.call(
                abi.encodeWithSelector(
                    IERC165.supportsInterface.selector,
                    type(IERC721).interfaceId
                )
            );

            // The call above must either fail (success = false) or if it succeeds,
            // return false.
            bool isERC721 = false;
            if (result.length > 0) {
                isERC721 = abi.decode(result, (bool));
            }

            require(!success || !isERC721, "Dubiex: ERC20 implements ERC721");

            // Lastly, we heuristically check if it responds to `balanceOf`.
            // If it succeeds, we assume it is an ERC20.
            result = Address.functionCall(
                contractAddress,
                abi.encodeWithSelector(
                    IERC20.balanceOf.selector,
                    contractAddress
                )
            );
            require(result.length > 0, "Dubiex: not ERC20 compliant");

            return true;
        }

        return false;
    }

    /**
     * @dev Increment the order id counter and return the new id.
     */
    function _getNextOrderId(address account) private returns (uint32) {
        uint32 currentId = _counters[account];

        uint32 nextId = currentId + 1;
        _counters[account] = nextId;

        return nextId;
    }

    /**
     * @dev Get or create order pair alias from the given order pair.
     */
    function _getOrCreateOrderPairAlias(DubiexLib.OrderPair memory pair)
        private
        returns (uint32)
    {
        // Some legacy applications might still be using the BOOSTED_ERC20 type. It is fully
        // superseded by ERC20.
        if (pair.makerCurrencyType == DubiexLib.CurrencyType.BOOSTED_ERC20) {
            pair.makerCurrencyType = DubiexLib.CurrencyType.ERC20;
        }

        if (pair.takerCurrencyType == DubiexLib.CurrencyType.BOOSTED_ERC20) {
            pair.takerCurrencyType = DubiexLib.CurrencyType.ERC20;
        }

        bytes32 orderPairHash = keccak256(
            abi.encode(
                pair.makerContractAddress,
                pair.takerContractAddress,
                pair.makerCurrencyType,
                pair.takerCurrencyType
            )
        );

        uint32 orderPairAlias = _orderPairAliasesByHash[orderPairHash];
        // If it doesn't exist yet, we create it (which makes the make order for the caller a bit more expensive).
        if (orderPairAlias == 0) {
            require(
                _validateCurrencyType(
                    pair.makerCurrencyType,
                    pair.makerContractAddress
                ),
                "Dubiex: maker pair mismatch"
            );
            require(
                _validateCurrencyType(
                    pair.takerCurrencyType,
                    pair.takerContractAddress
                ),
                "Dubiex: taker pair mismatch"
            );

            require(
                pair.takerContractAddress != pair.makerContractAddress,
                "Dubiex: order pair equal"
            );

            uint32 orderPairAliasCounter = _orderPairAliasCounter;
            orderPairAliasCounter++;
            // uint28.max = 2**28-1 = 268435455
            assert(orderPairAliasCounter < 268435455);

            orderPairAlias = orderPairAliasCounter;

            _orderPairAliasCounter = orderPairAliasCounter;

            // Write mappings
            _orderPairAliasesByHash[orderPairHash] = orderPairAlias;
            _orderPairsByAlias[orderPairAlias] = DubiexLib.packOrderPair(pair);
        }

        return orderPairAlias;
    }

    function _safeGetOrderPairByAlias(
        uint32 orderPairAlias,
        DubiexLib.OrderPairReadStrategy strategy
    ) private view returns (DubiexLib.OrderPair memory) {
        DubiexLib.OrderPair memory _unpackedOrderPair;

        if (strategy == DubiexLib.OrderPairReadStrategy.SKIP) {
            return _unpackedOrderPair;
        }

        DubiexLib.PackedOrderPair storage _pairStorage = _orderPairsByAlias[
            orderPairAlias
        ];

        // Read only maker info if requested
        if (
            strategy == DubiexLib.OrderPairReadStrategy.MAKER ||
            strategy == DubiexLib.OrderPairReadStrategy.FULL
        ) {
            (
                address makerContractAddress,
                DubiexLib.CurrencyType makerCurrencyType
            ) = DubiexLib.unpackOrderPairAddressType(_pairStorage.makerPair);
            _unpackedOrderPair.makerContractAddress = makerContractAddress;
            _unpackedOrderPair.makerCurrencyType = makerCurrencyType;

            require(
                _unpackedOrderPair.makerCurrencyType !=
                    DubiexLib.CurrencyType.NULL,
                "Dubiex: maker pair not found"
            );
        }

        // Read only taker info if requested
        if (
            strategy == DubiexLib.OrderPairReadStrategy.TAKER ||
            strategy == DubiexLib.OrderPairReadStrategy.FULL
        ) {
            (
                address takerContractAddress,
                DubiexLib.CurrencyType takerCurrencyType
            ) = DubiexLib.unpackOrderPairAddressType(_pairStorage.takerPair);
            _unpackedOrderPair.takerContractAddress = takerContractAddress;
            _unpackedOrderPair.takerCurrencyType = takerCurrencyType;

            require(
                _unpackedOrderPair.takerCurrencyType !=
                    DubiexLib.CurrencyType.NULL,
                "Dubiex: taker not found"
            );
        }

        return _unpackedOrderPair;
    }

    /**
     * @dev Returns the order from `account` with the given id from storage
     * plus it's order key.
     *
     * If it cannot be found, then this function reverts, because we expect the
     * caller to operate on existing orders.
     */
    function _safeGetOrder(
        address account,
        uint32 id,
        DubiexLib.OrderPairReadStrategy strategy
    )
        private
        view
        returns (
            bytes32,
            DubiexLib.PackedOrderBookItem storage,
            DubiexLib.UnpackedOrderBookItem memory
        )
    {
        bytes32 key = DubiexLib.getOrderKey(account, id);
        DubiexLib.PackedOrderBookItem storage _packed = _packedOrders[key];

        uint256 packedData = _packed.packedData;
        require(packedData > 0, "Dubiex: order does not exist");

        DubiexLib.UnpackedOrderBookItem memory _unpacked = DubiexLib
            .unpackOrderBookItem(packedData);

        _unpacked.pair = _safeGetOrderPairByAlias(
            _unpacked.orderPairAlias,
            strategy
        );

        return (key, _packed, _unpacked);
    }

    /**
     * @dev Returns the order from `account` with the given id from storage
     * plus it's order key.
     *
     * If it cannot be found, then this function does not revert and it's up to the
     * caller to decide.
     */
    function _getOrder(
        address account,
        uint32 id,
        DubiexLib.OrderPairReadStrategy strategy
    )
        private
        view
        returns (
            bytes32,
            DubiexLib.PackedOrderBookItem storage,
            DubiexLib.UnpackedOrderBookItem memory
        )
    {
        bytes32 key = DubiexLib.getOrderKey(account, id);
        DubiexLib.PackedOrderBookItem storage _packed = _packedOrders[key];

        uint256 packedData = _packed.packedData;
        if (packedData == 0) {
            DubiexLib.UnpackedOrderBookItem memory __unpacked;
            return (bytes32(0), _emptyOrder, __unpacked);
        }

        DubiexLib.UnpackedOrderBookItem memory _unpacked = DubiexLib
            .unpackOrderBookItem(packedData);

        // Read the order pair with the given strategy
        // NOTE: This cannot revert when the order exists.
        _unpacked.pair = _safeGetOrderPairByAlias(
            _unpacked.orderPairAlias,
            strategy
        );

        return (key, _packed, _unpacked);
    }
}

// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)

pragma solidity ^0.8.0;

/**
 * @dev Interface of the ERC20 standard as defined in the EIP.
 */
interface IERC20 {
    /**
     * @dev Returns the amount of tokens in existence.
     */
    function totalSupply() external view returns (uint256);

    /**
     * @dev Returns the amount of tokens owned by `account`.
     */
    function balanceOf(address account) external view returns (uint256);

    /**
     * @dev Moves `amount` tokens from the caller's account to `to`.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transfer(address to, uint256 amount) external returns (bool);

    /**
     * @dev Returns the remaining number of tokens that `spender` will be
     * allowed to spend on behalf of `owner` through {transferFrom}. This is
     * zero by default.
     *
     * This value changes when {approve} or {transferFrom} are called.
     */
    function allowance(address owner, address spender) external view returns (uint256);

    /**
     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * IMPORTANT: Beware that changing an allowance with this method brings the risk
     * that someone may use both the old and the new allowance by unfortunate
     * transaction ordering. One possible solution to mitigate this race
     * condition is to first reduce the spender's allowance to 0 and set the
     * desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     *
     * Emits an {Approval} event.
     */
    function approve(address spender, uint256 amount) external returns (bool);

    /**
     * @dev Moves `amount` tokens from `from` to `to` using the
     * allowance mechanism. `amount` is then deducted from the caller's
     * allowance.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transferFrom(
        address from,
        address to,
        uint256 amount
    ) external returns (bool);

    /**
     * @dev Emitted when `value` tokens are moved from one account (`from`) to
     * another (`to`).
     *
     * Note that `value` may be zero.
     */
    event Transfer(address indexed from, address indexed to, uint256 value);

    /**
     * @dev Emitted when the allowance of a `spender` for an `owner` is set by
     * a call to {approve}. `value` is the new allowance.
     */
    event Approval(address indexed owner, address indexed spender, uint256 value);
}

// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)

pragma solidity ^0.8.0;

import "../IERC20.sol";
import "../../../utils/Address.sol";

/**
 * @title SafeERC20
 * @dev Wrappers around ERC20 operations that throw on failure (when the token
 * contract returns false). Tokens that return no value (and instead revert or
 * throw on failure) are also supported, non-reverting calls are assumed to be
 * successful.
 * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,
 * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.
 */
library SafeERC20 {
    using Address for address;

    function safeTransfer(
        IERC20 token,
        address to,
        uint256 value
    ) internal {
        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));
    }

    function safeTransferFrom(
        IERC20 token,
        address from,
        address to,
        uint256 value
    ) internal {
        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));
    }

    /**
     * @dev Deprecated. This function has issues similar to the ones found in
     * {IERC20-approve}, and its usage is discouraged.
     *
     * Whenever possible, use {safeIncreaseAllowance} and
     * {safeDecreaseAllowance} instead.
     */
    function safeApprove(
        IERC20 token,
        address spender,
        uint256 value
    ) internal {
        // safeApprove should only be called when setting an initial allowance,
        // or when resetting it to zero. To increase and decrease it, use
        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'
        require(
            (value == 0) || (token.allowance(address(this), spender) == 0),
            "SafeERC20: approve from non-zero to non-zero allowance"
        );
        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));
    }

    function safeIncreaseAllowance(
        IERC20 token,
        address spender,
        uint256 value
    ) internal {
        uint256 newAllowance = token.allowance(address(this), spender) + value;
        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));
    }

    function safeDecreaseAllowance(
        IERC20 token,
        address spender,
        uint256 value
    ) internal {
        unchecked {
            uint256 oldAllowance = token.allowance(address(this), spender);
            require(oldAllowance >= value, "SafeERC20: bad allowance");
            uint256 newAllowance = oldAllowance - value;
            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));
        }
    }

    /**
     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement
     * on the return value: the return value is optional (but if data is returned, it must not be false).
     * @param token The token targeted by the call.
     * @param data The call data (encoded using abi.encode or one of its variants).
     */
    function _callOptionalReturn(IERC20 token, bytes memory data) private {
        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since
        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that
        // the target address contains contract code and also asserts for success in the low-level call.

        bytes memory returndata = address(token).functionCall(data, "SafeERC20: low-level call failed");
        if (returndata.length > 0) {
            // Return data is optional
            require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");
        }
    }
}

// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts v4.4.1 (token/ERC721/IERC721.sol)

pragma solidity ^0.8.0;

import "../../utils/introspection/IERC165.sol";

/**
 * @dev Required interface of an ERC721 compliant contract.
 */
interface IERC721 is IERC165 {
    /**
     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.
     */
    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);

    /**
     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.
     */
    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);

    /**
     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.
     */
    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);

    /**
     * @dev Returns the number of tokens in ``owner``'s account.
     */
    function balanceOf(address owner) external view returns (uint256 balance);

    /**
     * @dev Returns the owner of the `tokenId` token.
     *
     * Requirements:
     *
     * - `tokenId` must exist.
     */
    function ownerOf(uint256 tokenId) external view returns (address owner);

    /**
     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients
     * are aware of the ERC721 protocol to prevent tokens from being forever locked.
     *
     * Requirements:
     *
     * - `from` cannot be the zero address.
     * - `to` cannot be the zero address.
     * - `tokenId` token must exist and be owned by `from`.
     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.
     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.
     *
     * Emits a {Transfer} event.
     */
    function safeTransferFrom(
        address from,
        address to,
        uint256 tokenId
    ) external;

    /**
     * @dev Transfers `tokenId` token from `from` to `to`.
     *
     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.
     *
     * Requirements:
     *
     * - `from` cannot be the zero address.
     * - `to` cannot be the zero address.
     * - `tokenId` token must be owned by `from`.
     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.
     *
     * Emits a {Transfer} event.
     */
    function transferFrom(
        address from,
        address to,
        uint256 tokenId
    ) external;

    /**
     * @dev Gives permission to `to` to transfer `tokenId` token to another account.
     * The approval is cleared when the token is transferred.
     *
     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.
     *
     * Requirements:
     *
     * - The caller must own the token or be an approved operator.
     * - `tokenId` must exist.
     *
     * Emits an {Approval} event.
     */
    function approve(address to, uint256 tokenId) external;

    /**
     * @dev Returns the account approved for `tokenId` token.
     *
     * Requirements:
     *
     * - `tokenId` must exist.
     */
    function getApproved(uint256 tokenId) external view returns (address operator);

    /**
     * @dev Approve or remove `operator` as an operator for the caller.
     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.
     *
     * Requirements:
     *
     * - The `operator` cannot be the caller.
     *
     * Emits an {ApprovalForAll} event.
     */
    function setApprovalForAll(address operator, bool _approved) external;

    /**
     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.
     *
     * See {setApprovalForAll}
     */
    function isApprovedForAll(address owner, address operator) external view returns (bool);

    /**
     * @dev Safely transfers `tokenId` token from `from` to `to`.
     *
     * Requirements:
     *
     * - `from` cannot be the zero address.
     * - `to` cannot be the zero address.
     * - `tokenId` token must exist and be owned by `from`.
     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.
     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.
     *
     * Emits a {Transfer} event.
     */
    function safeTransferFrom(
        address from,
        address to,
        uint256 tokenId,
        bytes calldata data
    ) external;
}

// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts v4.4.1 (token/ERC721/utils/ERC721Holder.sol)

pragma solidity ^0.8.0;

import "../IERC721Receiver.sol";

/**
 * @dev Implementation of the {IERC721Receiver} interface.
 *
 * Accepts all token transfers.
 * Make sure the contract is able to use its token with {IERC721-safeTransferFrom}, {IERC721-approve} or {IERC721-setApprovalForAll}.
 */
contract ERC721Holder is IERC721Receiver {
    /**
     * @dev See {IERC721Receiver-onERC721Received}.
     *
     * Always returns `IERC721Receiver.onERC721Received.selector`.
     */
    function onERC721Received(
        address,
        address,
        uint256,
        bytes memory
    ) public virtual override returns (bytes4) {
        return this.onERC721Received.selector;
    }
}

// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)

pragma solidity ^0.8.0;

/**
 * @dev Contract module that helps prevent reentrant calls to a function.
 *
 * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier
 * available, which can be applied to functions to make sure there are no nested
 * (reentrant) calls to them.
 *
 * Note that because there is a single `nonReentrant` guard, functions marked as
 * `nonReentrant` may not call one another. This can be worked around by making
 * those functions `private`, and then adding `external` `nonReentrant` entry
 * points to them.
 *
 * TIP: If you would like to learn more about reentrancy and alternative ways
 * to protect against it, check out our blog post
 * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].
 */
abstract contract ReentrancyGuard {
    // Booleans are more expensive than uint256 or any type that takes up a full
    // word because each write operation emits an extra SLOAD to first read the
    // slot's contents, replace the bits taken up by the boolean, and then write
    // back. This is the compiler's defense against contract upgrades and
    // pointer aliasing, and it cannot be disabled.

    // The values being non-zero value makes deployment a bit more expensive,
    // but in exchange the refund on every call to nonReentrant will be lower in
    // amount. Since refunds are capped to a percentage of the total
    // transaction's gas, it is best to keep them low in cases like this one, to
    // increase the likelihood of the full refund coming into effect.
    uint256 private constant _NOT_ENTERED = 1;
    uint256 private constant _ENTERED = 2;

    uint256 private _status;

    constructor() {
        _status = _NOT_ENTERED;
    }

    /**
     * @dev Prevents a contract from calling itself, directly or indirectly.
     * Calling a `nonReentrant` function from another `nonReentrant`
     * function is not supported. It is possible to prevent this from happening
     * by making the `nonReentrant` function external, and making it call a
     * `private` function that does the actual work.
     */
    modifier nonReentrant() {
        // On the first call to nonReentrant, _notEntered will be true
        require(_status != _ENTERED, "ReentrancyGuard: reentrant call");

        // Any calls to nonReentrant after this point will fail
        _status = _ENTERED;

        _;

        // By storing the original value once again, a refund is triggered (see
        // https://eips.ethereum.org/EIPS/eip-2200)
        _status = _NOT_ENTERED;
    }
}

// SPDX-License-Identifier: MIT
pragma solidity 0.8.12;

// keccak256(abi.encode(maker, orderId))
type OrderKey is bytes32;

library DubiexLib {
    enum CurrencyType {
        NULL,
        ETH,
        ERC20,
        BOOSTED_ERC20, // LEGACY: only kept to not break existing applications, it's an alias for CurrencyType.ERC20
        ERC721
    }

    // Enum is used to read only a specific part of the order pair from
    // storage, since it is a bad idea to always perform 4 SLOADs.
    enum OrderPairReadStrategy {
        SKIP,
        MAKER,
        TAKER,
        FULL
    }

    struct OrderPair {
        address makerContractAddress;
        CurrencyType makerCurrencyType;
        address takerContractAddress;
        CurrencyType takerCurrencyType;
    }

    // To reduce the number of reads, the order pairs
    // are stored packed and on read unpacked as required.
    // Also see `OrderPair` and `OrderPairReadStrategy`.
    struct PackedOrderPair {
        // 20 bytes address + 1 byte currency type
        uint168 makerPair;
        // 20 bytes address + 1 byte currency type
        uint168 takerPair;
    }

    struct PackedOrderBookItem {
        // Serialized `UnpackedOrderBookItem`
        uint256 packedData;
    }

    struct UnpackedOrderBookItem {
        uint32 id;
        uint96 makerValue;
        uint96 takerValue;
        uint32 orderPairAlias;
        // The resolved pair based on the order pair alias
        OrderPair pair;
        OrderFlags flags;
    }

    // Struct that contains all unpacked data and the additional almost-always zero fields from
    // the packed order bookt item - returned from `getOrder()` to be more user-friendly to consume.
    struct PrettyOrderBookItem {
        uint32 id;
        uint96 makerValue;
        uint96 takerValue;
        uint32 orderPairAlias;
        OrderPair pair;
        OrderFlags flags;
    }

    struct OrderFlags {
        bool isMakerERC721;
        bool isTakerERC721;
    }

    function packOrderBookItem(UnpackedOrderBookItem memory _unpacked)
        internal
        pure
        returns (uint256)
    {
        // Bitpacking saves gas on read/write:

        // 61287 gas
        // struct Item1 {
        //     uint256 word1;
        //     uint256 word2;
        // }

        // // 62198 gas
        // struct Item2 {
        //     uint256 word1;
        //     uint128 a;
        //     uint128 b;
        // }

        // // 62374 gas
        // struct Item3 {
        //     uint256 word1;
        //     uint64 a;
        //     uint64 b;
        //     uint64 c;
        //     uint64 d;
        // }

        uint256 packedData;
        uint256 offset;

        // 1) Set first 32 bits to id
        uint32 id = _unpacked.id;
        packedData |= id;
        offset += 32;

        // 2) Set next 96 bits to maker value
        uint96 makerValue = _unpacked.makerValue;
        packedData |= uint256(makerValue) << offset;
        offset += 96;

        // 3) Set next 96 bits to taker value
        uint96 takerValue = _unpacked.takerValue;
        packedData |= uint256(takerValue) << offset;
        offset += 96;

        // 4) Set next 28 bits to order pair alias
        // Since it is stored in a uint32 AND it with a bitmask where the first 28 bits are 1
        uint32 orderPairAlias = _unpacked.orderPairAlias;
        uint32 orderPairAliasMask = (1 << 28) - 1;
        packedData |= uint256(orderPairAlias & orderPairAliasMask) << offset;
        offset += 28;

        // 5) Set remaining bits to flags
        OrderFlags memory flags = _unpacked.flags;
        if (flags.isMakerERC721) {
            // Maker currency type is ERC721
            packedData |= 1 << (offset + 0);
        }

        if (flags.isTakerERC721) {
            // Taker currency type is ERC721
            packedData |= 1 << (offset + 1);
        }

        offset += 2;

        // 2 bits unused
        assert(offset == 254);

        return packedData;
    }

    function unpackOrderBookItem(uint256 packedData)
        internal
        pure
        returns (UnpackedOrderBookItem memory)
    {
        assert(packedData > 0);

        UnpackedOrderBookItem memory _unpacked;
        uint256 offset;

        // 1) Read id from the first 32 bits
        _unpacked.id = uint32(packedData >> offset);
        offset += 32;

        // 2) Read maker value from next 96 bits
        _unpacked.makerValue = uint96(packedData >> offset);
        offset += 96;

        // 3) Read taker value from next 96 bits
        _unpacked.takerValue = uint96(packedData >> offset);
        offset += 96;

        // 4) Read order pair alias from next 28 bits
        uint32 orderPairAlias = uint32(packedData >> offset);
        uint32 orderPairAliasMask = (1 << 28) - 1;
        _unpacked.orderPairAlias = orderPairAlias & orderPairAliasMask;
        offset += 28;

        // NOTE: the caller still needs to read the order pair from storage
        // with the unpacked alias

        // 5) Read order flags from remaining bits
        OrderFlags memory flags = _unpacked.flags;

        flags.isMakerERC721 = (packedData >> (offset + 0)) & 1 == 1;
        flags.isTakerERC721 = (packedData >> (offset + 1)) & 1 == 1;

        offset += 2;

        // 2 bits unused

        assert(offset == 254);

        return _unpacked;
    }

    function packOrderPair(OrderPair memory unpacked)
        internal
        pure
        returns (PackedOrderPair memory)
    {
        uint168 packedMaker = uint160(unpacked.makerContractAddress);
        packedMaker |= uint168(unpacked.makerCurrencyType) << 160;

        uint168 packedTaker = uint160(unpacked.takerContractAddress);
        packedTaker |= uint168(unpacked.takerCurrencyType) << 160;

        return PackedOrderPair(packedMaker, packedTaker);
    }

    function unpackOrderPairAddressType(uint168 packed)
        internal
        pure
        returns (address, CurrencyType)
    {
        // The first 20 bytes of order pair are used for the maker address
        address unpackedAddress = address(uint160(packed));
        // The next 8 bits for the maker currency type
        CurrencyType unpackedCurrencyType = CurrencyType(uint8(packed >> 160));

        return (unpackedAddress, unpackedCurrencyType);
    }

    struct MakeOrderInput {
        uint96 makerValue;
        uint96 takerValue;
        OrderPair pair;
        // An id of an existing order can be optionally provided to
        // update the makerValue-takerValue ratio with a single call as opposed to cancel-then-make-new-order.
        uint32 orderId;
        // When calling make order using an existing order id, the `updatedRatio` will be applied on
        // the `makerValue` to calculate the new `takerValue`.
        uint128 updatedRatioWei;
    }

    struct TakeOrderInput {
        uint32 id;
        address payable maker;
        uint96 takerValue;
        // The expected max taker maker ratio of the order to take.
        uint256 maxTakerMakerRatio;
    }

    struct CancelOrderInput {
        uint32 id;
        address payable maker;
    }

    function getOrderKey(
        address maker,
        uint32 orderId
    ) internal pure returns (bytes32) {
        return keccak256(abi.encode(maker, orderId));
    }    
}

// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)

pragma solidity ^0.8.1;

/**
 * @dev Collection of functions related to the address type
 */
library Address {
    /**
     * @dev Returns true if `account` is a contract.
     *
     * [IMPORTANT]
     * ====
     * It is unsafe to assume that an address for which this function returns
     * false is an externally-owned account (EOA) and not a contract.
     *
     * Among others, `isContract` will return false for the following
     * types of addresses:
     *
     *  - an externally-owned account
     *  - a contract in construction
     *  - an address where a contract will be created
     *  - an address where a contract lived, but was destroyed
     * ====
     *
     * [IMPORTANT]
     * ====
     * You shouldn't rely on `isContract` to protect against flash loan attacks!
     *
     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets
     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract
     * constructor.
     * ====
     */
    function isContract(address account) internal view returns (bool) {
        // This method relies on extcodesize/address.code.length, which returns 0
        // for contracts in construction, since the code is only stored at the end
        // of the constructor execution.

        return account.code.length > 0;
    }

    /**
     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to
     * `recipient`, forwarding all available gas and reverting on errors.
     *
     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost
     * of certain opcodes, possibly making contracts go over the 2300 gas limit
     * imposed by `transfer`, making them unable to receive funds via
     * `transfer`. {sendValue} removes this limitation.
     *
     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].
     *
     * IMPORTANT: because control is transferred to `recipient`, care must be
     * taken to not create reentrancy vulnerabilities. Consider using
     * {ReentrancyGuard} or the
     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].
     */
    function sendValue(address payable recipient, uint256 amount) internal {
        require(address(this).balance >= amount, "Address: insufficient balance");

        (bool success, ) = recipient.call{value: amount}("");
        require(success, "Address: unable to send value, recipient may have reverted");
    }

    /**
     * @dev Performs a Solidity function call using a low level `call`. A
     * plain `call` is an unsafe replacement for a function call: use this
     * function instead.
     *
     * If `target` reverts with a revert reason, it is bubbled up by this
     * function (like regular Solidity function calls).
     *
     * Returns the raw returned data. To convert to the expected return value,
     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].
     *
     * Requirements:
     *
     * - `target` must be a contract.
     * - calling `target` with `data` must not revert.
     *
     * _Available since v3.1._
     */
    function functionCall(address target, bytes memory data) internal returns (bytes memory) {
        return functionCall(target, data, "Address: low-level call failed");
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with
     * `errorMessage` as a fallback revert reason when `target` reverts.
     *
     * _Available since v3.1._
     */
    function functionCall(
        address target,
        bytes memory data,
        string memory errorMessage
    ) internal returns (bytes memory) {
        return functionCallWithValue(target, data, 0, errorMessage);
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
     * but also transferring `value` wei to `target`.
     *
     * Requirements:
     *
     * - the calling contract must have an ETH balance of at least `value`.
     * - the called Solidity function must be `payable`.
     *
     * _Available since v3.1._
     */
    function functionCallWithValue(
        address target,
        bytes memory data,
        uint256 value
    ) internal returns (bytes memory) {
        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");
    }

    /**
     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but
     * with `errorMessage` as a fallback revert reason when `target` reverts.
     *
     * _Available since v3.1._
     */
    function functionCallWithValue(
        address target,
        bytes memory data,
        uint256 value,
        string memory errorMessage
    ) internal returns (bytes memory) {
        require(address(this).balance >= value, "Address: insufficient balance for call");
        require(isContract(target), "Address: call to non-contract");

        (bool success, bytes memory returndata) = target.call{value: value}(data);
        return verifyCallResult(success, returndata, errorMessage);
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
     * but performing a static call.
     *
     * _Available since v3.3._
     */
    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {
        return functionStaticCall(target, data, "Address: low-level static call failed");
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],
     * but performing a static call.
     *
     * _Available since v3.3._
     */
    function functionStaticCall(
        address target,
        bytes memory data,
        string memory errorMessage
    ) internal view returns (bytes memory) {
        require(isContract(target), "Address: static call to non-contract");

        (bool success, bytes memory returndata) = target.staticcall(data);
        return verifyCallResult(success, returndata, errorMessage);
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
     * but performing a delegate call.
     *
     * _Available since v3.4._
     */
    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {
        return functionDelegateCall(target, data, "Address: low-level delegate call failed");
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],
     * but performing a delegate call.
     *
     * _Available since v3.4._
     */
    function functionDelegateCall(
        address target,
        bytes memory data,
        string memory errorMessage
    ) internal returns (bytes memory) {
        require(isContract(target), "Address: delegate call to non-contract");

        (bool success, bytes memory returndata) = target.delegatecall(data);
        return verifyCallResult(success, returndata, errorMessage);
    }

    /**
     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the
     * revert reason using the provided one.
     *
     * _Available since v4.3._
     */
    function verifyCallResult(
        bool success,
        bytes memory returndata,
        string memory errorMessage
    ) internal pure returns (bytes memory) {
        if (success) {
            return returndata;
        } else {
            // Look for revert reason and bubble it up if present
            if (returndata.length > 0) {
                // The easiest way to bubble the revert reason is using memory via assembly

                assembly {
                    let returndata_size := mload(returndata)
                    revert(add(32, returndata), returndata_size)
                }
            } else {
                revert(errorMessage);
            }
        }
    }
}

// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)

pragma solidity ^0.8.0;

/**
 * @dev Interface of the ERC165 standard, as defined in the
 * https://eips.ethereum.org/EIPS/eip-165[EIP].
 *
 * Implementers can declare support of contract interfaces, which can then be
 * queried by others ({ERC165Checker}).
 *
 * For an implementation, see {ERC165}.
 */
interface IERC165 {
    /**
     * @dev Returns true if this contract implements the interface defined by
     * `interfaceId`. See the corresponding
     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]
     * to learn more about how these ids are created.
     *
     * This function call must use less than 30 000 gas.
     */
    function supportsInterface(bytes4 interfaceId) external view returns (bool);
}

// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts v4.4.1 (token/ERC721/IERC721Receiver.sol)

pragma solidity ^0.8.0;

/**
 * @title ERC721 token receiver interface
 * @dev Interface for any contract that wants to support safeTransfers
 * from ERC721 asset contracts.
 */
interface IERC721Receiver {
    /**
     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}
     * by `operator` from `from`, this function is called.
     *
     * It must return its Solidity selector to confirm the token transfer.
     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.
     *
     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.
     */
    function onERC721Received(
        address operator,
        address from,
        uint256 tokenId,
        bytes calldata data
    ) external returns (bytes4);
}